<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JSBridge</title>
    <url>/2020/07/21/JSBridge/</url>
    <content><![CDATA[<p>随着移动端盛行，不管是混合开发（Hybrid）应用，还是 React-Native 都离不开 JSBridge，当然也包括在国内举足轻重的微信小程序。</p>
<span id="more"></span>

<h1 id="JSBridge-的作用"><a href="#JSBridge-的作用" class="headerlink" title="JSBridge 的作用"></a>JSBridge 的作用</h1><p>通过 JSBridge 可以实现 H5 和 原生之间的<strong>双向</strong>通信，主要是给 H5 提供调用 原生（Native）功能的接口，让混合开发中的 H5 可以方便地使用地址位置、摄像头甚至支付等原生功能。</p>
<img src="/2020/07/21/JSBridge/jsbridge.png" class title="jsbridge">

<h1 id="JSBridge-的通信原理"><a href="#JSBridge-的通信原理" class="headerlink" title="JSBridge 的通信原理"></a>JSBridge 的通信原理</h1><p>主要有两种：注入 API 和 拦截 URL SCHEME。</p>
<h2 id="注入-API"><a href="#注入-API" class="headerlink" title="注入 API"></a>注入 API</h2><p>注入 API 方式是最常用的方式，主要原理是通过 <code>WebView</code> 提供的接口，向 JavaScript 的 Context（window）中注入对象或者方法，让 JavaScript 调用时，直接执行相应的 Native 代码逻辑，达到 JavaScript 调用 Native 的目的。</p>
<h3 id="注入-API-时，H5-端的代码"><a href="#注入-API-时，H5-端的代码" class="headerlink" title="注入 API 时，H5 端的代码"></a>注入 API 时，H5 端的代码</h3><h4 id="1）初始化-WebViewJavascriptBridge"><a href="#1）初始化-WebViewJavascriptBridge" class="headerlink" title="1）初始化 WebViewJavascriptBridge"></a>1）初始化 WebViewJavascriptBridge</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据navigator.userAgent来判断当前是 Android 还是 ios</span></span><br><span class="line"><span class="keyword">const</span> u = navigator.<span class="property">userAgent</span>;</span><br><span class="line"><span class="comment">// Android终端</span></span><br><span class="line"><span class="keyword">const</span> isAndroid = u.<span class="title function_">indexOf</span>(<span class="string">&quot;Android&quot;</span>) &gt; -<span class="number">1</span> || u.<span class="title function_">indexOf</span>(<span class="string">&quot;Adr&quot;</span>) &gt; -<span class="number">1</span>;</span><br><span class="line"><span class="comment">// IOS 终端</span></span><br><span class="line"><span class="keyword">const</span> isIOS = !!u.<span class="title function_">match</span>(<span class="regexp">/\(i[^;]+;( U;)? CPU.+Mac OS X/</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配合 IOS 使用时的初始化方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">iosFunction</span> = (<span class="params">callback</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">WebViewJavascriptBridge</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">callback</span>(<span class="variable language_">window</span>.<span class="property">WebViewJavascriptBridge</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">WVJBCallbacks</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">window</span>.<span class="property">WVJBCallbacks</span>.<span class="title function_">push</span>(callback);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">WVJBCallbacks</span> = [callback];</span><br><span class="line">  <span class="keyword">var</span> <span class="title class_">WVJBIframe</span> = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;iframe&quot;</span>);</span><br><span class="line">  <span class="title class_">WVJBIframe</span>.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;none&quot;</span>;</span><br><span class="line">  <span class="title class_">WVJBIframe</span>.<span class="property">src</span> = <span class="string">&quot;demo://__BRIDGE_LOADED__&quot;</span>;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="title function_">appendChild</span>(<span class="title class_">WVJBIframe</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="title function_">removeChild</span>(<span class="title class_">WVJBIframe</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配合 Android 使用时的初始化方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">androidFunction</span> = (<span class="params">callback</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">WebViewJavascriptBridge</span>) &#123;</span><br><span class="line">    <span class="title function_">callback</span>(<span class="variable language_">window</span>.<span class="property">WebViewJavascriptBridge</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(</span><br><span class="line">      <span class="string">&quot;WebViewJavascriptBridgeReady&quot;</span>,</span><br><span class="line">      <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">callback</span>(<span class="variable language_">window</span>.<span class="property">WebViewJavascriptBridge</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="literal">false</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">setupWebViewJavascriptBridge</span> = isAndroid ? androidFunction : iosFunction;</span><br><span class="line"></span><br><span class="line">isAndroid &amp;&amp;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">setupWebViewJavascriptBridge</span>(<span class="keyword">function</span> (<span class="params">bridge</span>) &#123;</span><br><span class="line">    <span class="comment">// 注册 H5 界面的默认接收函数</span></span><br><span class="line">    bridge.<span class="title function_">init</span>(<span class="keyword">function</span> (<span class="params">msg, responseCallback</span>) &#123;</span><br><span class="line">      <span class="title function_">responseCallback</span>(<span class="string">&quot;JS 返回给原生的消息内容&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h4 id="2）注册与原生交互的事件函数"><a href="#2）注册与原生交互的事件函数" class="headerlink" title="2）注册与原生交互的事件函数"></a>2）注册与原生交互的事件函数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bridge.registerHandler(&#x27;事件函数名&#x27;,fun 执行函数);</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">setupWebViewJavascriptBridge</span>(<span class="function">(<span class="params">bridge</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// data：原生传过来的数据;</span></span><br><span class="line">  <span class="comment">// callback: 原生传过来的回调函数</span></span><br><span class="line">  bridge.<span class="title function_">registerHandler</span>(<span class="string">&quot;H5Function&quot;</span>, <span class="function">(<span class="params">data, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    callback &amp;&amp; <span class="title function_">callback</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="3）调用原生注册的事件函数"><a href="#3）调用原生注册的事件函数" class="headerlink" title="3）调用原生注册的事件函数"></a>3）调用原生注册的事件函数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bridge.callHandler(&#x27;安卓端函数名&#x27;, &quot;传给原生端的数据&quot;, callback 回调函数);</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">setupWebViewJavascriptBridge</span>(<span class="function">(<span class="params">bridge</span>) =&gt;</span> &#123;</span><br><span class="line">  bridge.<span class="title function_">callHandler</span>(<span class="string">&quot;changeData&quot;</span>, data, <span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="拦截-URL-SCHEME"><a href="#拦截-URL-SCHEME" class="headerlink" title="拦截 URL SCHEME"></a>拦截 URL SCHEME</h2><p>先解释一下 URL SCHEME：URL SCHEME 是一种类似于 url 的链接，是为了方便 app 直接互相调用设计的，形式和普通的 url 近似，主要区别是 <code>protocol</code> 和 <code>host</code> 一般是自定义的</p>
<p>例如打开微信扫码的 SCHEME：weixin:&#x2F;&#x2F;scanqrcode<br>protocol 是 weixin，host 则是 scanqrcode</p>
<h3 id="拦截-URL-SCHEME-的主要流程"><a href="#拦截-URL-SCHEME-的主要流程" class="headerlink" title="拦截 URL SCHEME 的主要流程"></a>拦截 URL SCHEME 的主要流程</h3><p>Web 端通过某种方式（例如 <code>iframe.src</code>）发送 URL Scheme 请求，之后 Native 拦截到请求，并根据 URL SCHEME（包括所带的参数）进行相关操作（类似<code>JSONP</code>的方式）</p>
<h3 id="URL-SCHEME-的缺陷"><a href="#URL-SCHEME-的缺陷" class="headerlink" title="URL SCHEME 的缺陷"></a>URL SCHEME 的缺陷</h3><p>1）使用 <code>iframe.src</code> 发送 URL SCHEME 会有 url 长度的隐患<br>2）创建请求，需要一定的耗时，比注入 API 的方式调用同样的功能，耗时会较长</p>
]]></content>
  </entry>
  <entry>
    <title>JS 数组方法</title>
    <url>/2019/11/10/array-function/</url>
    <content><![CDATA[<h1 id="改变原数组的方法-9-个"><a href="#改变原数组的方法-9-个" class="headerlink" title="改变原数组的方法(9 个)"></a>改变原数组的方法(9 个)</h1><h2 id="1-splice-添加-删除数组元素"><a href="#1-splice-添加-删除数组元素" class="headerlink" title="1.splice() 添加 &#x2F; 删除数组元素"></a>1.splice() 添加 &#x2F; 删除数组元素</h2><p>splice() 方法向&#x2F;从数组中添加&#x2F;删除项目，然后返回被删除的项目</p>
<p><code>array.splice(index,howmany,item1,.....,itemX)</code></p>
<span id="more"></span>

<blockquote>
<p>index：必需。整数，规定添加&#x2F;删除项目的位置，使用负数可从数组结尾处规定位置。<br>howmany：可选。要删除的项目数量。如果设置为 0，则不会删除项目。<br>item1, …, itemX： 可选。向数组添加的新项目。<br>返回值: 如果有元素被删除,返回包含被删除项目的新数组。</p>
</blockquote>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从数组下标0开始，删除3个元素</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.<span class="title function_">splice</span>(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// [1,2,3]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// [4,5,6,7]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从最后一个元素开始删除3个元素，因为最后一个元素，所以只删除了7</span></span><br><span class="line"><span class="keyword">let</span> item = a.<span class="title function_">splice</span>(-<span class="number">1</span>, <span class="number">3</span>); <span class="comment">// [7]</span></span><br></pre></td></tr></table></figure>

<h3 id="删除并添加"><a href="#删除并添加" class="headerlink" title="删除并添加"></a>删除并添加</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从数组下标0开始，删除3个元素，并添加元素&#x27;添加&#x27;</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.<span class="title function_">splice</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="string">&quot;添加&quot;</span>); <span class="comment">// [1,2,3]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// [&#x27;添加&#x27;,4,5,6,7]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从数组最后第二个元素开始，删除3个元素，并添加两个元素&#x27;添加1&#x27;、&#x27;添加2&#x27;</span></span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> item = b.<span class="title function_">splice</span>(-<span class="number">2</span>, <span class="number">3</span>, <span class="string">&quot;添加1&quot;</span>, <span class="string">&quot;添加2&quot;</span>); <span class="comment">// [6,7]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// [1,2,3,4,5,&#x27;添加1&#x27;,&#x27;添加2&#x27;]</span></span><br></pre></td></tr></table></figure>

<h3 id="不删除只添加"><a href="#不删除只添加" class="headerlink" title="不删除只添加"></a>不删除只添加</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.<span class="title function_">splice</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;添加1&quot;</span>, <span class="string">&quot;添加2&quot;</span>); <span class="comment">// [] 没有删除元素，返回空数组</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// [&#x27;添加1&#x27;,&#x27;添加2&#x27;,1,2,3,4,5,6,7]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> item = b.<span class="title function_">splice</span>(-<span class="number">1</span>, <span class="number">0</span>, <span class="string">&quot;添加1&quot;</span>, <span class="string">&quot;添加2&quot;</span>); <span class="comment">// [] 没有删除元素，返回空数组</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// [1,2,3,4,5,6,&#x27;添加1&#x27;,&#x27;添加2&#x27;,7] 在最后一个元素的前面添加两个元素</span></span><br></pre></td></tr></table></figure>

<h2 id="2-sort-数组排序"><a href="#2-sort-数组排序" class="headerlink" title="2.sort() 数组排序"></a>2.sort() 数组排序</h2><p>sort() 方法对数组元素进行排序，并返回这个数组。</p>
<blockquote>
<p>参数可选: 规定排序顺序的比较函数。<br>默认情况下 sort() 方法没有传比较函数的话，默认按字母升序，如果不是元素不是字符串的话，会调用 <code>toString()</code> 方法将元素转化为字符串的 <code>Unicode</code> (万国码)位点，然后再比较字符。</p>
</blockquote>
<h3 id="不传参"><a href="#不传参" class="headerlink" title="不传参"></a>不传参</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串排列 看起来很正常</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Mango&quot;</span>];</span><br><span class="line">a.<span class="title function_">sort</span>(); <span class="comment">// [&quot;Apple&quot;,&quot;Banana&quot;,&quot;Mango&quot;,&quot;Orange&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数字排序的时候 因为转换成Unicode字符串之后，有些数字会比较大会排在后面 这显然不是我们想要的</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">8</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">sort</span>()); <span class="comment">// [1,10,20,25,3,8];</span></span><br></pre></td></tr></table></figure>

<h3 id="比较函数的两个参数："><a href="#比较函数的两个参数：" class="headerlink" title="比较函数的两个参数："></a>比较函数的两个参数：</h3><p>sort 的比较函数有两个默认参数，要在函数中接收这两个参数，这两个参数是数组中两个要比较的元素，通常我们用 a 和 b 接收两个将要比较的元素：</p>
<ul>
<li>若比较函数返回值 &lt;0 ，那么 a 将排到 b 的前面;</li>
<li>若比较函数返回值 &#x3D;0 ，那么 a 和 b 相对位置不变；</li>
<li>若比较函数返回值 &gt;0 ，那么 b 排在 a 将的前面；</li>
</ul>
<h3 id="数字升降序"><a href="#数字升降序" class="headerlink" title="数字升降序"></a>数字升降序</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">20</span>, <span class="number">4</span>, <span class="number">25</span>, <span class="number">8</span>];</span><br><span class="line">array.<span class="title function_">sort</span>(<span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array); <span class="comment">// [1,3,4,4,8,10,20,25];</span></span><br><span class="line"></span><br><span class="line">array.<span class="title function_">sort</span>(<span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> b - a;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array); <span class="comment">// [25,20,10,8,4,4,3,1];</span></span><br></pre></td></tr></table></figure>

<p>pop() 删除一个数组中的最后的一个元素<br>定义: pop() 方法删除一个数组中的最后的一个元素，并且返回这个元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.<span class="title function_">pop</span>(); <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// [1,2]</span></span><br></pre></td></tr></table></figure>

<h2 id="shift-删除数组的第一个元素"><a href="#shift-删除数组的第一个元素" class="headerlink" title="shift() 删除数组的第一个元素"></a>shift() 删除数组的第一个元素</h2><p>定义: shift()方法删除数组的第一个元素，并返回这个元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.<span class="title function_">shift</span>(); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// [2,3]</span></span><br></pre></td></tr></table></figure>

<h2 id="push-向数组的末尾添加元素"><a href="#push-向数组的末尾添加元素" class="headerlink" title="push() 向数组的末尾添加元素"></a>push() 向数组的末尾添加元素</h2><p>定义：push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。</p>
<p>参数: item1, item2, …, itemX ,要添加到数组末尾的元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.<span class="title function_">push</span>(<span class="string">&quot;末尾&quot;</span>, <span class="string">&quot;233&quot;</span>); <span class="comment">// 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// [1,2,3,&#x27;末尾&#x27;, &#x27;233&#x27;]</span></span><br></pre></td></tr></table></figure>

<h2 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h2><p>定义：unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。</p>
<p>参数: item1, item2, …, itemX ,要添加到数组开头的元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.<span class="title function_">unshift</span>(<span class="string">&quot;开头&quot;</span>, <span class="string">&quot;开头 2&quot;</span>); <span class="comment">// 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// [ &#x27;开头&#x27;, &#x27;开头 2&#x27;, 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure>

<h2 id="reverse-颠倒数组中元素的顺序"><a href="#reverse-颠倒数组中元素的顺序" class="headerlink" title="reverse() 颠倒数组中元素的顺序"></a>reverse() 颠倒数组中元素的顺序</h2><p>定义: reverse() 方法用于颠倒数组中元素的顺序。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a.<span class="title function_">reverse</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// [3,2,1]</span></span><br></pre></td></tr></table></figure>

<h1 id="不改变原数组的方法（8-个）"><a href="#不改变原数组的方法（8-个）" class="headerlink" title="不改变原数组的方法（8 个）"></a>不改变原数组的方法（8 个）</h1><h2 id="slice-浅拷贝数组的元素"><a href="#slice-浅拷贝数组的元素" class="headerlink" title="slice() 浅拷贝数组的元素"></a>slice() 浅拷贝数组的元素</h2><p>定义： 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象，且原数组不会被修改。</p>
<p>语法：<code>array.slice(begin, end);</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> b = a.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">1</span>); <span class="comment">// [&#x27;hello&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新数组是浅拷贝的，元素是简单数据类型，改变之后不会互相干扰。</span></span><br><span class="line"><span class="comment">// 如果是复杂数据类型(对象,数组)的话，改变其中一个，另外一个也会改变。</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="string">&quot;改变原数组&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b); <span class="comment">// [&#x27;改变原数组&#x27;,&#x27;world&#x27;] [&#x27;hello&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [&#123; <span class="attr">name</span>: <span class="string">&quot;OBKoro1&quot;</span> &#125;];</span><br><span class="line"><span class="keyword">let</span> b = a.<span class="title function_">slice</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b, a); <span class="comment">// [&#123;&quot;name&quot;:&quot;OBKoro1&quot;&#125;] [&#123;&quot;name&quot;:&quot;OBKoro1&quot;&#125;]</span></span><br><span class="line"><span class="comment">// a[0].name=&#x27;改变原数组&#x27;</span></span><br><span class="line"><span class="comment">// console.log(b,a) // [&#123;&quot;name&quot;:&quot;改变原数组&quot;&#125;] [&#123;&quot;name&quot;:&quot;改变原数组&quot;&#125;]</span></span><br></pre></td></tr></table></figure>

<h2 id="join-数组转字符串"><a href="#join-数组转字符串" class="headerlink" title="join() 数组转字符串"></a>join() 数组转字符串</h2><p>定义: join() 方法用于把数组中的所有元素通过指定的分隔符进行分隔放入一个字符串，返回生成的字符串。</p>
<p>语法: <code>array.join(str)</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> str = a.<span class="title function_">join</span>(); <span class="comment">// &#x27;hello,world&#x27;</span></span><br><span class="line"><span class="keyword">let</span> str2 = a.<span class="title function_">join</span>(<span class="string">&quot;+&quot;</span>); <span class="comment">// &#x27;hello+world&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [[<span class="string">&quot;OBKoro1&quot;</span>, <span class="string">&quot;23&quot;</span>], <span class="string">&quot;test&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> str1 = a.<span class="title function_">join</span>(); <span class="comment">// OBKoro1,23,test</span></span><br><span class="line"><span class="keyword">let</span> b = [&#123; <span class="attr">name</span>: <span class="string">&quot;OBKoro1&quot;</span>, <span class="attr">age</span>: <span class="string">&quot;23&quot;</span> &#125;, <span class="string">&quot;test&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> str2 = b.<span class="title function_">join</span>(); <span class="comment">// [object Object],test</span></span><br><span class="line"><span class="comment">// 对象转字符串推荐 JSON.stringify(obj)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结论：</span></span><br><span class="line"><span class="comment">// join()/toString() 方法在数组元素是数组的时候，会将里面的数组也调用 join()/toString() ,</span></span><br><span class="line"><span class="comment">// 如果是对象的话，对象会被转为 [object Object] 字符串。</span></span><br></pre></td></tr></table></figure>

<h2 id="toLocaleString-数组转字符串"><a href="#toLocaleString-数组转字符串" class="headerlink" title="toLocaleString() 数组转字符串"></a>toLocaleString() 数组转字符串</h2><p>定义: 返回一个表示数组元素的字符串。该字符串由数组中的每个元素的 <code>toLocaleString()</code> 返回值经调用 <code>join()</code> 方法连接（由逗号隔开）组成。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [&#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&#x27;OBKoro1&#x27;</span></span><br><span class="line">&#125;, <span class="number">23</span>, <span class="string">&#x27;abcd&#x27;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()]</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">join</span>(<span class="string">&quot;,&quot;</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">toString</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">toLocaleString</span>(<span class="string">&#x27;en-us&#x27;</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">toLocaleString</span>(<span class="string">&#x27;zh-cn&#x27;</span>))</span><br><span class="line"></span><br><span class="line">[object <span class="title class_">Object</span>],<span class="number">23</span>,abcd,<span class="title class_">Tue</span> <span class="title class_">Feb</span> <span class="number">26</span> <span class="number">2019</span> <span class="number">11</span>:<span class="number">47</span>:<span class="number">03</span> <span class="variable constant_">GMT</span>+<span class="number">0800</span> (中国标准时间)</span><br><span class="line">[object <span class="title class_">Object</span>],<span class="number">23</span>,abcd,<span class="title class_">Tue</span> <span class="title class_">Feb</span> <span class="number">26</span> <span class="number">2019</span> <span class="number">11</span>:<span class="number">47</span>:<span class="number">03</span> <span class="variable constant_">GMT</span>+<span class="number">0800</span> (中国标准时间)</span><br><span class="line">[object <span class="title class_">Object</span>],<span class="number">23</span>,abcd,<span class="number">2</span>/<span class="number">26</span>/<span class="number">2019</span>, <span class="number">11</span>:<span class="number">47</span>:<span class="number">03</span> <span class="variable constant_">AM</span></span><br><span class="line">[object <span class="title class_">Object</span>],<span class="number">23</span>,abcd,<span class="number">2019</span>/<span class="number">2</span>/<span class="number">26</span> 上午 <span class="number">11</span>:<span class="number">47</span>:<span class="number">03</span></span><br></pre></td></tr></table></figure>

<h2 id="concat-合并数组"><a href="#concat-合并数组" class="headerlink" title="concat 合并数组"></a>concat 合并数组</h2><p>定义： 方法用于合并两个或多个数组，返回一个新数组。</p>
<p>语法：<code>var newArr =oldArray.concat(arrayX,arrayX,......,arrayX)</code></p>
<p>参数：arrayX（必须）：该参数可以是具体的值，也可以是数组对象。可以是任意多个。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="comment">//连接两个数组</span></span><br><span class="line"><span class="keyword">let</span> newVal = a.<span class="title function_">concat</span>(b); <span class="comment">// [1,2,3,4,5,6]</span></span><br><span class="line"><span class="comment">// 连接三个数组</span></span><br><span class="line"><span class="keyword">let</span> c = [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">let</span> newVal2 = a.<span class="title function_">concat</span>(b, c); <span class="comment">// [1,2,3,4,5,6,7,8,9]</span></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line"><span class="keyword">let</span> newVal3 = a.<span class="title function_">concat</span>(<span class="string">&quot;添加元素&quot;</span>, b, c, <span class="string">&quot;再加一个&quot;</span>);</span><br><span class="line"><span class="comment">// [1,2,3,&quot;添加元素&quot;,4,5,6,7,8,9,&quot;再加一个&quot;]</span></span><br><span class="line"><span class="comment">// 合并嵌套数组 会浅拷贝嵌套数组</span></span><br><span class="line"><span class="keyword">let</span> d = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> f = [<span class="number">3</span>, [<span class="number">4</span>]];</span><br><span class="line"><span class="keyword">let</span> newVal4 = d.<span class="title function_">concat</span>(f); <span class="comment">// [1,2,3,[4]]</span></span><br></pre></td></tr></table></figure>

<h2 id="ES6-扩展运算符-…-合并数组"><a href="#ES6-扩展运算符-…-合并数组" class="headerlink" title="ES6 扩展运算符 … 合并数组"></a>ES6 扩展运算符 … 合并数组</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">4</span>, ...a, <span class="number">4</span>, <span class="number">4</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b); <span class="comment">//  [2, 3, 4, 5] [4,2,3,4,5,4,4]</span></span><br></pre></td></tr></table></figure>

<h2 id="indexOf-查找数组是否存在某个元素，返回下标"><a href="#indexOf-查找数组是否存在某个元素，返回下标" class="headerlink" title="indexOf() 查找数组是否存在某个元素，返回下标"></a>indexOf() 查找数组是否存在某个元素，返回下标</h2><p>定义: 返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。</p>
<p>p.s. 字符串也有此方法，要注意当 ‘lance’.indexOf(‘’) 一个空字符串时，返回 0 而不是-1</p>
<p>语法：<code>array.indexOf(searchElement,fromIndex)</code></p>
<p>参数：</p>
<blockquote>
<p>searchElement (必须):被查找的元素<br>fromIndex (可选):开始查找的位置(不能大于等于数组的长度，返回-1)，接受负值，默认值为 0。</p>
</blockquote>
<h3 id="严格相等的搜索"><a href="#严格相等的搜索" class="headerlink" title="严格相等的搜索:"></a>严格相等的搜索:</h3><p>数组的 indexOf 搜索跟字符串的 indexOf 不一样,数组的 indexOf 使用严格相等&#x3D;&#x3D;&#x3D;搜索元素，即数组元素要完全匹配才能搜索成功。</p>
<blockquote>
<p>注意：indexOf() 不能识别 NaN</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">&quot;啦啦&quot;</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">24</span>, <span class="title class_">NaN</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">indexOf</span>(<span class="string">&quot;啦&quot;</span>)); <span class="comment">// -1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">indexOf</span>(<span class="string">&quot;NaN&quot;</span>)); <span class="comment">// -1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">indexOf</span>(<span class="string">&quot;啦啦&quot;</span>)); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h2 id="lastIndexOf-查找指定元素在数组中的最后一个位置"><a href="#lastIndexOf-查找指定元素在数组中的最后一个位置" class="headerlink" title="lastIndexOf() 查找指定元素在数组中的最后一个位置"></a>lastIndexOf() 查找指定元素在数组中的最后一个位置</h2><p>定义: 方法返回指定元素,在数组中的最后一个的索引，如果不存在则返回 -1。（从数组后面往前查找）</p>
<p>语法：<code>arr.lastIndexOf(searchElement,fromIndex)</code></p>
<p>参数:</p>
<blockquote>
<p>searchElement(必须): 被查找的元素<br>fromIndex(可选): 逆向查找开始位置，默认值数组的 长度-1，即查找整个数组。</p>
</blockquote>
<p>关于 fromIndex 有三个规则:</p>
<ul>
<li>正值。如果该值大于或等于数组的长度，则整个数组会被查找。</li>
<li>负值。将其视为从数组末尾向前的偏移。(比如-2，从数组最后第二个元素开始往前查找)</li>
<li>负值。其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">&quot;OB&quot;</span>, <span class="number">4</span>, <span class="string">&quot;Koro1&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;Koro1&quot;</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="string">&quot;Koro1&quot;</span>]; <span class="comment">// 数组长度为 10</span></span><br><span class="line"><span class="comment">// let b=a.lastIndexOf(&#x27;Koro1&#x27;,4) // 从下标 4 开始往前找 返回下标 2</span></span><br><span class="line"><span class="comment">// let b=a.lastIndexOf(&#x27;Koro1&#x27;,100) // 大于或数组的长度 查找整个数组 返回 9</span></span><br><span class="line"><span class="comment">// let b=a.lastIndexOf(&#x27;Koro1&#x27;,-11) // -1 数组不会被查找</span></span><br><span class="line"><span class="keyword">let</span> b = a.<span class="title function_">lastIndexOf</span>(<span class="string">&quot;Koro1&quot;</span>, -<span class="number">9</span>); <span class="comment">// 从第二个元素 4 往前查找，没有找到 返回-1</span></span><br></pre></td></tr></table></figure>

<h2 id="ES7-includes-查找数组是否包含某个元素-返回布尔"><a href="#ES7-includes-查找数组是否包含某个元素-返回布尔" class="headerlink" title="ES7 includes() 查找数组是否包含某个元素 返回布尔"></a>ES7 includes() 查找数组是否包含某个元素 返回布尔</h2><p>定义： 返回一个布尔值，表示某个数组是否包含给定的值</p>
<p>语法：<code>array.includes(searchElement,fromIndex=0)</code></p>
<p>参数：</p>
<blockquote>
<p>searchElement (必须):被查找的元素<br>fromIndex (可选):默认值为 0 ，参数表示搜索的起始位置，接受负值。正值超过数组长度，数组不会被搜索，返回 false 。负值绝对值超过长数组度，重置从 0 开始搜索。</p>
</blockquote>
<ul>
<li>includes 方法是为了弥补 indexOf 方法的缺陷而出现的:</li>
<li>indexOf 方法不能识别 NaN</li>
<li>indexOf 方法检查是否包含某个值不够语义化，需要判断是否不等于 -1 ，表达不够直观</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">&quot;OB&quot;</span>, <span class="string">&quot;Koro1&quot;</span>, <span class="number">1</span>, <span class="title class_">NaN</span>];</span><br><span class="line"><span class="comment">// let b=a.includes(NaN) // true 识别NaN</span></span><br><span class="line"><span class="comment">// let b=a.includes(&#x27;Koro1&#x27;,100) // false 超过数组长度 不搜索</span></span><br><span class="line"><span class="comment">// let b=a.includes(&#x27;Koro1&#x27;,-3)  // true 从倒数第三个元素开始搜索</span></span><br><span class="line"><span class="comment">// let b=a.includes(&#x27;Koro1&#x27;,-100)  // true 负值绝对值超过数组长度，搜索整个数组</span></span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://juejin.im/post/5b0903b26fb9a07a9d70c7e0">js 数组详细操作方法及解析合集</a></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>自动化测试</title>
    <url>/2023/01/15/auto-testing/</url>
    <content><![CDATA[<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>为了更好的实施自动化测试，我们希望有一套简单但足够的自动化测试体系，能够从各个层面帮助我们开展自动化测试，从而交付高质量的软件代码。</p>
<p>本文包含三个部分，包括「测试流程」、「测试平台和工具」和「测试方法论」，各自关注不同的维度，整体形成一个良好的体系。</p>
<span id="more"></span>

<h1 id="测试流程"><a href="#测试流程" class="headerlink" title="测试流程"></a>测试流程</h1><p>测试流程关注测试开发的过程中，应该以怎样的流程来实施，以便测试的最佳效果。</p>
<h2 id="用例设计"><a href="#用例设计" class="headerlink" title="用例设计"></a>用例设计</h2><p>测试用例的设计需要考虑多个层面，尽量全方位的考虑所有场景，包括但不限于如下层面：</p>
<ol>
<li>用户故事，特定功能需要满足的用户场景</li>
<li>权限需求，不同权限可能的差异</li>
<li>异常场景，一些异常可能出现的问题，如何恢复</li>
<li>兼容性，对环境、设备、浏览器的要求</li>
<li>性能层面，数据量是否很大，是否有极致的性能需求<br>这上面的东西，是测试用例设计的需求，在需求明确之后，就可以针对它们设计具体的测试用例。</li>
</ol>
<p>好的测试用例是一个完备的集合，覆盖所有等价类与关键值，设计好的测试用例有三种常用的方式：</p>
<ol>
<li>等价类划</li>
<li>边界值</li>
<li>错误推测</li>
</ol>
<h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><p>测试用例的设计可以分为以下几个步骤：</p>
<ol>
<li>画一个较粗的业务流程图，包含所有的流程分支，图内每个节点可以较粗，比如“短信验证码登录”就是一个节点，先不用细分手机号是否已注册，或者对应的用户是什么身份。</li>
<li>我们把流程图中最长的主流程称为基本流 1，其他分支也依次标号，然后就可以组合出该流程图中所有可能的子流程，比如 1 + 2 + 4。<br>○ 当流程图比较复杂导致组合情况过多时，可以寻找解耦点將它拆分为两个甚至多个彼此之间耦合度较低的流程图，也就是说一个流程以哪一条路径执行基本不影响另一个流程的正确性。然后对拆分后的流程图罗列组合。<br>○ 我们可以进一步降低流程图的复杂度，不把“表单验证失败”的节点写在流程图中，每个表单的验证可以做成单独的测试用例。比如“短信验证码登录”的失败原因分为手机号格式不对、验证码错误、验证码过期等等，这些可以单独汇总在一个测试用例中去测试。</li>
<li>～～对上述的组合结果进行精简，依然从耦合度的角度去考虑。假设我们的组合中有 1 + 2、1 + 3 和 1 + 2 + 3，而分支 3 的执行与否对分支 2 的正确性几无影响，那么在已测试 1 + 2 和 1 + 3 的基础上，1 + 2 + 3 的性价比非常低，对测试效果的提升很小，可以被精简掉。这个比较依赖设计者的经验去判断哪些是“无意义”的组合。～～<br>○ 这一条先注释掉，不太好解释和实施，需要在实践中再打磨。</li>
<li>为精简后的每一个组合编写一个测试用例。对于用例中的每一个节点步骤，此时要考虑它的细分场景。比如“短信验证码登录”，需要先按业务场景拆分为学生登录、老师登录、家长登录、未注册手机号登录 4 种可能性。<br>○ 原则上每一种可能性都应当是一个单独的测试用例，但为了不重复编写差别很小的用例，我们可以在一个用例中描述一个节点的多个输入值。在实际执行用例时，可以选择在一个节点上测试多个输入值再继续往下也可以每个输入值都跑一遍用例中的流程，这个也需要执行者依靠经验来灵活判断。<br>○ 我们需要同时在测试用例管理工具中保存业务流程图，为执行者理解测试用例和设计者将来随着业务变化更新测试用例提供方便。<br>○ 设计测试用例是一个再次检查产品逻辑严密性的好时机，遇到问题需要及时与产品经理沟通。<br>○ 很多用例，尤其是表单验证类的，需要用等价类划分和边界值的方法去设计多种输入值。</li>
<li>然后设计者需要基于对业务的了解补充针对不在正常业务逻辑中的异常场景、安全性敏感场景、性能敏感场景的测试用例，就得到了完整的冒烟测试和黑盒测试集。<br>○ 有些“副作用”式的功能可以考虑集中在一个测试用例中描述，比如任务的推送，可以写一个测试用例集中测试，包括任务的创建、修改、驳回等各种情况的推送。</li>
<li>最后我们需要根据黑盒测试集做 E2E UI 自动化测试，考虑到编写效率和运行效率，思路是一长多短：<br>a. 在一个模块的用例中取一个最长的基本流先实现。<br>b. 实现其他未被覆盖的短分支。</li>
</ol>
<h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>这是一个 App 用手机号登录后选择身份进入主页的流程图，按照上文我们提供的方法：<br><img src="/images/test.png" alt="test"></p>
<ol>
<li>这个流程原本属于一个更长的流程，前面是手机号登录的流程，两部分加起来是一个完整的 App 登录流程，但是我们认为这个子流程之间的耦合度不高，所以选择了在中间解耦，变成两个流程分别测试。</li>
<li>在编写黑盒测试用例时，我们得到的组合集是：<br>a. 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5<br>b. 1 -&gt; 4 -&gt; 5<br>c. 1 -&gt; 4 -&gt; 3 -&gt; 4 -&gt; 5<br>外加一个绑定新身份时的表单验证。</li>
<li>在编写 E2E UI 自动化测试时，我们先实现最长基本流，然后实现剩下的短分支，所以最后编写的用例是：<br>a. 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5<br>b. 1 -&gt; 4 -&gt; 5<br>c. 1 -&gt; 4 -&gt; 3</li>
</ol>
<h2 id="测试规划"><a href="#测试规划" class="headerlink" title="测试规划"></a>测试规划</h2><p>在需求明确之后，有大致的测试用例之后，应该对测试的实施有一个大致的规划，一定程度的明确各个类型的测试做多少，怎么做。</p>
<p>比如对于复杂的项目，我们可能需要更多的单元测试，从而保证逻辑的正确性，对于简单的项目，可能一定的功能测试和 E2E 测试就可以了。</p>
<p>测试规划的时候，应该考虑到各种测试类型擅长的和不擅长的，合理安排比例以及覆盖场景，在成本可控的前提下实现效率的最大化。</p>
<h2 id="测试开发"><a href="#测试开发" class="headerlink" title="测试开发"></a>测试开发</h2><p>规划完毕之后，就可以和代码开发一起，进入测试开发的环节，在开发的过程中，一定会发现之前没有考虑到的情况，或者发现效率更高的方法，这时及时调整策略，优化方案。</p>
<h1 id="测试平台与工具"><a href="#测试平台与工具" class="headerlink" title="测试平台与工具"></a>测试平台与工具</h1><p>测试平台和工具包含测试工具相关的东西，通过优秀工具的使用和研发，让测试开发能够非常简单的进行，找到测试开发的乐趣。</p>
<h2 id="测试数据管理平台"><a href="#测试数据管理平台" class="headerlink" title="测试数据管理平台"></a>测试数据管理平台</h2><p>测试数据是进行高效测试的基础，尤其是对于我们这种 toB 复杂业务逻辑来说，如果没有良好基础测试数据的支持，我们将花费大量时间在测试数据的准备上，测试的编写和维护将会变成一件很难受的工作。</p>
<p>为了解决这个问题，我们引入测试数据管理平台，他能够帮助我们管理各种测试数据，需要的时候，通过很简单的方式就可能调用这些测试数据，减少人工构造的成本。</p>
<p>这之中的测试数据将主要用到以下四个地方：</p>
<ol>
<li>后端功能测试</li>
<li>前端 E2E 测试</li>
<li>demo 系统</li>
<li>开发环境</li>
</ol>
<p>对这个平台而言，它将提供如下功能：</p>
<ol>
<li>测试数据存储与管理</li>
<li>测试数据的写入与生成</li>
<li>多套后端服务的配置管理，同一个平台，可以向多个后端写入数据？</li>
<li>通过对外 API，能够通过 API 执行指定的命令</li>
<li>依据 client 请求执行单个&#x2F;批量数据请求&#x2F;写入操作</li>
</ol>
<p>目前这个平台主要提供一套相对固定的数据， 将来，它应该有能力按需及时生成一部分数据，能够用于对数据之间关系要求不高的场景。</p>
<h2 id="后端测试工具"><a href="#后端测试工具" class="headerlink" title="后端测试工具"></a>后端测试工具</h2><p>为了改善后端测试的效率，我们已经&#x2F;需要开发一些测试工具，让测试开发更简单，主要包含如下几个部分：</p>
<ol>
<li>基础测试工具，是对开源工具的改善和封装，比如 UTL <a href="https://git.seiue.com/open-source/utl/tree/master">https://git.seiue.com/open-source/utl/tree/master</a></li>
<li>应用层相关工具，比如 <a href="https://www.yuque.com/kovru3/gfdy75/ygtibk">https://www.yuque.com/kovru3/gfdy75/ygtibk</a> 这里面说的</li>
<li>与测试数据平台的交互，交互方式是什么？类似 UDS 注册的机制？</li>
<li>Reponse 与 schema 定义的一致性检查</li>
</ol>
<h2 id="前端测试工具"><a href="#前端测试工具" class="headerlink" title="前端测试工具"></a>前端测试工具</h2><p>同理，前端差不多，可能包含如下几个部分：</p>
<ol>
<li>基础测试工具最佳实践，封装</li>
<li>数据 Mock 的机制，什么时候 Mock</li>
<li>测试数据平台通信的方式</li>
</ol>
<h1 id="测试方法论"><a href="#测试方法论" class="headerlink" title="测试方法论"></a>测试方法论</h1><h2 id="编写可测试代码"><a href="#编写可测试代码" class="headerlink" title="编写可测试代码"></a>编写可测试代码</h2><p>为了良好的实施自动化测试，我们对各方实施一定的约束，以便能够高效的开展自动化测试，让自动化测试的效能最大化。</p>
<h2 id="被测主体约束"><a href="#被测主体约束" class="headerlink" title="被测主体约束"></a>被测主体约束</h2><p>被测试主体（包括但不限于后端服务，前端组件，数据层）都应该提供良好的数据测试支持，这样测试代码才能够很好的与测试主体进行交互，从而高效的完成测试。</p>
<p>比如，后端在进行 API 设计的时候需要考虑到测试的场景，能够通过 API 准备需要的测试数据，也可能需要给测试提供专用的 API。</p>
<p>前端可能将数据数据操作接口暴露到外部，能够让测试代码直接操作内部方法和数据，以便方便高效的完成自动化测试（见附[1]）。</p>
<p>被测试主体应该同时满足多方面的需求，包括但不限于：</p>
<ol>
<li>业务需求</li>
<li>测试需求</li>
<li>架构需求</li>
</ol>
<h3 id="代码约束"><a href="#代码约束" class="headerlink" title="代码约束"></a>代码约束</h3><p>为了进行良好的单元测试，对我们的代码也提出了更高的要求，我们的代码需要更好的可测试性，具体来说包含如下几个方面：</p>
<ol>
<li>功能划分清晰，职责分明，函数、类的实现应该高内聚，底耦合，一个方法只做一件事</li>
<li>外部依赖显式化，依赖的东西应该单独测试 附[2]</li>
<li>尽量避免副作用，输入输出应该简单统一</li>
<li>More needed</li>
</ol>
<h2 id="数据与行为分离"><a href="#数据与行为分离" class="headerlink" title="数据与行为分离"></a>数据与行为分离</h2><p>在测试中，有很多时候我们需要对同一个场景使用不同的数据进行测试，同时期望获取不同的结果，这时如果测试数据和测试代码耦合在一起，就需要将他们同时复制多份，代码可读性和维护起来都是一个问题。</p>
<p>这时，我们可以采用数据与行为分离的策略，将测试行为抽象出来，然后再用给定的数据跑测试。</p>
<p>在 PHP 项目中，我们可以 PHPUnit 的 DataProvider 实现这样的策略，在前端的 Jest 中，也可以使用 jest.each 达成同样的效果。不同测试框架都应该有类似的支持（hmmm, Cypress 好像没有原生的支持）。</p>
<h2 id="App-Actions"><a href="#App-Actions" class="headerlink" title="App Actions"></a>App Actions</h2><p>在 E2E 测试中，传统的做法是封装 PageObject，用来封装 UI 层的操作，以便让测试代码更加易于维护，但因为 UI 层的变化一般比较大，这一层的封装成本比较高，而且所有地方都通过 UI 来操作效率很低，稳定性也不好。</p>
<p>所以，Cypress 采用了另外的思路，就是直接在测试代码中操作应用的内部逻辑，我们把这种方式称作 App Actions。某种程度上去掉了和简化了 PageObject 这个封装，从而减少的响应的成本。</p>
<p>它的缺点是需要理解应用的内部状态，但因为我们是开发者自己写测试，所以这个反而变成了优点。</p>
<p>读者具体可以查看 <a href="https://www.cypress.io/blog/2019/01/03/stop-using-page-objects-and-start-using-app-actions/">Stop using Page Objects and Start using App Actions</a> 了解更详细的内容。</p>
<h1 id="实施计划"><a href="#实施计划" class="headerlink" title="实施计划"></a>实施计划</h1><p>测试数据平台<br>[ ] 测试平台准备工作（P0）<br>[ ] 方案优化空间<br>[ ] 环境初始化<br>[ ] 对外提供 API (P1)</p>
<p>测试数据<br>[ ] 用户数据 (P0)<br>[ ] What’s else?</p>
<p>测试工具<br>[ ] 后端测试工具整理和规范 UTL<br>[ ] 后端针对 Event 和 Job 的测试工具<br>[ ] 后端 response 与 schema 的一致性检查 (P0)<br>[ ] 后端与测试平台的交互机制？(P0)<br>[ ] 前端测试工具的实践<br>[ ] 前端与测试平台的交互机制 (P0)<br>[ ] 前端 Mock 的场景与机制</p>
<p>测试流程&#x2F;方法论<br>[ ] 形成最佳实践（跟随实践不断迭代）</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>[1] <a href="https://www.cypress.io/blog/2019/01/03/stop-using-page-objects-and-start-using-app-actions/">https://www.cypress.io/blog/2019/01/03/stop-using-page-objects-and-start-using-app-actions/</a><br>[2] <a href="http://www.voidcn.com/article/p-uyjitnuy-bno.html">http://www.voidcn.com/article/p-uyjitnuy-bno.html</a></p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>兼容性</title>
    <url>/2023/12/15/compatibility/</url>
    <content><![CDATA[<h1 id="经常遇到的浏览器的兼容性有哪些？"><a href="#经常遇到的浏览器的兼容性有哪些？" class="headerlink" title="经常遇到的浏览器的兼容性有哪些？"></a>经常遇到的浏览器的兼容性有哪些？</h1><ol>
<li><p>IE 浏览器不支持 <code>Promise</code><br>babel-polyfill → webpack.config.js 的 entry 中设置 [‘babel-polyfill’, ‘.&#x2F;src&#x2F;main.js’]</p>
</li>
<li><p>各浏览器之间默认样式的差异<br>normalize.css<br>与 reset 区别 → normalize.css 消除各浏览器之间默认样式的差异、保留有用的默认样式；<br>而 reset 会清除所有的默认样式，过于暴力，例如会让 h 标题标签不再默认加粗，ul li 前面默认的小圆点也没了）</p>
<span id="more"></span></li>
<li><p>html5 某些新增标签不被识别<br>html5shiv.js - 解决 ie9 以下对 html5 某些新增标签不识别的问题（e.g. video 标签不识别不显示）<br>用法：[if lt IE 9]&gt;<script> src="<a href="http://html5shim.googlecode.com/svn/trunk/html5.js">http://html5shim.googlecode.com/svn/trunk/html5.js</a>"</script>&lt;![endif]<br>通过 <code>document.createElement</code> 方法产生的标签， 可以利用这一特性让这些浏览器支持 HTML5 新标签，浏览器支持新标签后，还需要添加标签默认的样式。</p>
</li>
<li><p>CSS3 媒体查询失效<br>respond.js - 能解决 ie9 以下不支持媒体查询问题</p>
</li>
<li><p>自动添加浏览器前缀<br>posscss-loader+autoprefixer</p>
</li>
<li><p>ie6 不支持 <code>min-height/width</code><br>添加额外的 _min-height ie6 识别</p>
</li>
<li><p>常见 <code>hack</code>（针对特定 ie 版本的样式控制）<br>_color - ie6 识别<br>*color - ie6&#x2F;7 识别<br>color: red\9; ie8 及以下识别</p>
</li>
<li><p>ie 条件注释写法：(lt 小于 | gt 大于 | lte 小于等于 | gte 大于等于 | ! 不等于)</p>
</li>
</ol>
<hr>
<h1 id="移动端兼容性？"><a href="#移动端兼容性？" class="headerlink" title="移动端兼容性？"></a>移动端兼容性？</h1><ol>
<li><p>移动端点透问题<a href="https://www.cnblogs.com/zhuzhenwei918/p/7588553.html">(解决办法)</a></p>
</li>
<li><p>ios 滚动卡顿<br>使用 better-scroll 插件</p>
</li>
<li><p>ios 顶部输入框 fixed 布局失效（当键盘弹起时）❌</p>
</li>
<li><p>安卓 键盘遮挡输入框 ❌</p>
</li>
<li><p>position:fixed; 在 android 下无效怎么处理？【❌ 待验证】</p>
<blockquote>
<p>原因：fixed 的元素是相对整个页面固定位置的，你在屏幕上滑动只是在移动这个所谓的 viewport ， 原来的网页还好好的在那，fixed 的内容也没有变过位置。</p>
</blockquote>
</li>
</ol>
<p>解决：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;meta</span><br><span class="line">  name=<span class="string">&quot;viewport&quot;</span></span><br><span class="line">  content=<span class="string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？❌<br>click 有 300ms 延迟,为了实现 safari 的双击事件的设计，浏览器要知道你是不是要双击操作。</li>
</ol>
<hr>
<h1 id="Polyfill"><a href="#Polyfill" class="headerlink" title="Polyfill"></a>Polyfill</h1><h2 id="什么是-Polyfill"><a href="#什么是-Polyfill" class="headerlink" title="什么是 Polyfill"></a>什么是 Polyfill</h2><p>polyfill 是“在旧版浏览器上复制标准 API 的 JavaScript 补充”,可以动态地加载 JavaScript 代码或库，在不支持这些标准 API 的浏览器中模拟它们。</p>
<p>例如，geolocation（地理位置）polyfill 可以在 navigator 对象上添加全局的 geolocation 对象，还能添加 getCurrentPosition 函数以及“坐标”回调对象， 所有这些都是 W3C 地理位置 API 定义的对象和函数。</p>
<p>因为 polyfill 模拟标准 API，所以能够以一种面向所有浏览器未来的方式针对这些 API 进行开发， 一旦对这些 API 的支持变成绝对大多数，则可以方便地去掉 polyfill，无需做任何额外工作。</p>
<ul>
<li>做的项目中，有没有用过或自己实现一些 polyfill 方案（兼容性处理方案）？❌<br>比如： html5shiv、Geolocation、Placeholder</li>
</ul>
<hr>
<h1 id="列举-IE-与其他浏览器不一样的特性？"><a href="#列举-IE-与其他浏览器不一样的特性？" class="headerlink" title="列举 IE 与其他浏览器不一样的特性？"></a>列举 IE 与其他浏览器不一样的特性？</h1><p><strong>事件目标对象</strong></p>
<p>触发事件的元素被认为是目标（target）。而在 IE 中，目标包含在 <code>event</code> 对象的 <code>srcElement</code> 属性</p>
<p><strong>获取字符代码</strong></p>
<p>如果按键代表一个字符（shift、ctrl、alt 除外），IE 的 <code>keyCode</code> 会返回字符代码（Unicode），DOM 中按键的代码和字符是分离的，要获取字符代码，需要使用 <code>charCode</code> 属性</p>
<p><strong>阻止某个事件的默认行为</strong></p>
<p>IE 中阻止某个事件的默认行为，必须将 <code>returnValue</code> 属性设置为 <code>false</code>，Mozilla 中，需要调用 <code>preventDefault()</code> 方法</p>
<p><strong>停止事件冒泡</strong></p>
<p>IE 中阻止事件进一步冒泡，需要设置 <code>cancelBubble</code> 为 true，Mozzilla 中，需要调用 <code>stopPropagation()</code></p>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
  </entry>
  <entry>
    <title>compose函数组合</title>
    <url>/2019/10/10/compose/</url>
    <content><![CDATA[<p>在函数式编程当中有一个很重要的概念就是函数组合，实际上就是<strong>把处理数据的函数像管道一样连接起来，然后让数据穿过管道得到最终的结果</strong></p>
<p>在多个框架源码中都有用到，比如 redux、koa 中多次遇到这个方法</p>
<span id="more"></span>

<p>效果：将一系列函数，通过 <code>compose</code> 函数组合起来，像管道一样连接起来，比如函数结合<code>[f, g, h ]</code>，通过 <code>compose</code> 最终达到这样的效果： <code>f(g(h()))</code></p>
<p>compose 函数要求：可执行同步方法，也可执行异步方法，两者都可以兼容</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compose</span>(<span class="params">list</span>) &#123;</span><br><span class="line">  <span class="comment">// 取出第一个函数，当做reduce函数的初始值</span></span><br><span class="line">  <span class="keyword">const</span> init = list.<span class="title function_">shift</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...arg</span>) &#123;</span><br><span class="line">    <span class="comment">// 执行compose函数，返回一个函数</span></span><br><span class="line">    <span class="keyword">return</span> list.<span class="title function_">reduce</span>(</span><br><span class="line">      <span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 返回list.reduce的结果，为一个promise实例，外部就可以通过then获取</span></span><br><span class="line">        <span class="keyword">return</span> pre.<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// pre始终为一个promise实例，result为结果的累加值</span></span><br><span class="line">          <span class="comment">// 在前一个函数的then中，执行当前的函数，并返回一个promise实例，实现累加传递的效果</span></span><br><span class="line">          <span class="keyword">return</span> cur.<span class="title function_">call</span>(<span class="literal">null</span>, result);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// Promise.resolve可以将非promise实例转为promise实例（一种兼容处理）</span></span><br><span class="line">      <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(init.<span class="title function_">apply</span>(<span class="literal">null</span>, arg))</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步方法案例</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">sync1</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sync1&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">sync2</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sync2&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> data + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">sync3</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sync3&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> data + <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> syncFn = <span class="title function_">compose</span>([sync1, sync2, sync3]);</span><br><span class="line"><span class="title function_">syncFn</span>(<span class="number">0</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 依次打印 sync1 → sync2 → sync3 → 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步方法案例</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">async1</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1&quot;</span>);</span><br><span class="line">      <span class="title function_">resolve</span>(data);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">async2</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async2&quot;</span>);</span><br><span class="line">      <span class="title function_">resolve</span>(data + <span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">async3</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async3&quot;</span>);</span><br><span class="line">      <span class="title function_">resolve</span>(data + <span class="number">2</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> composeFn = <span class="title function_">compose</span>([async1, async2, async3]);</span><br><span class="line"><span class="title function_">composeFn</span>(<span class="number">0</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 依次打印 async1 → async1 → async1 → 3</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS实现倒计时</title>
    <url>/2019/10/01/countdown/</url>
    <content><![CDATA[<p>天，小时，分钟，秒钟倒计时</p>
<span id="more"></span>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>倒计时<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;day&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;hour&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;minute&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;second&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> deadline = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;2019-10-1 00:00:00&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> dayElement = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.day&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> hourElement = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.hour&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> minuteElement = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.minute&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> secondElement = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.second&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> <span class="title function_">countDown</span> = (<span class="params"></span>) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> timeRemaining = deadline - <span class="keyword">new</span> <span class="title class_">Date</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> day, hour, minute, second;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (timeRemaining &lt; <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">return</span> <span class="number">0</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        day = <span class="title class_">Math</span>.<span class="title function_">floor</span>(timeRemaining / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> / <span class="number">24</span>);</span></span><br><span class="line"><span class="language-javascript">        hour = <span class="title class_">Math</span>.<span class="title function_">floor</span>((timeRemaining / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span>) % <span class="number">24</span>);</span></span><br><span class="line"><span class="language-javascript">        minute = <span class="title class_">Math</span>.<span class="title function_">floor</span>((timeRemaining / <span class="number">1000</span> / <span class="number">60</span>) % <span class="number">60</span>);</span></span><br><span class="line"><span class="language-javascript">        second = <span class="title class_">Math</span>.<span class="title function_">floor</span>((timeRemaining / <span class="number">1000</span>) % <span class="number">60</span>);</span></span><br><span class="line"><span class="language-javascript">        dayElement.<span class="property">innerHTML</span> = day + <span class="string">&quot;天&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        hourElement.<span class="property">innerHTML</span> = hour + <span class="string">&quot;时&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        minuteElement.<span class="property">innerHTML</span> = minute + <span class="string">&quot;分&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        secondElement.<span class="property">innerHTML</span> = second + <span class="string">&quot;秒&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="built_in">setTimeout</span>(countDown, <span class="number">1000</span>);</span></span><br><span class="line"><span class="language-javascript">      &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">countDown</span>();</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖节流函数</title>
    <url>/2023/12/18/debounce-throttle/</url>
    <content><![CDATA[<h1 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h1><p>应用场景：搜索框输入文字后调用对应搜索接口</p>
<p>利用闭包，不管触发频率多高，在停止触发 n 秒后才会执行，如果重复触发，会清空之前的定时器，重新计时，直到最后一次 n 秒后执行</p>
<span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @param &#123;function&#125; fn - 需要防抖的函数</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; time - 多长时间执行一次</span></span><br><span class="line"><span class="comment"> * @param &#123;boolean&#125; flag - 第一次是否执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, time, flag</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="comment">// 在time时间段内重复执行，会清空之前的定时器，然后重新计时</span></span><br><span class="line">    timer &amp;&amp; <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    <span class="keyword">if</span> (flag &amp;&amp; !timer) &#123;</span><br><span class="line">      <span class="comment">// flag为true 第一次默认执行</span></span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;执行:&quot;</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> debounceFn = <span class="title function_">debounce</span>(fn, <span class="number">3000</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="title function_">debounceFn</span>(<span class="number">1</span>);</span><br><span class="line"><span class="title function_">debounceFn</span>(<span class="number">2</span>);</span><br><span class="line"><span class="title function_">debounceFn</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先打印：执行: 1</span></span><br><span class="line"><span class="comment">// 3s后打印: 执行: 3</span></span><br></pre></td></tr></table></figure>

<h1 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h1><p>应用场景： 下拉滚动加载</p>
<p>利用闭包，不管触发频率多高，每隔一段时间内执行一次</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @param &#123;function&#125; fn - 需要防抖的函数</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; time - 多长时间执行一次</span></span><br><span class="line"><span class="comment"> * @param &#123;boolean&#125; flag - 第一次是否执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, time, flag</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="comment">// flag控制第一次是否立即执行</span></span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">      <span class="comment">// 第一次执行完后，flag变为false；否则以后每次都会执行</span></span><br><span class="line">      flag = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">        <span class="comment">// 每次执行完重置timer</span></span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">      &#125;, time);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fn&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> throttleFn = <span class="title function_">throttle</span>(fn, <span class="number">3000</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">setInterval</span>(throttleFn, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试结果，一开始就打印&quot;fn&quot;, 以后每隔3s打印一次&quot;fn&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2021/10/14/design-patterns/</url>
    <content><![CDATA[<p>设计模式是从许多优秀的软件系统中，总结出的成功的、能够实现可维护性、复用的设计方案，使用这些方案将可以让我们避免做一些重复性的工作。</p>
<span id="more"></span>

<h1 id="单例模式-弹框"><a href="#单例模式-弹框" class="headerlink" title="单例模式(弹框)"></a>单例模式(弹框)</h1><p>一个类只能构造出唯一实例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Single</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getInstance</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">instance</span>) &#123;</span><br><span class="line">      <span class="comment">// 关键代码 this指向的是Single这个构造函数</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">instance</span> = <span class="keyword">new</span> <span class="title class_">Single</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">instance</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> single1 = <span class="title class_">Single</span>.<span class="title function_">getInstance</span>(<span class="string">&quot;name1&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> single2 = <span class="title class_">Single</span>.<span class="title function_">getInstance</span>(<span class="string">&quot;name2&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(single1 === single2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h1 id="策略模式-表单验证"><a href="#策略模式-表单验证" class="headerlink" title="策略模式(表单验证)"></a>策略模式(表单验证)</h1><p>根据不同参数命中不同的策略</p>
<h2 id="策略模式的表单验证示例"><a href="#策略模式的表单验证示例" class="headerlink" title="策略模式的表单验证示例"></a>策略模式的表单验证示例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 策略对象</span></span><br><span class="line"><span class="keyword">const</span> strategies = &#123;</span><br><span class="line">  <span class="comment">// 验证是否为空</span></span><br><span class="line">  <span class="attr">isNoEmpty</span>: <span class="keyword">function</span>(<span class="params">value, errorMsg</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value.<span class="title function_">trim</span>() === <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 验证最小长度</span></span><br><span class="line">  <span class="attr">minLength</span>: <span class="keyword">function</span>(<span class="params">value, length, errorMsg</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value.<span class="title function_">trim</span>().<span class="property">length</span> &lt; length) &#123;</span><br><span class="line">      <span class="keyword">return</span> errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 验证最大长度</span></span><br><span class="line">  <span class="attr">maxLength</span>: <span class="keyword">function</span>(<span class="params">value, length, errorMsg</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value.<span class="property">length</span> &gt; length) &#123;</span><br><span class="line">      <span class="keyword">return</span> errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 验证手机号</span></span><br><span class="line">  <span class="attr">isMobile</span>: <span class="keyword">function</span>(<span class="params">value, errorMsg</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      !<span class="regexp">/^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|17[7]|18[0|1|2|3|5|6|7|8|9])\d&#123;8&#125;$/</span>.<span class="title function_">test</span>(</span><br><span class="line">        value</span><br><span class="line">      )</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Validator</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span> = []; <span class="comment">// 存储要验证的方法</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">errList</span> = []; <span class="comment">// 存储最终的验证结果</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">add</span>(<span class="params">value, rules</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, rule; (rule = rules[i++]); ) &#123;</span><br><span class="line">      <span class="keyword">let</span> strategyAry = rule.<span class="property">strategy</span>.<span class="title function_">split</span>(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">      <span class="keyword">let</span> errorMsg = rule.<span class="property">errorMsg</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> strategy = strategyAry.<span class="title function_">shift</span>();</span><br><span class="line">        strategyAry.<span class="title function_">unshift</span>(value);</span><br><span class="line">        strategyAry.<span class="title function_">push</span>(errorMsg);</span><br><span class="line">        <span class="comment">// 执行策略对象中的不同验证规则</span></span><br><span class="line">        <span class="keyword">let</span> error = strategies[strategy](...strategyAry <span class="string">&quot;strategy&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">errList</span>.<span class="title function_">push</span>(error);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">start</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, validatorFunc; (validatorFunc = <span class="variable language_">this</span>.<span class="property">cache</span>[i++]); ) &#123;</span><br><span class="line">      <span class="title function_">validatorFunc</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">errList</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> validataFunc = <span class="keyword">function</span>(<span class="params">info</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> validator = <span class="keyword">new</span> <span class="title class_">Validator</span>();</span><br><span class="line">  validator.<span class="title function_">add</span>(info.<span class="property">userName</span>, [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">strategy</span>: <span class="string">&quot;isNoEmpty&quot;</span>,</span><br><span class="line">      <span class="attr">errorMsg</span>: <span class="string">&quot;用户名不可为空&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">strategy</span>: <span class="string">&quot;minLength:2&quot;</span>,</span><br><span class="line">      <span class="attr">errorMsg</span>: <span class="string">&quot;用户名长度不能小于2位&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]);</span><br><span class="line">  validator.<span class="title function_">add</span>(info.<span class="property">password</span>, [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">strategy</span>: <span class="string">&quot;minLength:6&quot;</span>,</span><br><span class="line">      <span class="attr">errorMsg</span>: <span class="string">&quot;密码长度不能小于6位&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]);</span><br><span class="line">  validator.<span class="title function_">add</span>(info.<span class="property">phoneNumber</span>, [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">strategy</span>: <span class="string">&quot;isMobile&quot;</span>,</span><br><span class="line">      <span class="attr">errorMsg</span>: <span class="string">&quot;请输入正确的手机号码格式&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]);</span><br><span class="line">  <span class="keyword">return</span> validator.<span class="title function_">start</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要验证表单的对象</span></span><br><span class="line"><span class="keyword">let</span> userInfo = &#123;</span><br><span class="line">  <span class="attr">userName</span>: <span class="string">&quot;王&quot;</span>,</span><br><span class="line">  <span class="attr">password</span>: <span class="string">&quot;1234&quot;</span>,</span><br><span class="line">  <span class="attr">phoneNumber</span>: <span class="string">&quot;666&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> errorMsg = <span class="title function_">validataFunc</span>(userInfo);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(errorMsg); <span class="comment">// [&#x27;用户名长度不能小于2位&#x27;, &#x27;密码长度不能小于6位&#x27;, &#x27;请输入正确的手机号码格式&#x27;]</span></span><br></pre></td></tr></table></figure>

<h1 id="代理模式-图片预加载"><a href="#代理模式-图片预加载" class="headerlink" title="代理模式(图片预加载)"></a>代理模式(图片预加载)</h1><p>代理对象和本体对象具有一致的接口</p>
<h2 id="图片代理模式示例"><a href="#图片代理模式示例" class="headerlink" title="图片代理模式示例"></a>图片代理模式示例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代理模式</span></span><br><span class="line"><span class="keyword">let</span> relImage = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> imgNode = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(imgNode);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">setSrc</span>(<span class="params">src</span>) &#123;</span><br><span class="line">      imgNode.<span class="property">src</span> = src;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">let</span> proxyImage = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">  <span class="comment">// 实际要加载的图片 加载成功后 替换调占位图</span></span><br><span class="line">  img.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    relImage.<span class="title function_">setSrc</span>(img.<span class="property">src</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">setSrc</span>(<span class="params">src</span>) &#123;</span><br><span class="line">      img.<span class="property">src</span> = src;</span><br><span class="line">      <span class="comment">// 设置占位图</span></span><br><span class="line">      relImage.<span class="title function_">setSrc</span>(</span><br><span class="line">        <span class="string">&quot;https://fuss10.elemecdn.com/e/5d/4a731a90594a4af544c0c25941171jpeg.jpeg&quot;</span></span><br><span class="line">      );</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置实际要加载的图片</span></span><br><span class="line">proxyImage.<span class="title function_">setSrc</span>(</span><br><span class="line">  <span class="string">&quot;https://cube.elemecdn.com/6/94/4d3ea53c084bad6931a56d5158a48jpeg.jpeg&quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h1 id="装饰者模式-在函数执行前后添加新的方法"><a href="#装饰者模式-在函数执行前后添加新的方法" class="headerlink" title="装饰者模式(在函数执行前后添加新的方法)"></a>装饰者模式(在函数执行前后添加新的方法)</h1><p>在不改变对象自身的基础上，动态地给某个对象添加一些额外的职责</p>
<h2 id="装饰者模式示例"><a href="#装饰者模式示例" class="headerlink" title="装饰者模式示例"></a>装饰者模式示例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fuc</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">before</span> = <span class="keyword">function</span> (<span class="params">beFn</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    beFn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>); <span class="comment">// 先执行插入到前面的方法，类似于二叉树的前序遍历</span></span><br><span class="line">    <span class="keyword">return</span> self.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>); <span class="comment">// 后执行当前的方法</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">after</span> = <span class="keyword">function</span> (<span class="params">afFn</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    self.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>); <span class="comment">// 先执行当前的方法</span></span><br><span class="line">    <span class="keyword">return</span> afFn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>); <span class="comment">// 后执行插入到后面的方法</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fuc1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fuc3</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fuc4</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fuc = fuc.<span class="title function_">before</span>(fuc1).<span class="title function_">before</span>(fuc4).<span class="title function_">after</span>(fuc3);</span><br><span class="line"><span class="title function_">fuc</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终打印结果：4 1 2 3</span></span><br></pre></td></tr></table></figure>

<h1 id="组合模式-打印文件目录"><a href="#组合模式-打印文件目录" class="headerlink" title="组合模式(打印文件目录)"></a>组合模式(打印文件目录)</h1><p>组合模式在对象间形成树形结构<br>组合模式中基本对象和组合对象被一致对待<br>无须关心对象有多少层, 调用时只需在根部进行调用</p>
<h2 id="函数组合模式示例"><a href="#函数组合模式示例" class="headerlink" title="函数组合模式示例"></a>函数组合模式示例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Combine</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">add</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">push</span>(fn);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>; <span class="comment">// 链式调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">excute</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">list</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">list</span>[i].<span class="title function_">excute</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> comb1 = <span class="keyword">new</span> <span class="title class_">Combine</span>();</span><br><span class="line">comb1</span><br><span class="line">  .<span class="title function_">add</span>(&#123;</span><br><span class="line">    <span class="title function_">excute</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">add</span>(&#123;</span><br><span class="line">    <span class="title function_">excute</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> comb2 = <span class="keyword">new</span> <span class="title class_">Combine</span>();</span><br><span class="line">comb2</span><br><span class="line">  .<span class="title function_">add</span>(&#123;</span><br><span class="line">    <span class="title function_">excute</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">add</span>(&#123;</span><br><span class="line">    <span class="title function_">excute</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> comb3 = <span class="keyword">new</span> <span class="title class_">Combine</span>();</span><br><span class="line">comb3</span><br><span class="line">  .<span class="title function_">add</span>(&#123;</span><br><span class="line">    <span class="title function_">excute</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">add</span>(&#123;</span><br><span class="line">    <span class="title function_">excute</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">comb2.<span class="title function_">add</span>(comb3);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> comb4 = <span class="keyword">new</span> <span class="title class_">Combine</span>();</span><br><span class="line">comb4.<span class="title function_">add</span>(comb1).<span class="title function_">add</span>(comb2);</span><br><span class="line">comb4.<span class="title function_">excute</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终打印结果：1 2 3 4 5 6</span></span><br></pre></td></tr></table></figure>

<h1 id="工厂模式-jquery-中的-window"><a href="#工厂模式-jquery-中的-window" class="headerlink" title="工厂模式(jquery 中的 window.$)"></a>工厂模式(jquery 中的 window.$)</h1><p>工厂模式是用来创建对象的一种最常用的设计模式</p>
<p>不暴露创建对象的具体逻辑，而是将逻辑封装在一个函数中，这个函数就可以被视为一个工厂</p>
<h2 id="工厂模式示例"><a href="#工厂模式示例" class="headerlink" title="工厂模式示例"></a>工厂模式示例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, color</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">create</span>(<span class="params">type</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;car&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;汽车&quot;</span>, <span class="string">&quot;白色&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;bicycle&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;自行车&quot;</span>, <span class="string">&quot;黑色&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="attr">default</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;没有该类型&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Factory</span>.<span class="title function_">create</span>(<span class="string">&quot;car&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Factory</span>.<span class="title function_">create</span>(<span class="string">&quot;bicycle&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1, p1 <span class="keyword">instanceof</span> <span class="title class_">Car</span>); <span class="comment">// &#123;name: &#x27;汽车&#x27;, color: &#x27;白色&#x27;&#125; true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2, p2 <span class="keyword">instanceof</span> <span class="title class_">Car</span>); <span class="comment">// &#123;name: &#x27;自行车&#x27;, color: &#x27;黑色&#x27;&#125; true</span></span><br></pre></td></tr></table></figure>

<h1 id="访问者模式-babel-插件"><a href="#访问者模式-babel-插件" class="headerlink" title="访问者模式(babel 插件)"></a>访问者模式(babel 插件)</h1><p>在不改变该对象的前提下访问其结构中元素的新方法</p>
<h2 id="访问者模式示例"><a href="#访问者模式示例" class="headerlink" title="访问者模式示例"></a>访问者模式示例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 元素类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, chinese, math, english</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">chinese</span> = chinese;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">math</span> = math;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">english</span> = english;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">accept</span>(<span class="params">visitor</span>) &#123;</span><br><span class="line">    visitor.<span class="title function_">visit</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问者类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChineseTeacher</span> &#123;</span><br><span class="line">  <span class="title function_">visit</span>(<span class="params">student</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`语文 <span class="subst">$&#123;student.chinese&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MathTeacher</span> &#123;</span><br><span class="line">  <span class="title function_">visit</span>(<span class="params">student</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`数学 <span class="subst">$&#123;student.math&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EnglishTeacher</span> &#123;</span><br><span class="line">  <span class="title function_">visit</span>(<span class="params">student</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`英语 <span class="subst">$&#123;student.english&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化元素类</span></span><br><span class="line"><span class="keyword">const</span> student = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">90</span>, <span class="number">80</span>, <span class="number">60</span>);</span><br><span class="line"><span class="comment">// 实例化访问者类</span></span><br><span class="line"><span class="keyword">const</span> chineseTeacher = <span class="keyword">new</span> <span class="title class_">ChineseTeacher</span>();</span><br><span class="line"><span class="keyword">const</span> mathTeacher = <span class="keyword">new</span> <span class="title class_">MathTeacher</span>();</span><br><span class="line"><span class="keyword">const</span> englishTeacher = <span class="keyword">new</span> <span class="title class_">EnglishTeacher</span>();</span><br><span class="line"><span class="comment">// 接受访问</span></span><br><span class="line">student.<span class="title function_">accept</span>(chineseTeacher); <span class="comment">// 语文90</span></span><br><span class="line">student.<span class="title function_">accept</span>(mathTeacher); <span class="comment">// 数学80</span></span><br><span class="line">student.<span class="title function_">accept</span>(englishTeacher); <span class="comment">// 英语60</span></span><br></pre></td></tr></table></figure>

<h1 id="发布订阅模式-EventBus"><a href="#发布订阅模式-EventBus" class="headerlink" title="发布订阅模式(EventBus)"></a>发布订阅模式(EventBus)</h1><p>订阅者订阅相关主题，发布者通过发布主题事件的方式，通知订阅该主题的对象</p>
<h2 id="手写发布订阅模式示例"><a href="#手写发布订阅模式示例" class="headerlink" title="手写发布订阅模式示例"></a>手写发布订阅模式示例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发布订阅模式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventBus</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">task</span> = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">on</span>(<span class="params">type, fn</span>) &#123;</span><br><span class="line">    <span class="comment">// on 注册事件</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">task</span>[type]) <span class="variable language_">this</span>.<span class="property">task</span>[type] = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">task</span>[type].<span class="title function_">push</span>(fn);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">emit</span>(<span class="params">type, ...args</span>) &#123;</span><br><span class="line">    <span class="comment">// emit 发送事件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">task</span>[type]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">task</span>[type].<span class="title function_">forEach</span>(<span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">        fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args); <span class="comment">// 注意this指向</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">off</span>(<span class="params">type, fn</span>) &#123;</span><br><span class="line">    <span class="comment">// 删除事件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">task</span>[type]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">task</span>[type] = <span class="variable language_">this</span>.<span class="property">task</span>[type].<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item !== fn);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">once</span>(<span class="params">type, fn</span>) &#123;</span><br><span class="line">    <span class="comment">// 只执行一次</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">      <span class="title function_">fn</span>(...args);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">off</span>(type, f);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">on</span>(type, f);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">let</span> event = <span class="keyword">new</span> <span class="title class_">EventBus</span>();</span><br><span class="line">event.<span class="title function_">on</span>(<span class="string">&quot;change&quot;</span>, <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(args);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 只执行一次</span></span><br><span class="line">event.<span class="title function_">once</span>(<span class="string">&quot;change&quot;</span>, <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(args);</span><br><span class="line">&#125;);</span><br><span class="line">event.<span class="title function_">emit</span>(<span class="string">&quot;change&quot;</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">event.<span class="title function_">emit</span>(<span class="string">&quot;change&quot;</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h1 id="观察者模式-vue-双向绑定"><a href="#观察者模式-vue-双向绑定" class="headerlink" title="观察者模式(vue 双向绑定)"></a>观察者模式(vue 双向绑定)</h1><p>一个对象有一系列依赖于它的观察者（watcher），当对象发生变化时，会通知观察者进行更新</p>
<h2 id="观察者模式示例"><a href="#观察者模式示例" class="headerlink" title="观察者模式示例"></a>观察者模式示例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;ming&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(data).<span class="title function_">forEach</span>(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> value = data[key];</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data, key, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;get&quot;</span>, value);</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;更新&quot;</span>);</span><br><span class="line">      value = newValue;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">data.<span class="property">name</span> = <span class="string">&quot;佩奇&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="property">name</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依次打印： 更新 → get 佩奇 → 佩奇</span></span><br></pre></td></tr></table></figure>

<h1 id="观察者与发布订阅模式的区别"><a href="#观察者与发布订阅模式的区别" class="headerlink" title="观察者与发布订阅模式的区别"></a>观察者与发布订阅模式的区别</h1><p>观察者模式：一个对象有一系列依赖于它的观察者（watcher），当对象发生变化时，会通知观察者进行更新</p>
<p>发布订阅模式：订阅者订阅相关主题，发布者通过发布主题事件的方式通知订阅该主题的对象，发布订阅模式中可以基于不同的主题去执行不同的自定义事件</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS 垃圾回收机制</title>
    <url>/2023/01/15/garbage-recycling-mechanism/</url>
    <content><![CDATA[<h1 id="一、垃圾回收机制——GC"><a href="#一、垃圾回收机制——GC" class="headerlink" title="一、垃圾回收机制——GC"></a>一、垃圾回收机制——GC</h1><p>Javascript 具有自动垃圾回收机制（GC：Garbage Collecation），也就是说，执行环境会负责管理代码执行过程中使用的内存。</p>
<p>原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。</p>
<p>通常情况下有两种实现方式：</p>
<span id="more"></span>

<h2 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2><p>js 中最常用的垃圾回收方式就是标记清除。</p>
<p>当变量进入环境时，例如，在函数中声明一个变量，就将这个变量<strong>标记为“进入环境”</strong>。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其<strong>标记为“离开环境”</strong>。</p>
<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p><strong>跟踪记录每个值被引用的次数</strong></p>
<p>当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为 0 的值所占用的内存。</p>
<h1 id="二、内存管理"><a href="#二、内存管理" class="headerlink" title="二、内存管理"></a>二、内存管理</h1><ol>
<li>Javascript 引擎基础 GC 方案是</li>
</ol>
<p>（simple GC）：mark and sweep（标记清除），即：</p>
<p>1）遍历所有可访问的对象；</p>
<p>2）回收已不可访问的对象。</p>
<ol start="2">
<li>GC 的缺陷</li>
</ol>
<p>和其他语言一样，JavaScript 的 GC 策略也无法避免一个问题：<strong>GC 时，停止响应其他操作</strong>，这是为了安全考虑。而 Javascript 的 GC 在 100ms 甚至以上，对一般的应用还好，但对于 JS 游戏，动画对连贯性要求比较高的应用，就麻烦了。<br>这就是新引擎需要优化的点：避免 GC 造成的长时间停止响应。</p>
<ol start="3">
<li>GC 优化策略</li>
</ol>
<p>1）分代回收（Generation GC）</p>
<p>这个和 Java 回收策略思想是一致的。目的是通过区分“临时”与“持久”对象；多回收“临时对象”区（young generation），少回收“持久对象”区（tenured generation），减少每次需遍历的对象，从而减少每次 GC 的耗时。</p>
<p>2）增量 GC</p>
<p>这个方案的思想很简单，就是“每次处理一点，下次再处理一点”，如此类推。</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>软链接和硬链接</title>
    <url>/2023/12/19/hard-symbol-link/</url>
    <content><![CDATA[<p>假设我们有一个文件，称为 <code>hello</code></p>
<p>通过 <code>ln -s</code> 创建一个软链接，通过 <code>ln</code> 可以创建一个硬链接。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ln -s hello hello-soft</span><br><span class="line">$ ln hello hello-hard</span><br><span class="line"></span><br><span class="line">$ ls -lh</span><br><span class="line">total 768</span><br><span class="line">45459612 -rw-r--r--  2 xiange  staff   153K 11 19 17:56 hello</span><br><span class="line">45459612 -rw-r--r--  2 xiange  staff   153K 11 19 17:56 hello-hard</span><br><span class="line">45463415 lrwxr-xr-x  1 xiange  staff     5B 11 19 19:40 hello-soft -&gt; hello</span><br></pre></td></tr></table></figure>

<p>他们的区别有以下几点:</p>
<ul>
<li>软链接可理解为指向源文件的指针，它是单独的一个文件，仅仅只有几个字节，它拥有独立的 inode</li>
<li>硬链接与源文件同时指向一个物理地址，它与源文件共享存储数据，它俩拥有相同的 inode</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>实现图片的懒加载</title>
    <url>/2022/12/14/img-lazyload/</url>
    <content><![CDATA[<p>图片的懒加载原理： 当图片元素出现在屏幕中时，才给图片的 src 赋值对应的链接，去加载对应的图片</p>
<span id="more"></span>

<p>使用 <code>IntersectionObserver</code> 监听元素来判断是否出现在视口，当图片出现在视口时，给 <code>img.src</code> 赋值</p>
<p><code>IntersectionObserver</code> 替代监听 <code>scroll</code> 事件来判断元素是否在视口中，性能更高</p>
<p>图片懒加载示例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// html内容</span></span><br><span class="line"><span class="comment">// &lt;img src=&quot;./loading.jpg&quot; src=&quot;https://cube.elemecdn.com/6/94/4d3ea53c084bad6931a56d5158a48jpeg.jpeg&quot;&gt;</span></span><br><span class="line"><span class="comment">// &lt;img src=&quot;./loading.jpg&quot; src=&quot;https://fuss10.elemecdn.com/e/5d/4a731a90594a4af544c0c25941171jpeg.jpeg&quot;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">observerImg</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> imgList = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(<span class="function">(<span class="params">list</span>) =&gt;</span> &#123;</span><br><span class="line">    list.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 判断元素是否出现在视口</span></span><br><span class="line">      <span class="keyword">if</span> (item.<span class="property">intersectionRatio</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        item.<span class="property">target</span>.<span class="property">src</span> = item.<span class="property">target</span>.<span class="title function_">getAttribute</span>(<span class="string">&quot;src&quot;</span>);</span><br><span class="line">        observer.<span class="title function_">unobserve</span>(item.<span class="property">target</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; imgList.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 监听每个img元素</span></span><br><span class="line">    observer.<span class="title function_">observe</span>(imgList[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>indexedDB</title>
    <url>/2023/12/19/indexedDB/</url>
    <content><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>随着浏览器的功能不断增强，越来越多的网站开始考虑，将大量数据储存在客户端，这样可以减少从服务器获取数据，直接从本地获取数据。</p>
<p>现有的浏览器数据储存方案，都不适合储存大量数据：Cookie 的大小不超过 4KB，且每次请求都会发送回服务器；LocalStorage 在 2.5MB 到 10MB 之间（各家浏览器不同），而且不提供搜索功能，不能建立自定义的索引。所以，需要一种新的解决方案，这就是 IndexedDB 诞生的背景。</p>
<span id="more"></span>

<p>通俗地说，<strong>IndexedDB 就是浏览器提供的本地数据库，它可以被网页脚本创建和操作</strong>。IndexedDB 允许储存大量数据，提供查找接口，还能建立索引。这些都是 LocalStorage 所不具备的。就数据库类型而言，IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL 数据库。</p>
<p>IndexedDB 具有以下特点。</p>
<ul>
<li><p>（1）<strong>键值对储存</strong>。 IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以”键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。</p>
</li>
<li><p>（2）<strong>异步</strong>。 IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。</p>
</li>
</ul>
<ul>
<li><p>（3）<strong>支持事务</strong>。 IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。</p>
</li>
<li><p>（4）<strong>同源限制</strong>。 IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。</p>
</li>
<li><p>（5）<strong>储存空间大</strong>。 IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。</p>
</li>
<li><p>（6）<strong>支持二进制储存</strong>。 IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。</p>
</li>
</ul>
<h1 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h1><p>IndexedDB 是一个比较复杂的 API，涉及不少概念。它把不同的实体，抽象成一个个对象接口。学习这个 API，就是学习它的各种对象接口。</p>
<blockquote>
<ul>
<li>数据库：IDBDatabase 对象</li>
<li>对象仓库：IDBObjectStore 对象</li>
<li>索引： IDBIndex 对象</li>
<li>事务： IDBTransaction 对象</li>
<li>操作请求：IDBRequest 对象</li>
<li>指针： IDBCursor 对象</li>
<li>主键集合：IDBKeyRange 对象</li>
</ul>
</blockquote>
<p>下面是一些主要的概念。</p>
<p><strong>（1）数据库</strong></p>
<p>数据库是一系列相关数据的容器。每个域名（严格的说，是协议 + 域名 + 端口）都可以新建任意多个数据库。</p>
<p>IndexedDB 数据库有版本的概念。同一个时刻，只能有一个版本的数据库存在。如果要修改数据库结构（新增或删除表、索引或者主键），只能通过升级数据库版本完成。</p>
<p><strong>（2）对象仓库</strong></p>
<p>每个数据库包含若干个对象仓库（object store）。它类似于关系型数据库的表格。</p>
<p><strong>（3）数据记录</strong></p>
<p>对象仓库保存的是数据记录。每条记录类似于关系型数据库的行，但是只有主键和数据体两部分。主键用来建立默认的索引，必须是不同的，否则会报错。主键可以是数据记录里面的一个属性，也可以指定为一个递增的整数编号。</p>
<p><code>&#123; id: 1, text: &#39;foo&#39; &#125;</code><br>上面的对象中，id 属性可以当作主键。</p>
<p>数据体可以是任意数据类型，不限于对象。</p>
<p><strong>（4）索引</strong></p>
<p>为了加速数据的检索，可以在对象仓库里面，为不同的属性建立索引。</p>
<p><strong>（5）事务</strong></p>
<p>数据记录的读写和删改，都要通过事务完成。事务对象提供<code>error</code>、<code>abort</code>和<code>complete</code>三个事件，用来监听操作结果。</p>
<h1 id="三、操作流程"><a href="#三、操作流程" class="headerlink" title="三、操作流程"></a>三、操作流程</h1><p>IndexedDB 数据库的各种操作，一般是按照下面的流程进行的。这个部分只给出简单的代码示例，用于快速上手，详细的各个对象的 API 请看<a href="https://wangdoc.com/javascript/bom/indexeddb#indexeddb-%E5%AF%B9%E8%B1%A1">这里</a>。</p>
<h2 id="3-1-打开数据库"><a href="#3-1-打开数据库" class="headerlink" title="3.1 打开数据库"></a>3.1 打开数据库</h2><p>使用 IndexedDB 的第一步是打开数据库，使用<code>indexedDB.open()</code>方法。</p>
<p><code>var request = window.indexedDB.open(databaseName, version);</code></p>
<p>这个方法接受两个参数，第一个参数是字符串，表示数据库的名字。如果指定的数据库不存在，就会新建数据库。第二个参数是整数，表示数据库的版本。如果省略，打开已有数据库时，默认为当前版本；新建数据库时，默认为 1。</p>
<p><code>indexedDB.open()</code>方法返回一个 <code>IDBRequest</code> 对象。这个对象通过三种事件<code>error</code>、<code>success</code>、<code>upgradeneeded</code>，处理打开数据库的操作结果。</p>
<h3 id="1）error-事件"><a href="#1）error-事件" class="headerlink" title="1）error 事件"></a>1）error 事件</h3><p>error 事件表示打开数据库失败。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">request.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;数据库打开报错&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2）success-事件"><a href="#2）success-事件" class="headerlink" title="2）success 事件"></a>2）success 事件</h3><p>success 事件表示打开数据库成功。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> db;</span><br><span class="line">request.<span class="property">onsuccess</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  db = request.<span class="property">result</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;数据库打开成功&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这时，通过 request 对象的 result 属性拿到数据库对象。</p>
<h3 id="3）upgradeneeded-事件"><a href="#3）upgradeneeded-事件" class="headerlink" title="3）upgradeneeded 事件"></a>3）upgradeneeded 事件</h3><p>如果指定的版本号，大于数据库的实际版本号，就会发生数据库升级事件 upgradeneeded。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> db;</span><br><span class="line"></span><br><span class="line">request.<span class="property">onupgradeneeded</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  db = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这时通过事件对象的 target.result 属性，拿到数据库实例。</p>
<h2 id="3-2-新建数据库"><a href="#3-2-新建数据库" class="headerlink" title="3.2 新建数据库"></a>3.2 新建数据库</h2><p>新建数据库与打开数据库是同一个操作。如果指定的数据库不存在，就会新建。不同之处在于，后续的操作主要在 <code>upgradeneeded</code> 事件的监听函数里面完成，因为这时版本从无到有，所以会触发这个事件。</p>
<p>通常，新建数据库以后，第一件事是新建对象仓库（即新建表）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">request.<span class="property">onupgradeneeded</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  db = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">  <span class="keyword">var</span> objectStore = db.<span class="title function_">createObjectStore</span>(<span class="string">&quot;person&quot;</span>, &#123; <span class="attr">keyPath</span>: <span class="string">&quot;id&quot;</span> &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，数据库新建成功以后，新增一张叫做 person 的表格，主键是 id。</p>
<p>更好的写法是先判断一下，这张表格是否存在，如果不存在再新建。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">request.<span class="property">onupgradeneeded</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  db = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">  <span class="keyword">var</span> objectStore;</span><br><span class="line">  <span class="keyword">if</span> (!db.<span class="property">objectStoreNames</span>.<span class="title function_">contains</span>(<span class="string">&quot;person&quot;</span>)) &#123;</span><br><span class="line">    objectStore = db.<span class="title function_">createObjectStore</span>(<span class="string">&quot;person&quot;</span>, &#123; <span class="attr">keyPath</span>: <span class="string">&quot;id&quot;</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>主键（key）是默认建立索引的属性。比如，数据记录是<code>&#123; id: 1, name: &#39;张三&#39; &#125;</code>，那么 id 属性可以作为主键。主键也可以指定为下一层对象的属性，比如<code>&#123; foo: &#123; bar: &#39;baz&#39; &#125; &#125;</code>的 <code>foo.bar</code> 也可以指定为主键。</p>
<p>如果数据记录里面没有合适作为主键的属性，那么可以让 IndexedDB 自动生成主键。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> objectStore = db.<span class="title function_">createObjectStore</span>(<span class="string">&quot;person&quot;</span>, &#123; <span class="attr">autoIncrement</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，指定主键为一个递增的整数。</p>
<p>新建对象仓库以后，下一步可以新建索引。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">request.<span class="property">onupgradeneeded</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  db = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">  <span class="keyword">var</span> objectStore = db.<span class="title function_">createObjectStore</span>(<span class="string">&quot;person&quot;</span>, &#123; <span class="attr">keyPath</span>: <span class="string">&quot;id&quot;</span> &#125;);</span><br><span class="line">  objectStore.<span class="title function_">createIndex</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;name&quot;</span>, &#123; <span class="attr">unique</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">  objectStore.<span class="title function_">createIndex</span>(<span class="string">&quot;email&quot;</span>, <span class="string">&quot;email&quot;</span>, &#123; <span class="attr">unique</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>IDBObject.createIndex()</code>的三个参数分别为索引名称、索引所在的属性、配置对象（说明该属性是否包含重复的值）。</p>
<h2 id="3-3-新增数据"><a href="#3-3-新增数据" class="headerlink" title="3.3 新增数据"></a>3.3 新增数据</h2><p>新增数据指的是向对象仓库写入数据记录。这需要通过事务完成。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> request = db</span><br><span class="line">    .<span class="title function_">transaction</span>([<span class="string">&quot;person&quot;</span>], <span class="string">&quot;readwrite&quot;</span>)</span><br><span class="line">    .<span class="title function_">objectStore</span>(<span class="string">&quot;person&quot;</span>)</span><br><span class="line">    .<span class="title function_">add</span>(&#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>, <span class="attr">age</span>: <span class="number">24</span>, <span class="attr">email</span>: <span class="string">&quot;zhangsan@example.com&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">  request.<span class="property">onsuccess</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;数据写入成功&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  request.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;数据写入失败&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>();</span><br></pre></td></tr></table></figure>

<p>上面代码中，写入数据需要新建一个事务。新建时必须指定表格名称和操作模式（”只读”或”读写”）。新建事务以后，通过<code>IDBTransaction.objectStore(name)</code>方法，拿到 IDBObjectStore 对象，再通过表格对象的 add()方法，向表格写入一条记录。</p>
<p>写入操作是一个异步操作，通过监听连接对象的<code>success</code>事件和<code>error</code>事件，了解是否写入成功。</p>
<h2 id="3-4-读取数据"><a href="#3-4-读取数据" class="headerlink" title="3.4 读取数据"></a>3.4 读取数据</h2><p>读取数据也是通过事务完成。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">read</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> transaction = db.<span class="title function_">transaction</span>([<span class="string">&quot;person&quot;</span>]);</span><br><span class="line">  <span class="keyword">var</span> objectStore = transaction.<span class="title function_">objectStore</span>(<span class="string">&quot;person&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> request = objectStore.<span class="title function_">get</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  request.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;事务失败&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  request.<span class="property">onsuccess</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (request.<span class="property">result</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Name: &quot;</span> + request.<span class="property">result</span>.<span class="property">name</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Age: &quot;</span> + request.<span class="property">result</span>.<span class="property">age</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Email: &quot;</span> + request.<span class="property">result</span>.<span class="property">email</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;未获得数据记录&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">read</span>();</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>objectStore.get()</code>方法用于读取数据，参数是主键的值。</p>
<h2 id="3-5"><a href="#3-5" class="headerlink" title="3.5"></a>3.5</h2><p>遍历数据<br>遍历数据表格的所有记录，要使用指针对象 IDBCursor。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">readAll</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> objectStore = db.<span class="title function_">transaction</span>(<span class="string">&quot;person&quot;</span>).<span class="title function_">objectStore</span>(<span class="string">&quot;person&quot;</span>);</span><br><span class="line"></span><br><span class="line">  objectStore.<span class="title function_">openCursor</span>().<span class="property">onsuccess</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> cursor = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cursor) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Id: &quot;</span> + cursor.<span class="property">key</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Name: &quot;</span> + cursor.<span class="property">value</span>.<span class="property">name</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Age: &quot;</span> + cursor.<span class="property">value</span>.<span class="property">age</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Email: &quot;</span> + cursor.<span class="property">value</span>.<span class="property">email</span>);</span><br><span class="line">      cursor.<span class="title function_">continue</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;没有更多数据了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">readAll</span>();</span><br></pre></td></tr></table></figure>

<p>上面代码中，新建指针对象的<code>openCursor()</code>方法是一个异步操作，所以要监听<code>success</code>事件。</p>
<h2 id="3-6-更新数据"><a href="#3-6-更新数据" class="headerlink" title="3.6 更新数据"></a>3.6 更新数据</h2><p>更新数据要使用<code>IDBObject.put()</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> request = db</span><br><span class="line">    .<span class="title function_">transaction</span>([<span class="string">&quot;person&quot;</span>], <span class="string">&quot;readwrite&quot;</span>)</span><br><span class="line">    .<span class="title function_">objectStore</span>(<span class="string">&quot;person&quot;</span>)</span><br><span class="line">    .<span class="title function_">put</span>(&#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&quot;李四&quot;</span>, <span class="attr">age</span>: <span class="number">35</span>, <span class="attr">email</span>: <span class="string">&quot;lisi@example.com&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">  request.<span class="property">onsuccess</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;数据更新成功&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  request.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;数据更新失败&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">update</span>();</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>put()</code>方法自动更新了主键为 1 的记录。</p>
<h2 id="3-7-删除数据"><a href="#3-7-删除数据" class="headerlink" title="3.7 删除数据"></a>3.7 删除数据</h2><p><code>IDBObjectStore.delete()</code>方法用于删除记录。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">remove</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> request = db</span><br><span class="line">    .<span class="title function_">transaction</span>([<span class="string">&quot;person&quot;</span>], <span class="string">&quot;readwrite&quot;</span>)</span><br><span class="line">    .<span class="title function_">objectStore</span>(<span class="string">&quot;person&quot;</span>)</span><br><span class="line">    .<span class="title function_">delete</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  request.<span class="property">onsuccess</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;数据删除成功&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">remove</span>();</span><br></pre></td></tr></table></figure>

<h2 id="3-8-使用索引"><a href="#3-8-使用索引" class="headerlink" title="3.8 使用索引"></a>3.8 使用索引</h2><p>索引的意义在于，可以让你搜索任意字段，也就是说从任意字段拿到数据记录。如果不建立索引，默认只能搜索主键（即从主键取值）。</p>
<p>假定新建表格的时候，对 <code>name</code>字段建立了索引。</p>
<p><code>objectStore.createIndex(&#39;name&#39;, &#39;name&#39;, &#123; unique: false &#125;);</code><br>现在，就可以从 name 找到对应的数据记录了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> transaction = db.<span class="title function_">transaction</span>([<span class="string">&quot;person&quot;</span>], <span class="string">&quot;readonly&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> store = transaction.<span class="title function_">objectStore</span>(<span class="string">&quot;person&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> index = store.<span class="title function_">index</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> request = index.<span class="title function_">get</span>(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line"></span><br><span class="line">request.<span class="property">onsuccess</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = e.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">  <span class="keyword">if</span> (result) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>pnpm</title>
    <url>/2023/03/19/pnpm/</url>
    <content><![CDATA[<p>pnpm(performant npm) 通过软、硬链接（hark link、symbolic link） + 全局存储（store）结合的依赖管理方式完全实现了依赖树结构的包管理方式，解决了 npm3 及 yarn 中的幽灵依赖和 npm 分身的问题，提升了依赖包的安装速度，减小了磁盘空间占用。</p>
<span id="more"></span>

<h1 id="pnpm-为何节省空间"><a href="#pnpm-为何节省空间" class="headerlink" title="pnpm 为何节省空间"></a>pnpm 为何节省空间</h1><p>它解决了 npm&#x2F;yarn 平铺 node_modules 带来的依赖项重复的问题 (doppelgangers)</p>
<p>假设存在依赖依赖:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── package-a</span><br><span class="line">│   └── lodash@4.0.0</span><br><span class="line">├── package-b</span><br><span class="line">│   └── lodash@4.0.0</span><br><span class="line">├── package-c</span><br><span class="line">│   └── lodash@3.0.0</span><br><span class="line">└── package-d</span><br><span class="line">    └── lodash@3.0.0</span><br></pre></td></tr></table></figure>

<p>那么不可避免地在 npm 或者 yarn 中，<code>lodash@3.0.0</code> 会被多次安装，无疑造成了空间的浪费与诸多问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./node_modules/lodash</span><br><span class="line">./node_modules/package-a</span><br><span class="line">./node_modules/package-b</span><br><span class="line">./node_modules/package-c</span><br><span class="line">./node_modules/package-c/node_mdoules/lodash</span><br><span class="line">./node_modules/package-d</span><br><span class="line">./node_modules/package-d/node_mdoules/lodash</span><br></pre></td></tr></table></figure>

<p>这是一个较为常见的场景，在平时项目中有些库相同版本甚至会安装七八次，如 <code>postcss</code>、<code>ansi-styles</code>、<code>ansi-regex</code>、<code>braces</code> 等，可以去<code>yarn.lock/package-lock.json</code> 中搜索一下。</p>
<p>而在 pnpm 中，它改变了 npm&#x2F;yarn 的目录结构，采用<strong>软链接</strong>的方式，避免了 <code>doppelgangers</code> 问题更加节省空间。</p>
<p>它最终生成的 <code>node_modules</code> 如下所示，从中也可以看出它解决了<strong>幽灵依赖</strong>的问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./node_modules/package-a       -&gt;  .pnpm/package-a@1.0.0/node_modules/package-a</span><br><span class="line">./node_modules/package-b       -&gt;  .pnpm/package-b@1.0.0/node_modules/package-b</span><br><span class="line">./node_modules/package-c       -&gt;  .pnpm/package-c@1.0.0/node_modules/package-c</span><br><span class="line">./node_modules/package-d       -&gt;  .pnpm/package-d@1.0.0/node_modules/package-d</span><br><span class="line">./node_modules/.pnpm/lodash@3.0.0</span><br><span class="line">./node_modules/.pnpm/lodash@4.0.0</span><br><span class="line">./node_modules/.pnpm/package-a@1.0.0</span><br><span class="line">./node_modules/.pnpm/package-a@1.0.0/node_modules/package-a</span><br><span class="line">./node_modules/.pnpm/package-a@1.0.0/node_modules/lodash     -&gt; .pnpm/package-a@1.0.0/node_modules/lodash@4.0.0</span><br><span class="line">./node_modules/.pnpm/package-b@1.0.0</span><br><span class="line">./node_modules/.pnpm/package-b@1.0.0/node_modules/package-b</span><br><span class="line">./node_modules/.pnpm/package-b@1.0.0/node_modules/lodash     -&gt; .pnpm/package-b@1.0.0/node_modules/lodash@4.0.0</span><br><span class="line">./node_modules/.pnpm/package-c@1.0.0</span><br><span class="line">./node_modules/.pnpm/package-c@1.0.0/node_modules/package-c</span><br><span class="line">./node_modules/.pnpm/package-c@1.0.0/node_modules/lodash     -&gt; .pnpm/package-c@1.0.0/node_modules/lodash@3.0.0</span><br><span class="line">./node_modules/.pnpm/package-d@1.0.0</span><br><span class="line">./node_modules/.pnpm/package-d@1.0.0/node_modules/package-d</span><br><span class="line">./node_modules/.pnpm/package-d@1.0.0/node_modules/lodash     -&gt; .pnpm/package-d@1.0.0/node_modules/lodash@3.0.0</span><br></pre></td></tr></table></figure>

<p>如此，依赖软链接的方式，可解决重复依赖安装 (doppelgangers) 的问题，<strong>如果一个项目占用 1000 MB，那么使用 pnpm 可能仅占用 800 MB</strong></p>
<p>然而它除此之外，还有一个最大的好处，<strong>如果一个项目占用 1000 MB，传统方式十个项目占用 10000 MB，那么使用 pnpm 可能仅占用 3000 MB，而它得益于硬链接。</strong></p>
<p>再借用以上示例，<code>lodash@3.0.0</code> 与 <code>lodash@4.0.0</code> 会生成一个指向全局目录(<code>~/.pnpm-store</code>)的硬链接，如果新项目依赖二者，则可复用存储空间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./node_modules/.pnpm/lodash@3.0.0/node_modules/lodash   -&gt; hardlink</span><br><span class="line">./node_modules/.pnpm/lodash@4.0.0/node_modules/lodash   -&gt; hardlink</span><br></pre></td></tr></table></figure>

<h1 id="pnpm、yarn、npm-的区别"><a href="#pnpm、yarn、npm-的区别" class="headerlink" title="pnpm、yarn、npm 的区别"></a>pnpm、yarn、npm 的区别</h1><table>
<thead>
<tr>
<th>功能</th>
<th>pnpm</th>
<th>yarn</th>
<th>npm</th>
</tr>
</thead>
<tbody><tr>
<td>工作空间支持（monorepo）</td>
<td>O</td>
<td>O</td>
<td>O</td>
</tr>
<tr>
<td>隔离的 node_modules</td>
<td>O-默认</td>
<td>O</td>
<td>O</td>
</tr>
<tr>
<td>提升的 node_modules</td>
<td>O</td>
<td>O</td>
<td>O-默认</td>
</tr>
<tr>
<td>自动安装 peers</td>
<td>O</td>
<td>X</td>
<td>O</td>
</tr>
<tr>
<td>Plug’n’Play</td>
<td>O</td>
<td>O-默认</td>
<td>X</td>
</tr>
<tr>
<td>零安装</td>
<td>X</td>
<td>O</td>
<td>X</td>
</tr>
<tr>
<td>修补依赖项</td>
<td>O</td>
<td>O</td>
<td>X</td>
</tr>
<tr>
<td>管理 Node.js 版本</td>
<td>O</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>有锁文件</td>
<td>O-pnpm-lock.yaml</td>
<td>O-yarn.lock</td>
<td>O-package-lock.json</td>
</tr>
<tr>
<td>支持覆盖</td>
<td>O</td>
<td>O-通过 resolutions</td>
<td>O</td>
</tr>
<tr>
<td>内容可寻址存储</td>
<td>O</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>动态包执行</td>
<td>O-通过 pnpm dlx</td>
<td>O-通过 yarn dlx</td>
<td>O-通过 npx</td>
</tr>
<tr>
<td>Side-effects cache</td>
<td>O</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>Listing License</td>
<td>O-Vua pnpm licenses list</td>
<td>O-Via a plugin</td>
<td>X</td>
</tr>
</tbody></table>
<h1 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install -g pnpm</span><br><span class="line"></span><br><span class="line">pnpm -v</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">pnpm init</span><br><span class="line">pnpm install xxx</span><br><span class="line">pnpm run xxx</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置源</span></span><br><span class="line">pnpm config get registry</span><br><span class="line">pnpm config set registry &lt;淘宝源或其他源地址&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//管理依赖</span></span><br><span class="line">pnpm add xxx</span><br><span class="line">pnpm add -D xxx <span class="comment">//安装到devDependencies</span></span><br><span class="line">pnpm add -O xxx <span class="comment">//安装到optionalDependencies</span></span><br><span class="line">pnpm add -g xx <span class="comment">//全局安装依赖包</span></span><br><span class="line">pnpm install 或(pnpm i)</span><br><span class="line">pnpm update 或( pnpm up)</span><br><span class="line">pnpm remove 或(pnpm rm/uninstall/un)</span><br></pre></td></tr></table></figure>

<h2 id="查看依赖"><a href="#查看依赖" class="headerlink" title="查看依赖"></a>查看依赖</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pnpm list 或(pnpm ls)</span><br><span class="line">pnpm list --<span class="variable language_">global</span> 或(pnpm ls --g)</span><br><span class="line">pnpm outdated <span class="comment">//检查过期的依赖</span></span><br></pre></td></tr></table></figure>

<h2 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pnpm run xxx 或（pnpm xxx）</span><br><span class="line">pnpm test 运行test测试脚本</span><br><span class="line">pnpm create</span><br><span class="line">pnpm start</span><br></pre></td></tr></table></figure>

<h2 id="包存储-store"><a href="#包存储-store" class="headerlink" title="包存储 store"></a>包存储 store</h2><p>pnpm store: pnpm 资源在磁盘上的存储空间</p>
<p>可以通过 <code>pnpm store path</code>命令查看 store 存储目录的路径</p>
<p>在项目中执行<code>pnpm install</code>的时候，依赖包存在于 store 中，直接创建依赖包硬链接到 store 中，如果不存在，则从远程下载后存储在 store 中，并从项目的 node_modules 依赖包中创建硬链接到 store 中。</p>
<p><code>pnpm store prune</code>，从存储中删除未引用的包。</p>
<h2 id="workspce-协议"><a href="#workspce-协议" class="headerlink" title="workspce 协议"></a>workspce 协议</h2><blockquote>
<p>workspce:工作空间</p>
</blockquote>
<p><code>workspace:*</code>协议，表示依赖的就一直是本地的包，而不是从<code>npm registry</code>安装的包。</p>
<h3 id="别名引用"><a href="#别名引用" class="headerlink" title="别名引用"></a>别名引用</h3><p>假如工作区有一个名为 foo 的包，可以通过这样引用 <code>&quot;foo&quot;: &quot;workspace:&quot;</code>，如果是其它别名，可以这么引用：<code>&quot;bar&quot;: &quot;workspace:foo@*&quot;</code>。</p>
<h3 id="相对引用"><a href="#相对引用" class="headerlink" title="相对引用"></a>相对引用</h3><p>假如 packages 下有同层级的 foo、bar，其中 bar 依赖于 foo，则可以写作<code>&quot;bar&quot;: &quot;workspace:../foo&quot;</code>。</p>
<h3 id="发布-workspace-包"><a href="#发布-workspace-包" class="headerlink" title="发布 workspace 包"></a>发布 workspace 包</h3><p>当 workspace 包打包发布时，将会动态替换这些 workspace:依赖。</p>
<h1 id="npm-或-Yarn-转-pnpm"><a href="#npm-或-Yarn-转-pnpm" class="headerlink" title="npm 或 Yarn 转 pnpm"></a>npm 或 Yarn 转 pnpm</h1><p>操作步骤：</p>
<ol>
<li>全局安装 pnpm</li>
</ol>
<p><code>npm install -g pnpm</code></p>
<ol start="2">
<li>删除 npm 或 yarn 生成的 node_modules</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 项目目录下运行或手动物理删除</span><br><span class="line">rm -rf node_modules</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>pnpm import 从其他软件包管理器的 lock 文件生成  pnpm-lock.yaml，再执行 <code>pnpm install --frozen-lockfile</code>（相当于 npm ci）生成依赖，防止没有 lock 文件意外升级依赖包，导致项目出错</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 生成`pnpm-lock.yaml`</span><br><span class="line">pnpm import</span><br><span class="line"></span><br><span class="line"># 安装依赖</span><br><span class="line">pnpm install --frozen-lockfile</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>删除 npm 或 yarn 生成的 lock 文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 删除 package-lock.json</span><br><span class="line">rm -rf package-lock.json</span><br><span class="line"></span><br><span class="line"># 删除 yarn.lock</span><br><span class="line">rm -rf yarn.lock</span><br></pre></td></tr></table></figure>

<p>项目中的 npm 命令等修改为 pnpm，包括 README 文档、运行命令等</p>
<p><a href="https://juejin.cn/post/7124142007659790372">参考链接</a></p>
]]></content>
      <tags>
        <tag>pnpm</tag>
      </tags>
  </entry>
  <entry>
    <title>React 组件的编写</title>
    <url>/2022/03/08/react-components/</url>
    <content><![CDATA[<p>在编写 React 组件时，有一些最佳实践需要遵循：</p>
<span id="more"></span>

<h1 id="单一职责"><a href="#单一职责" class="headerlink" title="单一职责"></a>单一职责</h1><p>就像函数一样，组件也应当遵循单一职责的原则，即每个组件只能负责一个功能。请阅读<a href="https://zh-hans.reactjs.org/docs/thinking-in-react.html#step-1-break-the-ui-into-a-component-hierarchy">官方示例中的第一步</a>。</p>
<p>将一个功能复杂的大组件拆分为多个职责单一的小组件可以获得以下好处：</p>
<ol>
<li>可读性和可维护性的提升：小组件代码更短，且服务于同一目的；读者可以按层级理解代码。</li>
<li>可测试性的提升：小组件更容易做单元测试。</li>
<li>可复用性的提升：小组件可以在简单的调整和提取后被复用于其他场景。</li>
<li>性能的提升：state 的变化不再总是触发整个大组件的重渲染。</li>
</ol>
<h1 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h1><p>拆分组件时在文件结构上的最佳实践是，假设原来有一个大组件是 Complex.tsx，拆分后它应变成一个文件夹：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- Complex</span><br><span class="line">  - index.tsx // 简化后的大组件</span><br><span class="line">  - SubA.tsx // 拆分出来的小组件</span><br><span class="line">  - SubB.tsx // 拆分出来的小组件</span><br></pre></td></tr></table></figure>

<h1 id="State-最小集"><a href="#State-最小集" class="headerlink" title="State 最小集"></a>State 最小集</h1><p>渲染组件所需要的数据有以下来源：外部传入的 prop、组件内部的 state、全局 state（比如 redux store）、组件 scope 外的常量，以及由前面这些基础数据计算得到的间接数据（即 Vue 中的 computed）。</p>
<p>新人易犯的错误是将间接数据作为 state 来维护，然后用 <code>useEffect</code> 去监听其他 state&#x2F;prop 并重新计算该数据。</p>
<p>组件内部 state 应是一个最小集，不包含任何间接数据或常量。请阅读<a href="https://zh-hans.react.dev/learn/thinking-in-react#step-3-identify-the-minimal-but-complete-representation-of-ui-state">官方示例中的第三步</a>。</p>
<h1 id="Prop-的设计"><a href="#Prop-的设计" class="headerlink" title="Prop 的设计"></a>Prop 的设计</h1><p>Prop 的设计应尽量从组件本身的需求出发，而不是套用父组件已有的数据和方法。举例来说：</p>
<ol>
<li>如果子组件需要的数据 c 是由父组件中的 a 和 b 计算而来的，那么应该为 c 设计一个 prop，在父组件中用 a 和 b 计算出 c 之后传给子组件，而不是为 a 和 b 设计两个 prop，在子组件内部再计算 c。这一条原则也可以理解为 prop 最小集。</li>
<li>如果子组件需要反向传递数据去设置父组件的 state（假设要传递的数据是 date），不要设计一个 setDate prop 然后把父组件的 setDate 直接传给子组件，而是设计一个 onDateChange prop，允许父组件设置一个 callback 去监听子组件的 date 变化。子组件不关心父组件是要 setDate 还是做什么，子组件只负责“广播”自己的数据变化“事件”。</li>
</ol>
<h1 id="组件内的代码组织"><a href="#组件内的代码组织" class="headerlink" title="组件内的代码组织"></a>组件内的代码组织</h1><p>目前我们统一用 React hooks 编写组件，hooks 的一大优势就是允许我们将组件内的代码按业务逻辑而非性质分组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Bad</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// states</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [state1, setState1] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [state2, setState2] = <span class="title function_">useState</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// computed</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> computed1 = state1 + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> computed2 = !state2;</span><br><span class="line">  <span class="keyword">const</span> computed3 = <span class="string">`<span class="subst">$&#123;computed1&#125;</span> <span class="subst">$&#123;computed2&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// side effects</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">sideEffect1</span>();</span><br><span class="line">    <span class="title function_">sideEffect2</span>();</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Good</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// logic group 1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [state1, setState1] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> computed1 = state1 + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">sideEffect1</span>();</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// logic group 2</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [state2, setState2] = <span class="title function_">useState</span>(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">const</span> computed2 = !state2;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">sideEffect2</span>();</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// logic group 3</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> computed3 = <span class="string">`<span class="subst">$&#123;computed1&#125;</span> <span class="subst">$&#123;computed2&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果组件中有很多个逻辑分组，可能就是该组件需要进一步拆分的信号。</p>
<h1 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h1><p>当一个组件树中有很多不同层级的组件需要访问一批同样的数据时，完全用 prop 传递会导致中间层的组件为了往下传递而多出很多它自己并不关心的 prop，此时你通常需要 context 解决方案，请阅读<a href="https://zh-hans.legacy.reactjs.org/docs/context.html">官方文档</a>。</p>
<p>当需要层层传递的数据本身非常简单时，也有<a href="https://zh-hans.legacy.reactjs.org/docs/context.html#before-you-use-context">除了 context 之外的解决方案</a>。</p>
<h1 id="表现与逻辑的分离"><a href="#表现与逻辑的分离" class="headerlink" title="表现与逻辑的分离"></a>表现与逻辑的分离</h1><p>组件主要负责表现层（即 UI 层）的逻辑，因此复杂的数据处理逻辑原则上不属于组件的职责，应提取为工具函数而不是直接放一大段代码在组件内。这个职责分离的原则与上文组件拆分的原则在本质上是一致的，即每个单元应负责自己唯一的职责。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>service worker</title>
    <url>/2023/02/19/service-worker/</url>
    <content><![CDATA[<p>了解 service work 前先了解一下 PWA，那么什么是 PWA 呢？</p>
<span id="more"></span>

<p><strong>渐进式网路应用 PWA</strong></p>
<ol>
<li>Web 应用和 Native 应用有着各自不同的优势和使用场景</li>
<li>PWA 结合了二者的优势</li>
<li>PWA 会越来越流行<blockquote>
<ul>
<li>Web 应用的资源存储在服务器，Native 的资源存储在本地。所以 Native 会比 Web 应用的加载速度和流畅性方面获得更好地表现；</li>
<li>PWA 旨在创造拥有更加流畅的用户体验的 Web 应用，和创建类 Native App 的沉浸式效果，而非浏览器端那样的外观和体验；</li>
<li>在各种网络和数据加载的条件下仍然可用－它可以在网络不稳定或者没有网络的情况下使用。</li>
</ul>
</blockquote>
</li>
</ol>
<h1 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h1><p>Service Worker 是 PWA 的关键技术，可以支持一些原始应用的功能</p>
<ul>
<li>友好的弱网和离线体验</li>
<li>定期的后台同步</li>
<li>推送通知</li>
</ul>
<p>Service workers  本质上充当 Web 应用程序、浏览器与网络（可用时）之间的代理服务器。</p>
<p>1.友好的弱网和离线体验<br>这个 API 旨在创建有效的离线体验，它会拦截网络请求并根据网络是否可用来采取适当的动作、更新来自服务器的的资源。它还提供入口以推送通知和访问后台同步 API。</p>
<h2 id="web-worker"><a href="#web-worker" class="headerlink" title="web worker"></a>web worker</h2><ul>
<li>JavaScript 是一个单线程的语言；</li>
<li>异步编程通过调度一部分代码在 <code>event loop</code> 中执行，从而让程序流畅地运行；</li>
<li>Web Workers 是真正的多线程</li>
<li>Service Worker 是 Web Worker 的一个子类</li>
</ul>
<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><ul>
<li>它是一种 Web worker，不能直接访问 DOM</li>
<li>它有自己独立的生命周期，不和特定网页相关联</li>
<li>是一个由事件驱动的 worker，它由源和路径组成</li>
<li>可以使用一些离线存储 API — Cache Storage 和 IndexedDB, 不能访问 localStorage</li>
<li>大量使用了 Promise</li>
<li>只能使用 HTTPS，localhost 也被允许</li>
</ul>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><ul>
<li>Service Worker 的生命周期和网页是相互独立的</li>
</ul>
<ul>
<li>在网页的 JS 代码中调用 Service Worker 的注册方法开始安装。在安装阶段可以进行一些缓存工作，缓存失败安装就会失败。如果安装成功，代表了缓存也成功完成了</li>
<li>安装成功后触发 activate 事件，Service Worker 处于激活状态</li>
<li>激活后的 Service Worker 线程可以控制页面、监听事件了，它可以根据情况被中止或者唤起</li>
</ul>
<h1 id="基本功能和用法"><a href="#基本功能和用法" class="headerlink" title="基本功能和用法"></a>基本功能和用法</h1><ul>
<li>install 事件会在注册完成之后触发。install 事件一般是被用来填充你的浏览器的离线缓存能力。</li>
</ul>
<p>为了达成这个目的，我们使用了 Service Worker 的新的标志性的存储 API — <strong>cache</strong> — 一个 service worker 上的全局对象，它使我们可以存储网络响应发来的资源，并且根据它们的请求来生成 key。<br>在安装事件的回调里我们需要完成一些缓存的工作，所以需要 <code>waitUntil()</code> 方法来暂时挂起代码，waitUntil 方法接受一个<code>promise</code>。</p>
<h2 id="使用-Cache-API-缓存资源"><a href="#使用-Cache-API-缓存资源" class="headerlink" title="使用 Cache API 缓存资源"></a>使用 Cache API 缓存资源</h2><p>Cache 接口为缓存的 <code>Request / Response</code> 对象对提供存储机制</p>
<p>一个域可以有多个命名 Cache 对象。</p>
<p>你需要在你的脚本 (例如，在 ServiceWorker 中)中处理缓存更新的方式。除非明确地更新缓存，否则缓存将不会被更新；除非删除，否则缓存数据不会过期。</p>
<p><code>CacheStorage</code> 接口表示 Cache 对象存储。</p>
<p>使用通过全局 caches 属性来访问 CacheStorage，可以在 window、Service Worker 中访问。</p>
<p><code>window.caches // CacheStorage&#123;&#125;</code></p>
<p>使用 <code>CacheStorage.open(cacheName)</code> 打开一个 Cache 对象，再使用 Cache 对象的方法去处理缓存。</p>
<blockquote>
<p>activate 事件在脚本激活后触发，一般在这里处理旧版本的缓存<br>fetch 事件监听客户端的请求，包括任何被 service worker 控制的文档和文档内引用的资源。配合 respondWith()  方法，可以劫持 HTTP 响应</p>
</blockquote>
<hr>
<ul>
<li><p>CacheStorage.open()</p>
</li>
<li><p>CacheStorage.keys()</p>
</li>
<li><p>CacheStorage.match()</p>
</li>
<li><p>Cache.addAll(requests)</p>
</li>
<li><p>Cache.add(request)</p>
</li>
<li><p>Cache.put(request,response)</p>
</li>
<li><p>Cache.match(request)</p>
</li>
<li><p>Cache.delete(request)</p>
</li>
</ul>
<h2 id="在-install-阶段缓存资源"><a href="#在-install-阶段缓存资源" class="headerlink" title="在 install 阶段缓存资源"></a>在 install 阶段缓存资源</h2><ul>
<li>打开缓存</li>
<li>缓存文件</li>
<li>确认是否所有的静态资源已缓存</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">self.<span class="title function_">addEventListener</span>(<span class="string">&quot;install&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  event.<span class="title function_">waitUntil</span>(</span><br><span class="line">    caches.<span class="title function_">open</span>(<span class="variable constant_">CACHE_NAME</span>).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">cache</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Opened cache&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> cache.<span class="title function_">addAll</span>(urlsToCache);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="缓存运行时请求"><a href="#缓存运行时请求" class="headerlink" title="缓存运行时请求"></a>缓存运行时请求</h2><ul>
<li>event.respondWith() 会决定如何响应 fetch 事件。 caches.match() 查询请求及查找之前创建的缓存中是否有任意缓存结果并返回 promise。</li>
<li>如果有，则返回该缓存数据。</li>
<li>否则，执行 fetch 。</li>
<li>检查返回的状态码是否是 200。同时检查响应类型是否为 basic，即检查请求是否同域。当前场景不缓存第三方资源的请求。</li>
<li>把返回数据添加到缓存中。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">self.<span class="title function_">addEventListener</span>(<span class="string">&quot;fetch&quot;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  event.<span class="title function_">respondWith</span>(</span><br><span class="line">    caches.<span class="title function_">match</span>(event.<span class="property">request</span>).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (response) &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//复制请求。请求是一个流且只能被使用一次。因为之前已经通过缓存使用过一次了，所以为了在浏览器中使用fetch，需要复制下该请求。</span></span><br><span class="line">      <span class="keyword">var</span> fetchRequest = event.<span class="property">request</span>.<span class="title function_">clone</span>();</span><br><span class="line">      <span class="comment">//没有找到缓存。所以我们需要执行 fetch 以发起请求并返回请求数据。</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">fetch</span>(fetchRequest).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">        <span class="comment">//检测返回数据是否有效</span></span><br><span class="line">        <span class="keyword">if</span> (!response || response.<span class="property">status</span> !== <span class="number">200</span> || response.<span class="property">type</span> !== <span class="string">&quot;basic&quot;</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//复制返回数据，因为它也是流。因为我们想要浏览器和缓存一样使用返回数据，所以必须复制它。这样就有两个流</span></span><br><span class="line">        <span class="keyword">var</span> responseToCache = response.<span class="title function_">clone</span>();</span><br><span class="line">        caches,</span><br><span class="line">          <span class="title function_">open</span>(<span class="variable constant_">CACHE_NAME</span>).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">cache</span>) &#123;</span><br><span class="line">            <span class="comment">//把请求添加到缓存中以备之后的查询用</span></span><br><span class="line">            cache.<span class="title function_">put</span>(event.<span class="property">request</span>, responseToCache);</span><br><span class="line">          &#125;);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="更新-Service-Worker"><a href="#更新-Service-Worker" class="headerlink" title="更新 Service Worker"></a>更新 Service Worker</h2><p>当用户访问网络应用的时候，浏览器会在后台重新下载包含 Service Worker 代码的  .js  文件。<br>如果下载下来的文件和当前的 Service Worker 代码文件不同，浏览器会认为文件发生了改变并且会创建一个新的 Service Worker。</p>
<p>创建新的 Service Worker 的过程将会启动，然后触发  install  事件。然而，这时候，旧的 Service Worker 仍然控制着网络应用的页面意即新的 Service Worker 将会处于  waiting  状态。</p>
<p>一旦关闭网络应用当前打开的页面，旧的 Service Worker 将会被浏览器杀死而新安装的 Service Worker 就可以上位了。这时候将会触发  activate  事件。</p>
<p>这是为了避免在不同选项卡中同时运行不同版本的的网络应用所造成的问题－<br>一些在网页中实际存在的问题且有可能会产生新的 bug（比如当在浏览器中本地存储数据的时候却拥有不同的数据库结构）。</p>
<h2 id="在-activate-阶段清理旧版本的缓存"><a href="#在-activate-阶段清理旧版本的缓存" class="headerlink" title="在 activate 阶段清理旧版本的缓存"></a>在 activate 阶段清理旧版本的缓存</h2><p>出现在 activate 回调中的一个常见任务是缓存管理。</p>
<p>这么做的原因是，如果在安装步骤中清除了任何旧缓存，则继续控制所有当前页面的任何旧 Service Worker 将突然无法从缓存中提供文件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//清除了旧版本的缓存</span></span><br><span class="line">self.<span class="title function_">addEventListener</span>(<span class="string">&quot;activate&quot;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  event.<span class="title function_">waitUntil</span>(</span><br><span class="line">    caches.<span class="title function_">keys</span>().<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">cacheNames</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(</span><br><span class="line">        cacheNames.<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">cacheName</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!expectedCaches.<span class="title function_">includes</span>(cacheNames)) &#123;</span><br><span class="line">            <span class="keyword">return</span> caches.<span class="title function_">delete</span>(key);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="如何在浏览器里面进行调试"><a href="#如何在浏览器里面进行调试" class="headerlink" title="如何在浏览器里面进行调试"></a>如何在浏览器里面进行调试</h1><h2 id="Update-on-reload"><a href="#Update-on-reload" class="headerlink" title="Update on reload"></a>Update on reload</h2><ul>
<li>重新提取 Service Worker。</li>
<li>即使字节完全相同，也将其作为新版本安装，这表示运行  install  事件并更新缓存。</li>
<li>跳过等待阶段，以激活新 Service Worker。</li>
<li>浏览页面。这意味着每次浏览时（包括刷新）都将进行更新，无需重新加载两次或关闭标签。</li>
</ul>
<h2 id="Offline-可以离线应用"><a href="#Offline-可以离线应用" class="headerlink" title="Offline 可以离线应用"></a>Offline 可以离线应用</h2><h2 id="Bypass-for-network-可以绕过-Service-Worker-的控制"><a href="#Bypass-for-network-可以绕过-Service-Worker-的控制" class="headerlink" title="Bypass for network 可以绕过 Service Worker 的控制"></a>Bypass for network 可以绕过 Service Worker 的控制</h2><p>Disable cache 选项不会影响 Service Worker 的缓存；<br>⌘ + ⇧ + R 强制刷新，会跳过 Service Worker 的控制；</p>
<p>打开 <code>chrome://inspect/#service-workers</code> 管理浏览器中的 Service Worker</p>
<p>参考资料：<br><a href="https://github.com/ChangbaFE/presentation">ChangbaFE&#x2F;presentation</a></p>
]]></content>
  </entry>
  <entry>
    <title>sleep 函数</title>
    <url>/2020/12/18/sleep-function/</url>
    <content><![CDATA[<p>JS 没有语言内置的休眠（sleep or wait）函数，所谓的 sleep 只是实现一种延迟执行的效果</p>
<p>等待指定时间后再执行对应方法</p>
<span id="more"></span>

<h2 id="方法一：伪死循环阻塞主线程"><a href="#方法一：伪死循环阻塞主线程" class="headerlink" title="方法一：伪死循环阻塞主线程"></a>方法一：伪死循环阻塞主线程</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 因为JS是单线程的，所以通过这种方式可以实现真正意义上的sleep</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sleep1</span>(<span class="params">fn, time</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> start = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>() - start &lt; time) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">fn</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方式二：-定时器"><a href="#方式二：-定时器" class="headerlink" title="方式二： 定时器"></a>方式二： 定时器</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sleep2</span>(<span class="params">fn, time</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(fn, time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方式三：promise"><a href="#方式三：promise" class="headerlink" title="方式三：promise"></a>方式三：promise</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function sleep3(fn, time) &#123;</span><br><span class="line">  new Promise(resolve =&gt; &#123;</span><br><span class="line">    setTimeout(resolve, time);</span><br><span class="line">  &#125;).then(() =&gt; &#123;</span><br><span class="line">    fn();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="方式四：async-await"><a href="#方式四：async-await" class="headerlink" title="方式四：async await"></a>方式四：async await</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">sleep4</span>(<span class="params">fn, time</span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, time);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="title function_">fn</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fn&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sleep1</span>(fn, <span class="number">2000</span>);</span><br><span class="line"><span class="title function_">sleep2</span>(fn, <span class="number">2000</span>);</span><br><span class="line"><span class="title function_">sleep3</span>(fn, <span class="number">2000</span>);</span><br><span class="line"><span class="title function_">sleep4</span>(fn, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>强缓存和协商缓存</title>
    <url>/2020/02/20/strong-cache/</url>
    <content><![CDATA[<h1 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h1><p>所谓强缓存，可以理解为强制缓存的意思，即<strong>浏览器在访问某个资源时会判断是否使用本地缓存里已经存在的资源文件，使用本地缓存的话则不会发送请求到服务器，从而达到减轻服务器访问压力的作用</strong>，且由于直接从本地缓存读取资源文件，大大提高了加载速度。</p>
<h2 id="强缓存的具体流程为："><a href="#强缓存的具体流程为：" class="headerlink" title="强缓存的具体流程为："></a>强缓存的具体流程为：</h2><p>浏览器第一次请求远程服务器的某个资源时，如果服务器希望浏览器得到该资源后一段时间内不要再发送请求过来，直接从浏览器里的缓存里取，则服务器可以通过在响应头里设置 <code>Cache-Control: max-age=31536000</code>，<code>max-age</code> 代表缓存时间，单位为秒，这里的数据换算过来就是一年，意味着在一年内浏览器不会再向服务器发送请求。</p>
<img src="/2020/02/20/strong-cache/max-age.png" class title="max-age">

<p>使用缓存的话，状态码 200 后面会标明情况。浏览器缓存资源的地方有两个：磁盘缓存（disk cache）和内存缓存（memory cache）。</p>
<p>Cache-Control 除了 max-age 外，还可以设置其它属性值：</p>
<ul>
<li>no-cache: 不使用强缓存（但仍会使用协商缓存）。</li>
<li>no-store: 不使用缓存（不使用强缓存也不使用协商缓存），每次都向服务器发送资源请求。</li>
<li>private： 只允许客户端使用缓存，不允许其他代理服务器进行缓存。</li>
<li>public: 客户端和代理服务器都可缓存。</li>
<li>s-maxage: 与 max-age 类似，区别是 s-maxage 是设定代理服务器的缓存时间。</li>
</ul>
<p>强缓存除了使用<code>Cache-Control</code>实现之外，还可以使用<code>Expires</code>字段，<code>Expires</code>是 Http1.0 规范，<code>Cache-Control</code>是 Http1.1 规范，<code>Expires</code>返回一个具体的时间值（如下图所示），代表缓存的有效期，在该日期内浏览器不会向服务器发起请求，而是直接从缓存里获取资源。</p>
<p>因为 Expires 参照的是本地客户端的时间，而客户端的时间是可以被修改的，所以会有误差产生的情况，这也是 Expires 的一个缺点，所以有了后来 Http1.1 规范的 Cache-control。<br>另外，Cache-control 的优先级要高于 Expires，如果两者同时设置，会优先使用 Cache-control 而忽略掉 Expires。</p>
<h1 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h1><p>在强缓存里，是否使用缓存是由浏览器来确定的，而协商缓存则是由<strong>服务器来告诉浏览器是否使用缓存资源，也就是浏览器每一次都要发送请求到服务器询问是否使用缓存</strong>，协商缓存的具体流程如下：</p>
<p>浏览器初次请求资源，服务器返回资源，同时生成一个<code>Etag</code>值携带在响应头里返回给浏览器，当浏览器再次请求资源时会在请求头里携带<code>If-None-Match</code>，值是之前服务器返回的<code>Etag</code>的值，服务器收到之后拿该值与资源文件最新的<code>Etag</code>值做对比。</p>
<ul>
<li>如果没有变化则返回 304，告诉浏览器继续使用缓存（不返回资源文件）。</li>
<li>如果发生变化，则返回 200 和最新的资源文件给浏览器使用。</li>
</ul>
<p>除了 Etag 外，还有一个 <code>Last-Modified</code> 的属性，它是 Http1.0 规范的，服务器返回 Last-Modified，浏览器请求头对应携带的是 <code>If-Modified-since</code>，与 Etag 不同的是，<code>Last-Modified</code> 的值是一个时间值，代表文件的修改时间，服务器通过对比文件的修改时间是否发生改变来判断是否使用缓存。</p>
<p>相比 <code>Last-Modified</code>，Etag 优先级更高，使用上也更精确一些，因为有时候会存在文件内容并没有改变，但文件的修改时间变更了，<code>Last-Modified</code> 不一致所以服务器会重新返回资源文件，实际上还是可以继续使用缓存的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>强缓存就是浏览器本地根据服务器设置的过期时间来判断是否使用缓存，未过期则从本地缓存里拿资源，已过期则重新请求服务器获取最新资源。</p>
<p>协商缓存则是浏览器本地每次都向服务器发起请求，由服务器来告诉浏览器是从缓存里拿资源还是返回最新资源给浏览器使用。</p>
<p><a href="https://juejin.cn/post/7259298281578889273">参考链接</a></p>
]]></content>
  </entry>
  <entry>
    <title>todo</title>
    <url>/2023/12/18/todo/</url>
    <content><![CDATA[<p>图片标注<br>immer&#x2F;immutable<br>graphql&#x2F;node<br>navigator.online(rel)</p>
<h1 id="npm-package"><a href="#npm-package" class="headerlink" title="npm package"></a>npm package</h1><ul>
<li>包和模块的区别</li>
<li>如何避免业务项目被发布到 npm</li>
</ul>
<h1 id="monorepo"><a href="#monorepo" class="headerlink" title="monorepo"></a>monorepo</h1><p>ElectronJS</p>
<p>Hybrid</p>
<p>webpack、babel、postcss 等</p>
<p>taiwind</p>
<p>react 18</p>
<p>bff 层</p>
]]></content>
  </entry>
  <entry>
    <title>前端文件流、切片下载和上传</title>
    <url>/2023/12/22/upload-big-file/</url>
    <content><![CDATA[<h1 id="一、前端文件流操作"><a href="#一、前端文件流操作" class="headerlink" title="一、前端文件流操作"></a>一、前端文件流操作</h1><p>下面创建一个 <code>fileUpload</code> 的函数式组件，当用户选择文件时，通过<code>FileReader</code>将文件内容读取为 <code>ArrayButter</code>,然后将<code>ArrayBuffer</code>转换为十六进制字符串，并将结果显示在页面上。</p>
<span id="more"></span>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">FileInput</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [fileContent, setFileContent] = <span class="title function_">useState</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取文件内容到ArrayBuffer</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">readFileToArrayBuffer</span>(<span class="params">file</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 注册文件读取完成后的回调函数</span></span><br><span class="line">      reader.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> arrayBuffer = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">        <span class="title function_">resolve</span>(arrayBuffer);</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 读取文件内容到ArrayBuffer</span></span><br><span class="line">      reader.<span class="title function_">readAsArrayBuffer</span>(file);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将ArrayBuffer转为十六进制字符串</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">arrayBufferToHexString</span>(<span class="params">arrayBuffer</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> uint8Array = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(arrayBuffer);</span><br><span class="line">    <span class="keyword">let</span> hexString = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; uint8Array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> hex = uint8Array[i].<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">padStart</span>(<span class="number">2</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">      hexString += hex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hexString;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理文件选择事件</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleFileChange</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> file = event.<span class="property">target</span>.<span class="property">files</span>[<span class="number">0</span>]; <span class="comment">// 获取选中的文件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file) &#123;</span><br><span class="line">      <span class="title function_">readFileToArrayBuffer</span>(file)</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">(<span class="params">arrayBuffer</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> hexString = <span class="title function_">arrayBufferToHexString</span>(arrayBuffer);</span><br><span class="line">          <span class="title function_">setFileContent</span>(hexString);</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;文件读取失败:&quot;</span>, error);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">setFileContent</span>(<span class="string">&quot;请选择一个文件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">onChange</span>=<span class="string">&#123;handleFileChange&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h4</span>&gt;</span>文件内容：<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">pre</span>&gt;</span>&#123;fileContent&#125;<span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">FileInput</span>;</span><br></pre></td></tr></table></figure>

<h1 id="二、文件切片下载"><a href="#二、文件切片下载" class="headerlink" title="二、文件切片下载"></a>二、文件切片下载</h1><p>文件切片下载的好处：</p>
<ul>
<li>快速启动：客户端可以快速开始下载，因为只需要下载第一个切片即可。</li>
<li>并发下载：通过使用多个并发请求下载切片，可以充分利用带宽，并提高整体下载速度。</li>
<li>断点续传：如果下载中断，客户端只需要重新下载中断的切片，而不需要重新下载整个文件。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [selectedFile, setSelectedFile] = <span class="title function_">useState</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">const</span> [progress, setProgress] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 处理文件选择事件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleFileChange</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="title function_">setSelectedFile</span>(event.<span class="property">target</span>.<span class="property">files</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理文件上传事件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleFileUpload</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (selectedFile) &#123;</span><br><span class="line">    <span class="comment">// 计算切片数量和每个切片的大小</span></span><br><span class="line">    <span class="keyword">const</span> fileSize = selectedFile.<span class="property">size</span>;</span><br><span class="line">    <span class="keyword">const</span> chunkSize = <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// 设置切片大小为1MB</span></span><br><span class="line">    <span class="keyword">const</span> totalChunks = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(fileSize / chunkSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建FormData对象，并添加文件信息</span></span><br><span class="line">    <span class="keyword">const</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">    formData.<span class="title function_">append</span>(<span class="string">&quot;file&quot;</span>, selectedFile);</span><br><span class="line">    formData.<span class="title function_">append</span>(<span class="string">&quot;totalChunks&quot;</span>, totalChunks);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环上传切片</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> chunkNumber = <span class="number">0</span>; chunkNumber &lt; totalChunks; chunkNumber++) &#123;</span><br><span class="line">      <span class="keyword">const</span> start = chunkNumber * chunkSize;</span><br><span class="line">      <span class="keyword">const</span> end = <span class="title class_">Math</span>.<span class="title function_">min</span>(start + chunkSize, fileSize);</span><br><span class="line">      <span class="keyword">const</span> chunk = selectedFile.<span class="title function_">slice</span>(start, end);</span><br><span class="line">      formData.<span class="title function_">append</span>(<span class="string">`chunk-<span class="subst">$&#123;chunkNumber&#125;</span>`</span>, chunk, selectedFile.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起文件上传请求</span></span><br><span class="line">    axios</span><br><span class="line">      .<span class="title function_">post</span>(<span class="string">&quot;/upload&quot;</span>, formData, &#123;</span><br><span class="line">        <span class="attr">onUploadProgress</span>: <span class="function">(<span class="params">progressEvent</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> progress = <span class="title class_">Math</span>.<span class="title function_">round</span>(</span><br><span class="line">            (progressEvent.<span class="property">loaded</span> / progressEvent.<span class="property">total</span>) * <span class="number">100</span></span><br><span class="line">          );</span><br><span class="line">          <span class="title function_">setProgress</span>(progress);</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;文件上传成功:&quot;</span>, response.<span class="property">data</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;文件上传失败:&quot;</span>, error);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当用户选择文件后，通过 <code>handleFileChange</code> 函数处理文件选择事件，将选择的文件保存在 <code>selectedFile</code> 状态中。<br>当用户点击上传按钮时，通过 <code>handleFileUpload</code> 函数处理文件上传事件。<br>在 <code>handleFileUpload</code> 函数中，计算切片数量和每个切片的大小，并创建一个 <code>FormData</code> 对象用于存储文件信息和切片数据。</p>
</blockquote>
<h2 id="实现客户端切片下载的方案"><a href="#实现客户端切片下载的方案" class="headerlink" title="实现客户端切片下载的方案"></a>实现客户端切片下载的方案</h2><p>实现客户端切片下载的基本方案如下：</p>
<ol>
<li>服务器端将大文件切割成多个切片，并为每个切片生成唯一的标识符。</li>
<li>客户端发送请求获取切片列表，同时开始下载第一个切片。</li>
<li>客户端在下载过程中，根据切片列表发起并发请求下载其他切片，并逐渐拼接合并下载的数据。</li>
<li>当所有切片都下载完成后，客户端将下载的数据合并为完整的文件</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">downloadFile</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 发起文件下载请求</span></span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&quot;/download&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> totalSize = data.<span class="property">totalSize</span>;</span><br><span class="line">      <span class="keyword">const</span> totalChunks = data.<span class="property">totalChunks</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> downloadedChunks = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">let</span> chunks = [];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 下载每个切片</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> chunkNumber = <span class="number">0</span>; chunkNumber &lt; totalChunks; chunkNumber++) &#123;</span><br><span class="line">        <span class="title function_">fetch</span>(<span class="string">`/download/<span class="subst">$&#123;chunkNumber&#125;</span>`</span>, &#123;</span><br><span class="line">          <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">          .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> response.<span class="title function_">blob</span>())</span><br><span class="line">          .<span class="title function_">then</span>(<span class="function">(<span class="params">chunk</span>) =&gt;</span> &#123;</span><br><span class="line">            downloadedChunks++;</span><br><span class="line">            chunks.<span class="title function_">push</span>(chunk);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当所有切片都下载完成时</span></span><br><span class="line">            <span class="keyword">if</span> (downloadedChunks === totalChunks) &#123;</span><br><span class="line">              <span class="comment">// 合并切片</span></span><br><span class="line">              <span class="keyword">const</span> mergedBlob = <span class="keyword">new</span> <span class="title class_">Blob</span>(chunks);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 创建对象 URL，生成下载链接</span></span><br><span class="line">              <span class="keyword">const</span> downloadUrl = <span class="variable language_">window</span>.<span class="property">URL</span>.<span class="title function_">createObjectURL</span>(mergedBlob);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 创建 &lt;a&gt; 元素并设置属性</span></span><br><span class="line">              <span class="keyword">const</span> link = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">              link.<span class="property">href</span> = downloadUrl;</span><br><span class="line">              link.<span class="title function_">setAttribute</span>(<span class="string">&quot;download&quot;</span>, <span class="string">&quot;file.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 模拟点击下载</span></span><br><span class="line">              link.<span class="title function_">click</span>();</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 释放资源</span></span><br><span class="line">              <span class="variable language_">window</span>.<span class="property">URL</span>.<span class="title function_">revokeObjectURL</span>(downloadUrl);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;文件下载失败:&quot;</span>, error);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看下代码，首先使用 <code>BLOB</code> 对象创建一共对象 URL，用于生成下载连接，然后创建 a 标签并且设置 href 的属性为刚刚创建的对象 URL,继续设置 a 标签的 <code>download</code> 属性是文件名，方便点击的时候自动下载文件。</p>
<h2 id="显示下载进度和完成状态"><a href="#显示下载进度和完成状态" class="headerlink" title="显示下载进度和完成状态"></a>显示下载进度和完成状态</h2><p>为了显示下载进度和完成状态，可以在客户端实现以下功能：</p>
<ol>
<li>显示进度条：客户端可以通过监听每个切片的下载进度来计算整体下载进度，并实时更新进度条的显示。</li>
<li>显示完成状态：当所有切片都下载完成后，客户端可以显示下载完成的状态，例如显示一个完成的图标或者文本。<br>这里我们可以继续接着切片上传代码示例里的继续写。</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleFileDownload</span>(<span class="params"></span>) &#123;</span><br><span class="line">  axios.<span class="title function_">get</span>(<span class="string">&#x27;/download&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">responseType</span>: <span class="string">&#x27;blob&#x27;</span>,</span><br><span class="line">    <span class="attr">onDownloadProgress</span>: <span class="function"><span class="params">progressEvent</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> progress = <span class="title class_">Math</span>.<span class="title function_">round</span>((progressEvent.<span class="property">loaded</span> / progressEvent.<span class="property">total</span>) * <span class="number">100</span>);</span><br><span class="line">      <span class="title function_">setProgress</span>(progress);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 创建一个临时的URL对象用于下载</span></span><br><span class="line">      <span class="keyword">const</span> url = <span class="variable language_">window</span>.<span class="property">URL</span>.<span class="title function_">createObjectURL</span>(<span class="keyword">new</span> <span class="title class_">Blob</span>([response.<span class="property">data</span>]));</span><br><span class="line">      <span class="keyword">const</span> link = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">      link.<span class="property">href</span> = url;</span><br><span class="line">      link.<span class="title function_">setAttribute</span>(<span class="string">&#x27;download&#x27;</span>, <span class="string">&#x27;file.txt&#x27;</span>);</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(link);</span><br><span class="line">      link.<span class="title function_">click</span>();</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(link);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;文件下载失败:&#x27;</span>, error);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;button onClick=&#123;handleFileDownload&#125;&gt;下载文件&lt;/button&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>进度：&#123;progress&#125;%<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>当用户点击下载按钮时，通过 <code>handleFileDownload</code> 函数处理文件下载事件。</li>
<li>在 <code>handleFileDownload</code> 函数中，使用 <code>axios</code> 库发起文件下载请求，并设置 <code>responseType: &#39;blob&#39;</code> 表示返回二进制数据。</li>
<li>通过监听 <code>onDownloadProgress</code> 属性获取下载进度，并更新进度条的显示。</li>
<li>下载完成后，创建一个临时的 <code>URL</code> 对象用于下载，并通过动态创建 <code>&lt;a&gt;</code> 元素模拟点击下载。</li>
</ul>
<h1 id="实现断点续传的技术：记录和恢复上传状态"><a href="#实现断点续传的技术：记录和恢复上传状态" class="headerlink" title="实现断点续传的技术：记录和恢复上传状态"></a>实现断点续传的技术：记录和恢复上传状态</h1><ul>
<li>在前端，可以使用 <code>localStorage</code> 或 <code>sessionStorage</code> 来存储已上传的切片信息，包括已上传的切片索引、切片大小等。</li>
<li>每次上传前，先检查本地存储中是否存在已上传的切片信息，若存在，则从断点处继续上传。</li>
<li>在后端，可以使用一个临时文件夹或数据库来记录已接收到的切片信息，包括已上传的切片索引、切片大小等。</li>
<li>在上传完成前，保存上传状态，以便在上传中断后能够恢复上传进度。</li>
</ul>
<blockquote>
<p>在实现大文件上传时要考虑服务器端的处理能力和存储空间，以及安全性问题。同时，为了保障断点续传的准确性，应该尽量避免并发上传相同文件的情况，可以采用文件唯一标识符或用户会话标识符进行区分。</p>
</blockquote>
]]></content>
      <categories>
        <category>js</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>优化</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>react</title>
    <url>/2024/01/02/react/</url>
    <content><![CDATA[<img src="/2024/01/02/react/dom.png" class title="dom">

<p>组件初始化—-render 方法—-&gt;生成虚拟 DOM—ReactDOM.render 方法—&gt;真实 DOM</p>
<p>组件更新—- render 方法—-&gt;生成新的虚拟 DOM—-diff 算法—-&gt;定位出两次虚拟 DOM 的差异</p>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs-Express</title>
    <url>/2023/12/27/NodeJs-Express/</url>
    <content><![CDATA[<h1 id="简单的-demo"><a href="#简单的-demo" class="headerlink" title="简单的 demo"></a>简单的 demo</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="comment">//HTTP请求体解析中间件</span></span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&quot;body-parser&quot;</span>);</span><br><span class="line"><span class="comment">//日志组件</span></span><br><span class="line"><span class="keyword">const</span> morgan = <span class="built_in">require</span>(<span class="string">&quot;morgan&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> jsonParser = bodyParser.<span class="title function_">json</span>(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">unknownEndpoint</span> = (<span class="params">request, response</span>) =&gt; &#123;</span><br><span class="line">  response.<span class="title function_">status</span>(<span class="number">404</span>).<span class="title function_">send</span>(&#123; <span class="attr">error</span>: <span class="string">&quot;unknown endpoint&quot;</span> &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(unknownEndpoint);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">json</span>());</span><br><span class="line"></span><br><span class="line">morgan.<span class="title function_">token</span>(<span class="string">&quot;body&quot;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(req.<span class="property">body</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">morgan.<span class="title function_">format</span>(</span><br><span class="line">  <span class="string">&quot;format&quot;</span>,</span><br><span class="line">  <span class="string">&quot;:method :url :status :res[content-length] - :response-time ms :body&quot;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">morgan</span>(<span class="string">&quot;format&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> persons = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Arto Hellas&quot;</span>,</span><br><span class="line">    <span class="attr">number</span>: <span class="string">&quot;040-123456&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Ada Lovelace&quot;</span>,</span><br><span class="line">    <span class="attr">number</span>: <span class="string">&quot;39-44-5323523&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Dan Abramov&quot;</span>,</span><br><span class="line">    <span class="attr">number</span>: <span class="string">&quot;12-43-234345&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Mary Poppendieck&quot;</span>,</span><br><span class="line">    <span class="attr">number</span>: <span class="string">&quot;39-23-6423122&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/api/persons&quot;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  response.<span class="title function_">json</span>(persons);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/info&quot;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> peopleNum = persons.<span class="property">length</span>;</span><br><span class="line">  response.<span class="title function_">send</span>(</span><br><span class="line">    <span class="string">`&lt;p&gt;Phonebook has info for <span class="subst">$&#123;peopleNum&#125;</span> people&lt;/p&gt;&lt;p&gt;<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>()&#125;</span>&lt;/p&gt;`</span></span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/api/persons/:id&quot;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> id = <span class="title class_">Number</span>(request.<span class="property">params</span>.<span class="property">id</span>);</span><br><span class="line">  <span class="keyword">const</span> person = persons.<span class="title function_">find</span>(<span class="function">(<span class="params">i</span>) =&gt;</span> i.<span class="property">id</span> === id);</span><br><span class="line">  <span class="keyword">if</span> (person) &#123;</span><br><span class="line">    response.<span class="title function_">json</span>(person);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    response.<span class="title function_">status</span>(<span class="number">404</span>).<span class="title function_">end</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">delete</span>(<span class="string">&quot;/api/persons/:id&quot;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> id = <span class="title class_">Number</span>(request.<span class="property">params</span>.<span class="property">id</span>);</span><br><span class="line">  persons = persons.<span class="title function_">filter</span>(<span class="function">(<span class="params">i</span>) =&gt;</span> i.<span class="property">id</span> !== id);</span><br><span class="line">  response.<span class="title function_">status</span>(<span class="number">204</span>).<span class="title function_">send</span>(&#123; <span class="attr">msg</span>: <span class="string">&quot;delete successful&quot;</span> &#125;).<span class="title function_">end</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&quot;/api/persons&quot;</span>, jsonParser, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> person = request.<span class="property">body</span>;</span><br><span class="line">  <span class="keyword">if</span> (!person.<span class="property">name</span>) &#123;</span><br><span class="line">    response.<span class="title function_">status</span>(<span class="number">400</span>).<span class="title function_">send</span>(&#123; <span class="attr">error</span>: <span class="string">&quot;please provide name&quot;</span> &#125;);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!person.<span class="property">number</span>) &#123;</span><br><span class="line">    response.<span class="title function_">status</span>(<span class="number">400</span>).<span class="title function_">send</span>(&#123; <span class="attr">error</span>: <span class="string">&quot;please provide number&quot;</span> &#125;);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> isExistName = persons.<span class="title function_">find</span>(<span class="function">(<span class="params">i</span>) =&gt;</span> i.<span class="property">name</span> === person.<span class="property">name</span>);</span><br><span class="line">  <span class="keyword">if</span> (isExistName) &#123;</span><br><span class="line">    response.<span class="title function_">status</span>(<span class="number">400</span>).<span class="title function_">send</span>(&#123; <span class="attr">error</span>: <span class="string">&quot;name must be unique&quot;</span> &#125;);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  person.<span class="property">id</span> = <span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (<span class="number">1000</span> - <span class="number">100000000</span>)) + <span class="number">100000000</span>;</span><br><span class="line"></span><br><span class="line">  persons = persons.<span class="title function_">concat</span>(person);</span><br><span class="line"></span><br><span class="line">  response.<span class="title function_">json</span>(person);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3001</span>);</span><br></pre></td></tr></table></figure>

<h1 id="中间件-（Middleware）"><a href="#中间件-（Middleware）" class="headerlink" title="中间件 （Middleware）"></a>中间件 （Middleware）</h1><p>中间件是可以用来处理 request 和 response 对象的函数。</p>
<p>我们之前使用的 <code>json-parser</code> 从请求中获取原始数据，这些数据存储在 <code>request</code> 对象中，将其解析为一个 JavaScript 对象，并将其作为一个新的属性 <code>body</code> 分配给 <code>request</code> 对象。</p>
<p>让我们来实现我们自己的中间件，它可以打印出发送到服务器的每个请求的信息。</p>
<p>中间件是一个接收三个参数的函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">requestLogger</span> = (<span class="params">request, response, next</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Method:&quot;</span>, request.<span class="property">method</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Path:  &quot;</span>, request.<span class="property">path</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Body:  &quot;</span>, request.<span class="property">body</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;---&quot;</span>);</span><br><span class="line">  <span class="title function_">next</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在函数体的最后，调用作为参数传递的 <code>next</code> 函数。这个<code>next</code> 函数将控制权交给下一个中间件。</p>
<p>中间件是这样被使用的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app.use(requestLogger)</span><br></pre></td></tr></table></figure>

<p>中间件函数的调用顺序是它们被 <code>Express</code> 服务器对象的 <code>use</code> 方法所使用的顺序。请注意，<code>json-parser</code> 是在 <code>requestLogger</code> 中间件之前被使用的，因为否则在执行记录器的时候，<code>request.body</code> 将不会被初始化。</p>
<p>如果我们想让中间件函数在路由事件处理程序被调用前执行，那么就必须在路由之前使用这些中间件函数。也有一些情况，我们想在路由之后定义中间件函数。在实践中，这意味着我们要定义的中间件函数只有在没有路由处理 HTTP 请求时才会被调用。</p>
<p>让我们在路由之后添加以下中间件，用于捕捉向不存在的路由发出的请求。对于这些请求，中间件将返回一个 JSON 格式的错误信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const unknownEndpoint = (request, response) =&gt; &#123;</span><br><span class="line">  response.status(404).send(&#123; error: &#x27;unknown endpoint&#x27; &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.use(unknownEndpoint)</span><br></pre></td></tr></table></figure>

<h1 id="morgan"><a href="#morgan" class="headerlink" title="morgan"></a>morgan</h1><p><a href="https://github.com/expressjs/morgan">github</a></p>
<blockquote>
<p>注意，即使在控制台中记录数据也是危险的，因为它可能包含敏感数据，并可能违反当地的隐私法（如欧盟的 GDPR）或商业标准。</p>
</blockquote>
<h2 id="自定义日志格式"><a href="#自定义日志格式" class="headerlink" title="自定义日志格式"></a>自定义日志格式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">morgan.<span class="title function_">format</span>(</span><br><span class="line">  <span class="string">&quot;format&quot;</span>,</span><br><span class="line">  <span class="string">&quot;:method :url :status :res[content-length] - :response-time ms :body&quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="自定义-token"><a href="#自定义-token" class="headerlink" title="自定义 token"></a>自定义 token</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">morgan.<span class="title function_">token</span>(<span class="string">&quot;body&quot;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(req.<span class="property">body</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="控制台运行结果"><a href="#控制台运行结果" class="headerlink" title="控制台运行结果"></a>控制台运行结果</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /api/persons 400 31 - 0.621 ms &#123;&quot;name&quot;:&quot;aapls&quot;,&quot;number&quot;:&quot;0asd20-8780&quot;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="mongoose"><a href="#mongoose" class="headerlink" title="mongoose"></a>mongoose</h1><ol>
<li>在 <a href="https://cloud.mongodb.com/">https://cloud.mongodb.com/</a> 上建好 project 后，本地连接上（这个步骤不记得的可以上网搜索）</li>
<li>安装 mongoose</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install mongoose</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>node</tag>
        <tag>express</tag>
      </tags>
  </entry>
  <entry>
    <title>BFF(Backend For Frontend)</title>
    <url>/2024/01/16/BFF/</url>
    <content><![CDATA[<p>BFF，既 Backend For Frontend。 中文翻译过来的意思是前端的后端。</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>前端后端 (BFF) 是一种架构模式，涉及为每个客户端应用程序创建单独的后端。这可以更好地分离关注点，因为可以根据客户端应用程序的需求专门定制后端。BFF 还可以通过减少客户端和服务器之间需要传输的数据量来提高性能和可扩展性。</p>
<span id="more"></span>

<h1 id="比喻"><a href="#比喻" class="headerlink" title="比喻"></a>比喻</h1><p>前端后端（BFF）架构可以类比为一套量身定制的套装。正如西装是根据穿着者的具体尺寸和偏好量身定制的一样，BFF 也是根据客户端应用程序的特定需求和要求量身定制的。这可以更好地分离关注点并提高性能，类似于合身的西装如何增强穿着者的舒适度和外观。</p>
<h1 id="何时使用-BFF-模式？"><a href="#何时使用-BFF-模式？" class="headerlink" title="何时使用 BFF 模式？"></a>何时使用 BFF 模式？</h1><h2 id="1-微服务架构"><a href="#1-微服务架构" class="headerlink" title="1.微服务架构"></a>1.微服务架构</h2><p>BFF 在微服务架构中特别有用，其中每个微服务都可以有自己的 BFF。这使得微服务之间具有更大的灵活性和独立性，因为每个微服务都可以为其特定的客户端应用程序拥有自己定制的后端。</p>
<h2 id="2-架构解耦"><a href="#2-架构解耦" class="headerlink" title="2. 架构解耦"></a>2. 架构解耦</h2><p>与其他架构模式（例如微前端）结合使用，它创建了一个更具凝聚力和模块化的系统</p>
<h2 id="3-跨平台开发"><a href="#3-跨平台开发" class="headerlink" title="3. 跨平台开发"></a>3. 跨平台开发</h2><p>当构建多个客户端应用程序时，需要不同的后端来保持更好的关注点分离。</p>
<h2 id="4-敏捷开发"><a href="#4-敏捷开发" class="headerlink" title="4. 敏捷开发"></a>4. 敏捷开发</h2><p>BFF 还可以在不影响后端的情况下更轻松地维护和更新客户端应用程序，从而帮助简化开发过程。</p>
<h2 id="5-性能优势"><a href="#5-性能优势" class="headerlink" title="5.性能优势"></a>5.性能优势</h2><p>使用 BFF 可以通过减少客户端和服务器之间传输的数据量来提高性能和可扩展性</p>
<h2 id="6-构建微前端"><a href="#6-构建微前端" class="headerlink" title="6. 构建微前端"></a>6. 构建微前端</h2><p>在构建微前端时，将前端分解为更小、更易于管理的部分，以便可以独立开发和部署。每个微前端都可以有自己的 BFF，这可以提高关注点分离和灵活性</p>
<h1 id="何时不使用-BFF-模式？"><a href="#何时不使用-BFF-模式？" class="headerlink" title="何时不使用 BFF 模式？"></a>何时不使用 BFF 模式？</h1><h2 id="1-小团队"><a href="#1-小团队" class="headerlink" title="1.小团队"></a>1.小团队</h2><p>BFF 可能会带来额外的复杂性和维护开销，因为每个客户端应用程序都有自己的后端需要维护。对于资源有限的小型团队和初创公司来说，这尤其具有挑战性。</p>
<h2 id="2-产品可行性"><a href="#2-产品可行性" class="headerlink" title="2. 产品可行性"></a>2. 产品可行性</h2><p>当构建不需要复杂客户端应用程序的产品时，不需要根据特定客户端应用程序的需求定制后端</p>
<h2 id="3-Rest-足够了"><a href="#3-Rest-足够了" class="headerlink" title="3.Rest 足够了"></a>3.Rest 足够了</h2><p>在构建需要传统 RESTful API 架构（这是 Web API 最常见的架构）的应用程序时。</p>
<h2 id="4-编排延迟"><a href="#4-编排延迟" class="headerlink" title="4. 编排延迟"></a>4. 编排延迟</h2><p>在构建需要直接客户端到微服务通信的应用程序时，这样做是为了减少解耦微服务之间的附加通信层带来的延迟。</p>
<h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><p>以下是使用 React.js 的 BFF（前端后端）代码示例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = <span class="title function_">useState</span>([]);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">&quot;/api&quot;</span>)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line"></span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> <span class="title function_">setData</span>(data));</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;data.map((item) =&gt; (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;item.id&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;item.title&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;item.body&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      ))&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此代码设置一个 React 组件，该组件从 BFF API 端点获取数据并将其呈现在页面上。useEffect 挂钩用于在组件安装后立即获取数据。使用 useState 挂钩将获取的数据存储在组件的状态中，然后进行映射以显示数据数组中的每个项目。</p>
<h1 id="BFF-模式的替代方案"><a href="#BFF-模式的替代方案" class="headerlink" title="BFF 模式的替代方案"></a>BFF 模式的替代方案</h1><p>BFF 并不是唯一支持复杂 Web 开发的架构模式。还有其他流行的模式可以独立使用或与 BFF 一起使用：</p>
<h2 id="API-网关模式"><a href="#API-网关模式" class="headerlink" title="API 网关模式"></a>API 网关模式</h2><p>在此模式中，单个 API 网关负责处理所有客户端请求并与适当的微服务和后端进行通信。这可以简化架构并减少维护开销，因为客户端和后端之间只有一个接触点。但是，在处理 API 网关和微服务&#x2F;后端之间的路由和通信时，它也可能会带来额外的延迟和复杂性。</p>
<h2 id="无服务器架构"><a href="#无服务器架构" class="headerlink" title="无服务器架构"></a>无服务器架构</h2><p>该架构基于按需运行代码的概念，而不是始终运行专用服务器或服务器集群。这有助于降低成本并简化架构。</p>
<h2 id="GraphQL"><a href="#GraphQL" class="headerlink" title="GraphQL"></a>GraphQL</h2><p><a href="https://graphql.org/">GraphQL</a> 是 RESTful API 的替代方案，允许客户端指定他们需要的确切数据并仅接收该数据。这可以减少客户端和服务器之间传输的数据量并提高性能。</p>
<blockquote>
<p>GraphQL is a query language for APIs and a runtime for fulfilling those queries with your existing data. GraphQL provides a complete and understandable description of the data in your API, gives clients the power to ask for exactly what they need and nothing more, makes it easier to evolve APIs over time, and enables powerful developer tools.</p>
</blockquote>
<h2 id="微前端"><a href="#微前端" class="headerlink" title="微前端"></a>微前端</h2><p>这种架构模式涉及将前端分解为更小、更易于管理的部分，这些部分可以独立开发和部署。每个微前端都可以有自己的 BFF，这可以提高关注点分离和灵活性。</p>
<h2 id="服务网格架构"><a href="#服务网格架构" class="headerlink" title="服务网格架构"></a>服务网格架构</h2><p>在此架构中，添加了专用基础设施层来处理服务到服务的通信。这可以简化架构并降低处理服务之间通信的复杂性。</p>
<h2 id="API-成分"><a href="#API-成分" class="headerlink" title="API 成分"></a>API 成分</h2><p>这涉及将多个 API 聚合到单个 API 中，这可以简化架构并减少检索数据所需的请求数量。</p>
<h2 id="客户端到微服务的直接通信"><a href="#客户端到微服务的直接通信" class="headerlink" title="客户端到微服务的直接通信"></a>客户端到微服务的直接通信</h2><p>在此架构中，客户端直接与微服务通信，而不是通过 BFF 或 API 网关。这可以减少额外通信层带来的复杂性和延迟。然而，这也会降低灵活性和关注点分离。<br>事件驱动架构<br>这种架构涉及使用事件来触发系统中的操作，这可以提高可扩展性和模块化性。</p>
<h2 id="SOA（面向服务的架构）"><a href="#SOA（面向服务的架构）" class="headerlink" title="SOA（面向服务的架构）"></a>SOA（面向服务的架构）</h2><p>这涉及将系统分解为可以独立开发和部署的单独服务。每个服务都可以有自己的 BFF 或 API 网关。这可以提高可扩展性和灵活性。</p>
<h2 id="传统-RESTful-API"><a href="#传统-RESTful-API" class="headerlink" title="传统 RESTful API"></a>传统 RESTful API</h2><p>这是 Web API 最常见的架构，客户端通过 RESTful API 与服务器进行通信。</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://www.linkedin.com/pulse/bff-pattern-good-bad-alternatives-chandra-sharma-#:~:text=Backend%20for%20Frontend%20(BFF)%20is,of%20the%20client%2Dside%20application.">BFF Pattern: The Good, the Bad, and the Alternatives. - LinkedIn</a></p>
]]></content>
      <tags>
        <tag>BFF</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx</title>
    <url>/2024/01/16/nginx/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="1-包管理安装"><a href="#1-包管理安装" class="headerlink" title="1. 包管理安装"></a>1. 包管理安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install nginx</span><br></pre></td></tr></table></figure>

<p>or</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install nginx</span><br></pre></td></tr></table></figure>

<h2 id="2-编译安装"><a href="#2-编译安装" class="headerlink" title="2. 编译安装"></a>2. 编译安装</h2><p>下载源码，预编译，编译，安装，比较灵活，可以自定义配置一些东西，但比较麻烦</p>
<h2 id="3-使用-Docker-安装"><a href="#3-使用-Docker-安装" class="headerlink" title="3. 使用 Docker 安装"></a>3. 使用 Docker 安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure>

<h1 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h1><ol>
<li>启动命令：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></table></figure>

<blockquote>
<p>没有消息就是好消息</p>
</blockquote>
<ol start="2">
<li><p>打开浏览器输入 localhost,能打开页面看到 Welcome to nginx! ,说明启动成功</p>
</li>
<li><p><code>ps -ef|grep nginx</code>可查看 nginx 进程</p>
</li>
<li><p>nginx -s signal<br>quit : 优雅停止<br>stop: 立即停止<br>reload：重新配置文件<br>reopen：重新打开日志文件</p>
</li>
<li><p>nginx -V<br>可以查看 Nginx 的安装目录，编译参数等等</p>
</li>
<li><p>如何查看 nginx 运行的网页的位置</p>
</li>
<li><p><code>nginx -V</code></p>
</li>
<li><p>找到–prefix，例如： –prefix&#x3D;&#x2F;opt&#x2F;homebrew&#x2F;Cellar&#x2F;nginx&#x2F;1.21.6_1</p>
</li>
<li><p><code>cd /opt/homebrew/Cellar/nginx/1.21.6_1</code></p>
</li>
<li><p><code>ls -ltr </code>可以看到列表中有 html</p>
</li>
<li><p><code>cd html</code></p>
</li>
<li><p><code>ls -ltr</code></p>
</li>
<li><p><code>code index.html</code></p>
</li>
</ol>
<h1 id="搭建一个属于自己的个人博客网站"><a href="#搭建一个属于自己的个人博客网站" class="headerlink" title="搭建一个属于自己的个人博客网站"></a>搭建一个属于自己的个人博客网站</h1><ol>
<li>新建博客</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line">cd blog;npm install</span><br><span class="line">hexo server/ hexo s</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>部署到 nginx 上<br>然后将 hexo 生成的网页文件(在 public 目录下)，复制到 nginx 中</li>
</ol>
<p><code>cp -rf * /opt/homebrew/var/www</code></p>
<h1 id="nginx-配置"><a href="#nginx-配置" class="headerlink" title="nginx 配置"></a>nginx 配置</h1><h2 id="1-基本的服务器配置"><a href="#1-基本的服务器配置" class="headerlink" title="1. 基本的服务器配置"></a>1. 基本的服务器配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80; # 监听端口</span><br><span class="line">    server_name example.com www.example.com; # 域名配置</span><br><span class="line">    root /path/to/your/webroot; # 网站根目录</span><br><span class="line">    index index.html index.htm; # 默认首页</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        # 其他配置</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-反向代理配置"><a href="#2-反向代理配置" class="headerlink" title="2. 反向代理配置"></a>2. 反向代理配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name example.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://backend_server; # 后端服务器地址</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        # 其他反向代理配置</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-负载均衡配置"><a href="#3-负载均衡配置" class="headerlink" title="3. 负载均衡配置"></a>3. 负载均衡配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    server backend1.example.com;</span><br><span class="line">    server backend2.example.com;</span><br><span class="line">    # 添加更多后端服务器</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name example.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://backend;</span><br><span class="line">        # 其他负载均衡配置</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-SSL-TLS-配置"><a href="#4-SSL-TLS-配置" class="headerlink" title="4. SSL&#x2F;TLS 配置"></a>4. SSL&#x2F;TLS 配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name secure.example.com;</span><br><span class="line"></span><br><span class="line">    ssl_certificate /path/to/ssl_certificate.crt;</span><br><span class="line">    ssl_certificate_key /path/to/ssl_certificate.key;</span><br><span class="line"></span><br><span class="line">    # 其他SSL/TLS配置</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="5-重定向配置"><a href="#5-重定向配置" class="headerlink" title="5. 重定向配置"></a>5. 重定向配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name www.example.com;</span><br><span class="line">    return 301 http://example.com$request_uri; # 重定向到非www域名</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="反向代理和负载均衡"><a href="#反向代理和负载均衡" class="headerlink" title="反向代理和负载均衡"></a>反向代理和负载均衡</h1><h2 id="正向代理和反向代理"><a href="#正向代理和反向代理" class="headerlink" title="正向代理和反向代理"></a>正向代理和反向代理</h2><p>正向代理 代理客户端（client）（VPN）<br>反向代理 代理服务端（server） （比如我们通过 Google 搜索内容，我们只通过一个域名访问，但其实转发到了后面很多个不同的服务器端上，从而隐藏了真实的服务器 IP 地址、端口等信息）</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><ol>
<li>首先先用 go 生成一个简单的 web 页面，在端口 8000 监听，这里我是用 chatGPT 自动帮我生成：</li>
</ol>
<blockquote>
<p>如果没有安装 go,请先安装，我这边直接用<code>brew install go</code></p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 设置路由</span></span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		fmt.Fprintf(w, <span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动服务器并监听8000端口</span></span><br><span class="line">	port := <span class="number">8000</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;服务器正在监听端口 %d...\n&quot;</span>, port)</span><br><span class="line">	err := http.ListenAndServe(fmt.Sprintf(<span class="string">&quot;:%d&quot;</span>, port), <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;启动服务器时发生错误:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>我们将上面的文件再复制出两个文件，分别改写端口号为 8001、8002，分别运行在浏览器中。</p>
</li>
<li><p>然后我们再修改一下 nginx 的配置文件<br><code>code /opt/homebrew/etc/nginx/nginx.conf</code><br>添加<code>upstream</code>的配置，这个就是反向代理的配置</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream backend&#123;</span><br><span class="line">      server 127.0.0.1:8000;</span><br><span class="line">      server 127.0.0.1:8001;</span><br><span class="line">      server 127.0.0.1:8002;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在 下面的 server 配置中再添加一个 location 的配置，访问 app 都将代理到刚刚的配置中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location /app&#123;</span><br><span class="line">           proxy_pass http://backend;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>重新 reload 一下 nginx 配置<br><code>nginx -s reload </code></li>
</ol>
<h1 id="https-配置"><a href="#https-配置" class="headerlink" title="https 配置"></a>https 配置</h1><p>http + ssl 证书 -&gt; https<br>http 默认端口： 80<br>https 默认端口： 443<br>在主流的云平台（腾讯云，阿里云，AWS，GCP）上都可以申请免费的 ssl 证书，证书申请完后会得到证书文件(cacert.pem)和私钥文件（private.key），如果没有云平台也没有关系，我们可以通过 openssl 来自己生成一个自签名的证书</p>
<h2 id="openssl-生成证书"><a href="#openssl-生成证书" class="headerlink" title="openssl 生成证书"></a>openssl 生成证书</h2><ol>
<li>生成私钥文件（private key）<br><code>openssl genrsa -out private.key 2048</code></li>
<li>根据私钥生成证书签名请求文件<br><code>openssl req -new -key private.key -out cert.csr</code></li>
<li>使用私钥对证书申请进行签名从而生成证书（pem 文件）<br><code>openssl x509 -req -in cert.csr -out cacert.pem -signkey private.key</code></li>
</ol>
<h2 id="nginx-配置-1"><a href="#nginx-配置-1" class="headerlink" title="nginx 配置"></a>nginx 配置</h2><p>这两个文件需要放置到服务器上<code>证书文件(cacert.pem)和私钥文件（private.key）</code>,然后在 nginx 的配置文件中进行配置</p>
<ol>
<li>在监听后加上 ssl<br><code> listen    443 ssl;</code></li>
<li>将证书和私钥填写进入</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssl_certificate    /opt/homebrew/etc/nginx/cacert.pem</span><br><span class="line">ssl_certificate_key    /opt/homebrew/etc/nginx/private.key</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>然后再加上一些验证配置和加密协议，这些配置基本是固定的</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name your_domain.com;</span><br><span class="line"></span><br><span class="line">    ssl_certificate /etc/nginx/ssl/your_domain.crt;</span><br><span class="line">    ssl_certificate_key /etc/nginx/ssl/your_domain.key;</span><br><span class="line"></span><br><span class="line">    # 可选：配置 SSL 优化和安全性</span><br><span class="line">    ssl_protocols TLSv1.2 TLSv1.3;</span><br><span class="line">    ssl_prefer_server_ciphers off;</span><br><span class="line">    ssl_ciphers &#x27;TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384&#x27;;</span><br><span class="line"></span><br><span class="line">    # 其他 SSL 配置...</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        # 配置其他相关的代理或静态文件服务...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们的证书是自签名的，没有经过 ca 认证，所以打开网站会提示不安全</p>
</blockquote>
<h3 id="配置-http-重定向到-https"><a href="#配置-http-重定向到-https" class="headerlink" title="配置 http 重定向到 https"></a>配置 http 重定向到 https</h3><p>server {<br>listen 80;<br>server_name your_domain.com <a href="http://www.your_domain.com/">www.your_domain.com</a>;</p>
<pre><code># 重定向到 HTTPS
return 301 https://$host$request_uri;
</code></pre>
<p>}</p>
<h1 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h1><p>虚拟主机可以在一个服务器上部署多个站点</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>nginx 中通过<code>server</code>块来配置虚拟主机，每个<code>server</code>块就是一个虚拟主机</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80; # 监听端口</span><br><span class="line"></span><br><span class="line">    server_name your_domain.com www.your_domain.com; # 替换为你的域名</span><br><span class="line"></span><br><span class="line">    root /path/to/your/webroot; # 替换为你的网站根目录</span><br><span class="line"></span><br><span class="line">    index index.html index.htm; # 默认首页</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        # 配置其他参数，比如代理、缓存等</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 配置其他特定的location块，如果需要的话</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="如何将一个-vue-项目部署到服务器上"><a href="#如何将一个-vue-项目部署到服务器上" class="headerlink" title="如何将一个 vue 项目部署到服务器上"></a>如何将一个 vue 项目部署到服务器上</h2><ol>
<li><p>创建一个 vue 项目，并打包好</p>
</li>
<li><p>open nginx 配置项目</p>
</li>
</ol>
<ul>
<li><code>cd /opt/homebrew/etc/nginx</code></li>
<li><code>code .</code></li>
<li>新建一个 servers 文件夹，在 servers 里建<code>vue.conf</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    listen 5173;</span><br><span class="line">    server_name localhost;//替换成域名</span><br><span class="line">    location / &#123;</span><br><span class="line">        root /Users/mei/vue-demo/dist;//打包项目地址</span><br><span class="line">        index index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>nginx -s reload</code><br>在浏览器中输入 localhost:5173 就可以看到 vue 项目。</li>
</ul>
]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
</search>
