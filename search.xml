<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JSBridge</title>
    <url>/2020/07/21/JSBridge/</url>
    <content><![CDATA[<p>随着移动端盛行，不管是混合开发（Hybrid）应用，还是 React-Native 都离不开 JSBridge，当然也包括在国内举足轻重的微信小程序。</p>
<span id="more"></span>

<h1 id="JSBridge-的作用"><a href="#JSBridge-的作用" class="headerlink" title="JSBridge 的作用"></a>JSBridge 的作用</h1><p>通过 JSBridge 可以实现 H5 和 原生之间的<strong>双向</strong>通信，主要是给 H5 提供调用 原生（Native）功能的接口，让混合开发中的 H5 可以方便地使用地址位置、摄像头甚至支付等原生功能。</p>
<img src="/2020/07/21/JSBridge/jsbridge.png" class title="jsbridge">

<h1 id="JSBridge-的通信原理"><a href="#JSBridge-的通信原理" class="headerlink" title="JSBridge 的通信原理"></a>JSBridge 的通信原理</h1><p>主要有两种：注入 API 和 拦截 URL SCHEME。</p>
<h2 id="注入-API"><a href="#注入-API" class="headerlink" title="注入 API"></a>注入 API</h2><p>注入 API 方式是最常用的方式，主要原理是通过 <code>WebView</code> 提供的接口，向 JavaScript 的 Context（window）中注入对象或者方法，让 JavaScript 调用时，直接执行相应的 Native 代码逻辑，达到 JavaScript 调用 Native 的目的。</p>
<h3 id="注入-API-时，H5-端的代码"><a href="#注入-API-时，H5-端的代码" class="headerlink" title="注入 API 时，H5 端的代码"></a>注入 API 时，H5 端的代码</h3><h4 id="1）初始化-WebViewJavascriptBridge"><a href="#1）初始化-WebViewJavascriptBridge" class="headerlink" title="1）初始化 WebViewJavascriptBridge"></a>1）初始化 WebViewJavascriptBridge</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据navigator.userAgent来判断当前是 Android 还是 ios</span></span><br><span class="line"><span class="keyword">const</span> u = navigator.<span class="property">userAgent</span>;</span><br><span class="line"><span class="comment">// Android终端</span></span><br><span class="line"><span class="keyword">const</span> isAndroid = u.<span class="title function_">indexOf</span>(<span class="string">&quot;Android&quot;</span>) &gt; -<span class="number">1</span> || u.<span class="title function_">indexOf</span>(<span class="string">&quot;Adr&quot;</span>) &gt; -<span class="number">1</span>;</span><br><span class="line"><span class="comment">// IOS 终端</span></span><br><span class="line"><span class="keyword">const</span> isIOS = !!u.<span class="title function_">match</span>(<span class="regexp">/\(i[^;]+;( U;)? CPU.+Mac OS X/</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配合 IOS 使用时的初始化方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">iosFunction</span> = (<span class="params">callback</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">WebViewJavascriptBridge</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">callback</span>(<span class="variable language_">window</span>.<span class="property">WebViewJavascriptBridge</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">WVJBCallbacks</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">window</span>.<span class="property">WVJBCallbacks</span>.<span class="title function_">push</span>(callback);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">WVJBCallbacks</span> = [callback];</span><br><span class="line">  <span class="keyword">var</span> <span class="title class_">WVJBIframe</span> = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;iframe&quot;</span>);</span><br><span class="line">  <span class="title class_">WVJBIframe</span>.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;none&quot;</span>;</span><br><span class="line">  <span class="title class_">WVJBIframe</span>.<span class="property">src</span> = <span class="string">&quot;demo://__BRIDGE_LOADED__&quot;</span>;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="title function_">appendChild</span>(<span class="title class_">WVJBIframe</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="title function_">removeChild</span>(<span class="title class_">WVJBIframe</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配合 Android 使用时的初始化方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">androidFunction</span> = (<span class="params">callback</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">WebViewJavascriptBridge</span>) &#123;</span><br><span class="line">    <span class="title function_">callback</span>(<span class="variable language_">window</span>.<span class="property">WebViewJavascriptBridge</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(</span><br><span class="line">      <span class="string">&quot;WebViewJavascriptBridgeReady&quot;</span>,</span><br><span class="line">      <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">callback</span>(<span class="variable language_">window</span>.<span class="property">WebViewJavascriptBridge</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="literal">false</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">setupWebViewJavascriptBridge</span> = isAndroid ? androidFunction : iosFunction;</span><br><span class="line"></span><br><span class="line">isAndroid &amp;&amp;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">setupWebViewJavascriptBridge</span>(<span class="keyword">function</span> (<span class="params">bridge</span>) &#123;</span><br><span class="line">    <span class="comment">// 注册 H5 界面的默认接收函数</span></span><br><span class="line">    bridge.<span class="title function_">init</span>(<span class="keyword">function</span> (<span class="params">msg, responseCallback</span>) &#123;</span><br><span class="line">      <span class="title function_">responseCallback</span>(<span class="string">&quot;JS 返回给原生的消息内容&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h4 id="2）注册与原生交互的事件函数"><a href="#2）注册与原生交互的事件函数" class="headerlink" title="2）注册与原生交互的事件函数"></a>2）注册与原生交互的事件函数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bridge.registerHandler(&#x27;事件函数名&#x27;,fun 执行函数);</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">setupWebViewJavascriptBridge</span>(<span class="function">(<span class="params">bridge</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// data：原生传过来的数据;</span></span><br><span class="line">  <span class="comment">// callback: 原生传过来的回调函数</span></span><br><span class="line">  bridge.<span class="title function_">registerHandler</span>(<span class="string">&quot;H5Function&quot;</span>, <span class="function">(<span class="params">data, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    callback &amp;&amp; <span class="title function_">callback</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="3）调用原生注册的事件函数"><a href="#3）调用原生注册的事件函数" class="headerlink" title="3）调用原生注册的事件函数"></a>3）调用原生注册的事件函数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bridge.callHandler(&#x27;安卓端函数名&#x27;, &quot;传给原生端的数据&quot;, callback 回调函数);</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">setupWebViewJavascriptBridge</span>(<span class="function">(<span class="params">bridge</span>) =&gt;</span> &#123;</span><br><span class="line">  bridge.<span class="title function_">callHandler</span>(<span class="string">&quot;changeData&quot;</span>, data, <span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="拦截-URL-SCHEME"><a href="#拦截-URL-SCHEME" class="headerlink" title="拦截 URL SCHEME"></a>拦截 URL SCHEME</h2><p>先解释一下 URL SCHEME：URL SCHEME 是一种类似于 url 的链接，是为了方便 app 直接互相调用设计的，形式和普通的 url 近似，主要区别是 <code>protocol</code> 和 <code>host</code> 一般是自定义的</p>
<p>例如打开微信扫码的 SCHEME：weixin:&#x2F;&#x2F;scanqrcode<br>protocol 是 weixin，host 则是 scanqrcode</p>
<h3 id="拦截-URL-SCHEME-的主要流程"><a href="#拦截-URL-SCHEME-的主要流程" class="headerlink" title="拦截 URL SCHEME 的主要流程"></a>拦截 URL SCHEME 的主要流程</h3><p>Web 端通过某种方式（例如 <code>iframe.src</code>）发送 URL Scheme 请求，之后 Native 拦截到请求，并根据 URL SCHEME（包括所带的参数）进行相关操作（类似<code>JSONP</code>的方式）</p>
<h3 id="URL-SCHEME-的缺陷"><a href="#URL-SCHEME-的缺陷" class="headerlink" title="URL SCHEME 的缺陷"></a>URL SCHEME 的缺陷</h3><p>1）使用 <code>iframe.src</code> 发送 URL SCHEME 会有 url 长度的隐患<br>2）创建请求，需要一定的耗时，比注入 API 的方式调用同样的功能，耗时会较长</p>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS 数组方法</title>
    <url>/2019/11/10/array-function/</url>
    <content><![CDATA[<h1 id="改变原数组的方法-9-个"><a href="#改变原数组的方法-9-个" class="headerlink" title="改变原数组的方法(9 个)"></a>改变原数组的方法(9 个)</h1><h2 id="1-splice-添加-删除数组元素"><a href="#1-splice-添加-删除数组元素" class="headerlink" title="1.splice() 添加 &#x2F; 删除数组元素"></a>1.splice() 添加 &#x2F; 删除数组元素</h2><p>splice() 方法向&#x2F;从数组中添加&#x2F;删除项目，然后返回被删除的项目</p>
<p><code>array.splice(index,howmany,item1,.....,itemX)</code></p>
<span id="more"></span>

<blockquote>
<p>index：必需。整数，规定添加&#x2F;删除项目的位置，使用负数可从数组结尾处规定位置。<br>howmany：可选。要删除的项目数量。如果设置为 0，则不会删除项目。<br>item1, …, itemX： 可选。向数组添加的新项目。<br>返回值: 如果有元素被删除,返回包含被删除项目的新数组。</p>
</blockquote>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从数组下标0开始，删除3个元素</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.<span class="title function_">splice</span>(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// [1,2,3]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// [4,5,6,7]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从最后一个元素开始删除3个元素，因为最后一个元素，所以只删除了7</span></span><br><span class="line"><span class="keyword">let</span> item = a.<span class="title function_">splice</span>(-<span class="number">1</span>, <span class="number">3</span>); <span class="comment">// [7]</span></span><br></pre></td></tr></table></figure>

<h3 id="删除并添加"><a href="#删除并添加" class="headerlink" title="删除并添加"></a>删除并添加</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从数组下标0开始，删除3个元素，并添加元素&#x27;添加&#x27;</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.<span class="title function_">splice</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="string">&quot;添加&quot;</span>); <span class="comment">// [1,2,3]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// [&#x27;添加&#x27;,4,5,6,7]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从数组最后第二个元素开始，删除3个元素，并添加两个元素&#x27;添加1&#x27;、&#x27;添加2&#x27;</span></span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> item = b.<span class="title function_">splice</span>(-<span class="number">2</span>, <span class="number">3</span>, <span class="string">&quot;添加1&quot;</span>, <span class="string">&quot;添加2&quot;</span>); <span class="comment">// [6,7]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// [1,2,3,4,5,&#x27;添加1&#x27;,&#x27;添加2&#x27;]</span></span><br></pre></td></tr></table></figure>

<h3 id="不删除只添加"><a href="#不删除只添加" class="headerlink" title="不删除只添加"></a>不删除只添加</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.<span class="title function_">splice</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;添加1&quot;</span>, <span class="string">&quot;添加2&quot;</span>); <span class="comment">// [] 没有删除元素，返回空数组</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// [&#x27;添加1&#x27;,&#x27;添加2&#x27;,1,2,3,4,5,6,7]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> item = b.<span class="title function_">splice</span>(-<span class="number">1</span>, <span class="number">0</span>, <span class="string">&quot;添加1&quot;</span>, <span class="string">&quot;添加2&quot;</span>); <span class="comment">// [] 没有删除元素，返回空数组</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// [1,2,3,4,5,6,&#x27;添加1&#x27;,&#x27;添加2&#x27;,7] 在最后一个元素的前面添加两个元素</span></span><br></pre></td></tr></table></figure>

<h2 id="2-sort-数组排序"><a href="#2-sort-数组排序" class="headerlink" title="2.sort() 数组排序"></a>2.sort() 数组排序</h2><p>sort() 方法对数组元素进行排序，并返回这个数组。</p>
<blockquote>
<p>参数可选: 规定排序顺序的比较函数。<br>默认情况下 sort() 方法没有传比较函数的话，默认按字母升序，如果不是元素不是字符串的话，会调用 <code>toString()</code> 方法将元素转化为字符串的 <code>Unicode</code> (万国码)位点，然后再比较字符。</p>
</blockquote>
<h3 id="不传参"><a href="#不传参" class="headerlink" title="不传参"></a>不传参</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串排列 看起来很正常</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Mango&quot;</span>];</span><br><span class="line">a.<span class="title function_">sort</span>(); <span class="comment">// [&quot;Apple&quot;,&quot;Banana&quot;,&quot;Mango&quot;,&quot;Orange&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数字排序的时候 因为转换成Unicode字符串之后，有些数字会比较大会排在后面 这显然不是我们想要的</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">8</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">sort</span>()); <span class="comment">// [1,10,20,25,3,8];</span></span><br></pre></td></tr></table></figure>

<h3 id="比较函数的两个参数："><a href="#比较函数的两个参数：" class="headerlink" title="比较函数的两个参数："></a>比较函数的两个参数：</h3><p>sort 的比较函数有两个默认参数，要在函数中接收这两个参数，这两个参数是数组中两个要比较的元素，通常我们用 a 和 b 接收两个将要比较的元素：</p>
<ul>
<li>若比较函数返回值 &lt;0 ，那么 a 将排到 b 的前面;</li>
<li>若比较函数返回值 &#x3D;0 ，那么 a 和 b 相对位置不变；</li>
<li>若比较函数返回值 &gt;0 ，那么 b 排在 a 将的前面；</li>
</ul>
<h3 id="数字升降序"><a href="#数字升降序" class="headerlink" title="数字升降序"></a>数字升降序</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">20</span>, <span class="number">4</span>, <span class="number">25</span>, <span class="number">8</span>];</span><br><span class="line">array.<span class="title function_">sort</span>(<span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array); <span class="comment">// [1,3,4,4,8,10,20,25];</span></span><br><span class="line"></span><br><span class="line">array.<span class="title function_">sort</span>(<span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> b - a;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array); <span class="comment">// [25,20,10,8,4,4,3,1];</span></span><br></pre></td></tr></table></figure>

<p>pop() 删除一个数组中的最后的一个元素<br>定义: pop() 方法删除一个数组中的最后的一个元素，并且返回这个元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.<span class="title function_">pop</span>(); <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// [1,2]</span></span><br></pre></td></tr></table></figure>

<h2 id="shift-删除数组的第一个元素"><a href="#shift-删除数组的第一个元素" class="headerlink" title="shift() 删除数组的第一个元素"></a>shift() 删除数组的第一个元素</h2><p>定义: shift()方法删除数组的第一个元素，并返回这个元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.<span class="title function_">shift</span>(); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// [2,3]</span></span><br></pre></td></tr></table></figure>

<h2 id="push-向数组的末尾添加元素"><a href="#push-向数组的末尾添加元素" class="headerlink" title="push() 向数组的末尾添加元素"></a>push() 向数组的末尾添加元素</h2><p>定义：push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。</p>
<p>参数: item1, item2, …, itemX ,要添加到数组末尾的元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.<span class="title function_">push</span>(<span class="string">&quot;末尾&quot;</span>, <span class="string">&quot;233&quot;</span>); <span class="comment">// 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// [1,2,3,&#x27;末尾&#x27;, &#x27;233&#x27;]</span></span><br></pre></td></tr></table></figure>

<h2 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h2><p>定义：unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。</p>
<p>参数: item1, item2, …, itemX ,要添加到数组开头的元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.<span class="title function_">unshift</span>(<span class="string">&quot;开头&quot;</span>, <span class="string">&quot;开头 2&quot;</span>); <span class="comment">// 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// [ &#x27;开头&#x27;, &#x27;开头 2&#x27;, 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure>

<h2 id="reverse-颠倒数组中元素的顺序"><a href="#reverse-颠倒数组中元素的顺序" class="headerlink" title="reverse() 颠倒数组中元素的顺序"></a>reverse() 颠倒数组中元素的顺序</h2><p>定义: reverse() 方法用于颠倒数组中元素的顺序。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a.<span class="title function_">reverse</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// [3,2,1]</span></span><br></pre></td></tr></table></figure>

<h1 id="不改变原数组的方法（8-个）"><a href="#不改变原数组的方法（8-个）" class="headerlink" title="不改变原数组的方法（8 个）"></a>不改变原数组的方法（8 个）</h1><h2 id="slice-浅拷贝数组的元素"><a href="#slice-浅拷贝数组的元素" class="headerlink" title="slice() 浅拷贝数组的元素"></a>slice() 浅拷贝数组的元素</h2><p>定义： 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象，且原数组不会被修改。</p>
<p>语法：<code>array.slice(begin, end);</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> b = a.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">1</span>); <span class="comment">// [&#x27;hello&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新数组是浅拷贝的，元素是简单数据类型，改变之后不会互相干扰。</span></span><br><span class="line"><span class="comment">// 如果是复杂数据类型(对象,数组)的话，改变其中一个，另外一个也会改变。</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="string">&quot;改变原数组&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b); <span class="comment">// [&#x27;改变原数组&#x27;,&#x27;world&#x27;] [&#x27;hello&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [&#123; <span class="attr">name</span>: <span class="string">&quot;OBKoro1&quot;</span> &#125;];</span><br><span class="line"><span class="keyword">let</span> b = a.<span class="title function_">slice</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b, a); <span class="comment">// [&#123;&quot;name&quot;:&quot;OBKoro1&quot;&#125;] [&#123;&quot;name&quot;:&quot;OBKoro1&quot;&#125;]</span></span><br><span class="line"><span class="comment">// a[0].name=&#x27;改变原数组&#x27;</span></span><br><span class="line"><span class="comment">// console.log(b,a) // [&#123;&quot;name&quot;:&quot;改变原数组&quot;&#125;] [&#123;&quot;name&quot;:&quot;改变原数组&quot;&#125;]</span></span><br></pre></td></tr></table></figure>

<h2 id="join-数组转字符串"><a href="#join-数组转字符串" class="headerlink" title="join() 数组转字符串"></a>join() 数组转字符串</h2><p>定义: join() 方法用于把数组中的所有元素通过指定的分隔符进行分隔放入一个字符串，返回生成的字符串。</p>
<p>语法: <code>array.join(str)</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> str = a.<span class="title function_">join</span>(); <span class="comment">// &#x27;hello,world&#x27;</span></span><br><span class="line"><span class="keyword">let</span> str2 = a.<span class="title function_">join</span>(<span class="string">&quot;+&quot;</span>); <span class="comment">// &#x27;hello+world&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [[<span class="string">&quot;OBKoro1&quot;</span>, <span class="string">&quot;23&quot;</span>], <span class="string">&quot;test&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> str1 = a.<span class="title function_">join</span>(); <span class="comment">// OBKoro1,23,test</span></span><br><span class="line"><span class="keyword">let</span> b = [&#123; <span class="attr">name</span>: <span class="string">&quot;OBKoro1&quot;</span>, <span class="attr">age</span>: <span class="string">&quot;23&quot;</span> &#125;, <span class="string">&quot;test&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> str2 = b.<span class="title function_">join</span>(); <span class="comment">// [object Object],test</span></span><br><span class="line"><span class="comment">// 对象转字符串推荐 JSON.stringify(obj)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结论：</span></span><br><span class="line"><span class="comment">// join()/toString() 方法在数组元素是数组的时候，会将里面的数组也调用 join()/toString() ,</span></span><br><span class="line"><span class="comment">// 如果是对象的话，对象会被转为 [object Object] 字符串。</span></span><br></pre></td></tr></table></figure>

<h2 id="toLocaleString-数组转字符串"><a href="#toLocaleString-数组转字符串" class="headerlink" title="toLocaleString() 数组转字符串"></a>toLocaleString() 数组转字符串</h2><p>定义: 返回一个表示数组元素的字符串。该字符串由数组中的每个元素的 <code>toLocaleString()</code> 返回值经调用 <code>join()</code> 方法连接（由逗号隔开）组成。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [&#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&#x27;OBKoro1&#x27;</span></span><br><span class="line">&#125;, <span class="number">23</span>, <span class="string">&#x27;abcd&#x27;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()]</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">join</span>(<span class="string">&quot;,&quot;</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">toString</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">toLocaleString</span>(<span class="string">&#x27;en-us&#x27;</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">toLocaleString</span>(<span class="string">&#x27;zh-cn&#x27;</span>))</span><br><span class="line"></span><br><span class="line">[object <span class="title class_">Object</span>],<span class="number">23</span>,abcd,<span class="title class_">Tue</span> <span class="title class_">Feb</span> <span class="number">26</span> <span class="number">2019</span> <span class="number">11</span>:<span class="number">47</span>:<span class="number">03</span> <span class="variable constant_">GMT</span>+<span class="number">0800</span> (中国标准时间)</span><br><span class="line">[object <span class="title class_">Object</span>],<span class="number">23</span>,abcd,<span class="title class_">Tue</span> <span class="title class_">Feb</span> <span class="number">26</span> <span class="number">2019</span> <span class="number">11</span>:<span class="number">47</span>:<span class="number">03</span> <span class="variable constant_">GMT</span>+<span class="number">0800</span> (中国标准时间)</span><br><span class="line">[object <span class="title class_">Object</span>],<span class="number">23</span>,abcd,<span class="number">2</span>/<span class="number">26</span>/<span class="number">2019</span>, <span class="number">11</span>:<span class="number">47</span>:<span class="number">03</span> <span class="variable constant_">AM</span></span><br><span class="line">[object <span class="title class_">Object</span>],<span class="number">23</span>,abcd,<span class="number">2019</span>/<span class="number">2</span>/<span class="number">26</span> 上午 <span class="number">11</span>:<span class="number">47</span>:<span class="number">03</span></span><br></pre></td></tr></table></figure>

<h2 id="concat-合并数组"><a href="#concat-合并数组" class="headerlink" title="concat 合并数组"></a>concat 合并数组</h2><p>定义： 方法用于合并两个或多个数组，返回一个新数组。</p>
<p>语法：<code>var newArr =oldArray.concat(arrayX,arrayX,......,arrayX)</code></p>
<p>参数：arrayX（必须）：该参数可以是具体的值，也可以是数组对象。可以是任意多个。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="comment">//连接两个数组</span></span><br><span class="line"><span class="keyword">let</span> newVal = a.<span class="title function_">concat</span>(b); <span class="comment">// [1,2,3,4,5,6]</span></span><br><span class="line"><span class="comment">// 连接三个数组</span></span><br><span class="line"><span class="keyword">let</span> c = [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">let</span> newVal2 = a.<span class="title function_">concat</span>(b, c); <span class="comment">// [1,2,3,4,5,6,7,8,9]</span></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line"><span class="keyword">let</span> newVal3 = a.<span class="title function_">concat</span>(<span class="string">&quot;添加元素&quot;</span>, b, c, <span class="string">&quot;再加一个&quot;</span>);</span><br><span class="line"><span class="comment">// [1,2,3,&quot;添加元素&quot;,4,5,6,7,8,9,&quot;再加一个&quot;]</span></span><br><span class="line"><span class="comment">// 合并嵌套数组 会浅拷贝嵌套数组</span></span><br><span class="line"><span class="keyword">let</span> d = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> f = [<span class="number">3</span>, [<span class="number">4</span>]];</span><br><span class="line"><span class="keyword">let</span> newVal4 = d.<span class="title function_">concat</span>(f); <span class="comment">// [1,2,3,[4]]</span></span><br></pre></td></tr></table></figure>

<h2 id="ES6-扩展运算符-…-合并数组"><a href="#ES6-扩展运算符-…-合并数组" class="headerlink" title="ES6 扩展运算符 … 合并数组"></a>ES6 扩展运算符 … 合并数组</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">4</span>, ...a, <span class="number">4</span>, <span class="number">4</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b); <span class="comment">//  [2, 3, 4, 5] [4,2,3,4,5,4,4]</span></span><br></pre></td></tr></table></figure>

<h2 id="indexOf-查找数组是否存在某个元素，返回下标"><a href="#indexOf-查找数组是否存在某个元素，返回下标" class="headerlink" title="indexOf() 查找数组是否存在某个元素，返回下标"></a>indexOf() 查找数组是否存在某个元素，返回下标</h2><p>定义: 返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。</p>
<p>p.s. 字符串也有此方法，要注意当 ‘lance’.indexOf(‘’) 一个空字符串时，返回 0 而不是-1</p>
<p>语法：<code>array.indexOf(searchElement,fromIndex)</code></p>
<p>参数：</p>
<blockquote>
<p>searchElement (必须):被查找的元素<br>fromIndex (可选):开始查找的位置(不能大于等于数组的长度，返回-1)，接受负值，默认值为 0。</p>
</blockquote>
<h3 id="严格相等的搜索"><a href="#严格相等的搜索" class="headerlink" title="严格相等的搜索:"></a>严格相等的搜索:</h3><p>数组的 indexOf 搜索跟字符串的 indexOf 不一样,数组的 indexOf 使用严格相等&#x3D;&#x3D;&#x3D;搜索元素，即数组元素要完全匹配才能搜索成功。</p>
<blockquote>
<p>注意：indexOf() 不能识别 NaN</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">&quot;啦啦&quot;</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">24</span>, <span class="title class_">NaN</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">indexOf</span>(<span class="string">&quot;啦&quot;</span>)); <span class="comment">// -1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">indexOf</span>(<span class="string">&quot;NaN&quot;</span>)); <span class="comment">// -1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">indexOf</span>(<span class="string">&quot;啦啦&quot;</span>)); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h2 id="lastIndexOf-查找指定元素在数组中的最后一个位置"><a href="#lastIndexOf-查找指定元素在数组中的最后一个位置" class="headerlink" title="lastIndexOf() 查找指定元素在数组中的最后一个位置"></a>lastIndexOf() 查找指定元素在数组中的最后一个位置</h2><p>定义: 方法返回指定元素,在数组中的最后一个的索引，如果不存在则返回 -1。（从数组后面往前查找）</p>
<p>语法：<code>arr.lastIndexOf(searchElement,fromIndex)</code></p>
<p>参数:</p>
<blockquote>
<p>searchElement(必须): 被查找的元素<br>fromIndex(可选): 逆向查找开始位置，默认值数组的 长度-1，即查找整个数组。</p>
</blockquote>
<p>关于 fromIndex 有三个规则:</p>
<ul>
<li>正值。如果该值大于或等于数组的长度，则整个数组会被查找。</li>
<li>负值。将其视为从数组末尾向前的偏移。(比如-2，从数组最后第二个元素开始往前查找)</li>
<li>负值。其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">&quot;OB&quot;</span>, <span class="number">4</span>, <span class="string">&quot;Koro1&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;Koro1&quot;</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="string">&quot;Koro1&quot;</span>]; <span class="comment">// 数组长度为 10</span></span><br><span class="line"><span class="comment">// let b=a.lastIndexOf(&#x27;Koro1&#x27;,4) // 从下标 4 开始往前找 返回下标 2</span></span><br><span class="line"><span class="comment">// let b=a.lastIndexOf(&#x27;Koro1&#x27;,100) // 大于或数组的长度 查找整个数组 返回 9</span></span><br><span class="line"><span class="comment">// let b=a.lastIndexOf(&#x27;Koro1&#x27;,-11) // -1 数组不会被查找</span></span><br><span class="line"><span class="keyword">let</span> b = a.<span class="title function_">lastIndexOf</span>(<span class="string">&quot;Koro1&quot;</span>, -<span class="number">9</span>); <span class="comment">// 从第二个元素 4 往前查找，没有找到 返回-1</span></span><br></pre></td></tr></table></figure>

<h2 id="ES7-includes-查找数组是否包含某个元素-返回布尔"><a href="#ES7-includes-查找数组是否包含某个元素-返回布尔" class="headerlink" title="ES7 includes() 查找数组是否包含某个元素 返回布尔"></a>ES7 includes() 查找数组是否包含某个元素 返回布尔</h2><p>定义： 返回一个布尔值，表示某个数组是否包含给定的值</p>
<p>语法：<code>array.includes(searchElement,fromIndex=0)</code></p>
<p>参数：</p>
<blockquote>
<p>searchElement (必须):被查找的元素<br>fromIndex (可选):默认值为 0 ，参数表示搜索的起始位置，接受负值。正值超过数组长度，数组不会被搜索，返回 false 。负值绝对值超过长数组度，重置从 0 开始搜索。</p>
</blockquote>
<ul>
<li>includes 方法是为了弥补 indexOf 方法的缺陷而出现的:</li>
<li>indexOf 方法不能识别 NaN</li>
<li>indexOf 方法检查是否包含某个值不够语义化，需要判断是否不等于 -1 ，表达不够直观</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">&quot;OB&quot;</span>, <span class="string">&quot;Koro1&quot;</span>, <span class="number">1</span>, <span class="title class_">NaN</span>];</span><br><span class="line"><span class="comment">// let b=a.includes(NaN) // true 识别NaN</span></span><br><span class="line"><span class="comment">// let b=a.includes(&#x27;Koro1&#x27;,100) // false 超过数组长度 不搜索</span></span><br><span class="line"><span class="comment">// let b=a.includes(&#x27;Koro1&#x27;,-3)  // true 从倒数第三个元素开始搜索</span></span><br><span class="line"><span class="comment">// let b=a.includes(&#x27;Koro1&#x27;,-100)  // true 负值绝对值超过数组长度，搜索整个数组</span></span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://juejin.im/post/5b0903b26fb9a07a9d70c7e0">js 数组详细操作方法及解析合集</a></p>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>自动化测试</title>
    <url>/2023/01/15/auto-testing/</url>
    <content><![CDATA[<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>为了更好的实施自动化测试，我们希望有一套简单但足够的自动化测试体系，能够从各个层面帮助我们开展自动化测试，从而交付高质量的软件代码。</p>
<p>本文包含三个部分，包括「测试流程」、「测试平台和工具」和「测试方法论」，各自关注不同的维度，整体形成一个良好的体系。</p>
<span id="more"></span>

<h1 id="测试流程"><a href="#测试流程" class="headerlink" title="测试流程"></a>测试流程</h1><p>测试流程关注测试开发的过程中，应该以怎样的流程来实施，以便测试的最佳效果。</p>
<h2 id="用例设计"><a href="#用例设计" class="headerlink" title="用例设计"></a>用例设计</h2><p>测试用例的设计需要考虑多个层面，尽量全方位的考虑所有场景，包括但不限于如下层面：</p>
<ol>
<li>用户故事，特定功能需要满足的用户场景</li>
<li>权限需求，不同权限可能的差异</li>
<li>异常场景，一些异常可能出现的问题，如何恢复</li>
<li>兼容性，对环境、设备、浏览器的要求</li>
<li>性能层面，数据量是否很大，是否有极致的性能需求<br>这上面的东西，是测试用例设计的需求，在需求明确之后，就可以针对它们设计具体的测试用例。</li>
</ol>
<p>好的测试用例是一个完备的集合，覆盖所有等价类与关键值，设计好的测试用例有三种常用的方式：</p>
<ol>
<li>等价类划</li>
<li>边界值</li>
<li>错误推测</li>
</ol>
<h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><p>测试用例的设计可以分为以下几个步骤：</p>
<ol>
<li>画一个较粗的业务流程图，包含所有的流程分支，图内每个节点可以较粗，比如“短信验证码登录”就是一个节点，先不用细分手机号是否已注册，或者对应的用户是什么身份。</li>
<li>我们把流程图中最长的主流程称为基本流 1，其他分支也依次标号，然后就可以组合出该流程图中所有可能的子流程，比如 1 + 2 + 4。<br>○ 当流程图比较复杂导致组合情况过多时，可以寻找解耦点將它拆分为两个甚至多个彼此之间耦合度较低的流程图，也就是说一个流程以哪一条路径执行基本不影响另一个流程的正确性。然后对拆分后的流程图罗列组合。<br>○ 我们可以进一步降低流程图的复杂度，不把“表单验证失败”的节点写在流程图中，每个表单的验证可以做成单独的测试用例。比如“短信验证码登录”的失败原因分为手机号格式不对、验证码错误、验证码过期等等，这些可以单独汇总在一个测试用例中去测试。</li>
<li>～～对上述的组合结果进行精简，依然从耦合度的角度去考虑。假设我们的组合中有 1 + 2、1 + 3 和 1 + 2 + 3，而分支 3 的执行与否对分支 2 的正确性几无影响，那么在已测试 1 + 2 和 1 + 3 的基础上，1 + 2 + 3 的性价比非常低，对测试效果的提升很小，可以被精简掉。这个比较依赖设计者的经验去判断哪些是“无意义”的组合。～～<br>○ 这一条先注释掉，不太好解释和实施，需要在实践中再打磨。</li>
<li>为精简后的每一个组合编写一个测试用例。对于用例中的每一个节点步骤，此时要考虑它的细分场景。比如“短信验证码登录”，需要先按业务场景拆分为学生登录、老师登录、家长登录、未注册手机号登录 4 种可能性。<br>○ 原则上每一种可能性都应当是一个单独的测试用例，但为了不重复编写差别很小的用例，我们可以在一个用例中描述一个节点的多个输入值。在实际执行用例时，可以选择在一个节点上测试多个输入值再继续往下也可以每个输入值都跑一遍用例中的流程，这个也需要执行者依靠经验来灵活判断。<br>○ 我们需要同时在测试用例管理工具中保存业务流程图，为执行者理解测试用例和设计者将来随着业务变化更新测试用例提供方便。<br>○ 设计测试用例是一个再次检查产品逻辑严密性的好时机，遇到问题需要及时与产品经理沟通。<br>○ 很多用例，尤其是表单验证类的，需要用等价类划分和边界值的方法去设计多种输入值。</li>
<li>然后设计者需要基于对业务的了解补充针对不在正常业务逻辑中的异常场景、安全性敏感场景、性能敏感场景的测试用例，就得到了完整的冒烟测试和黑盒测试集。<br>○ 有些“副作用”式的功能可以考虑集中在一个测试用例中描述，比如任务的推送，可以写一个测试用例集中测试，包括任务的创建、修改、驳回等各种情况的推送。</li>
<li>最后我们需要根据黑盒测试集做 E2E UI 自动化测试，考虑到编写效率和运行效率，思路是一长多短：<br>a. 在一个模块的用例中取一个最长的基本流先实现。<br>b. 实现其他未被覆盖的短分支。</li>
</ol>
<h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>这是一个 App 用手机号登录后选择身份进入主页的流程图，按照上文我们提供的方法：<br><img src="/images/test.png" alt="test"></p>
<ol>
<li>这个流程原本属于一个更长的流程，前面是手机号登录的流程，两部分加起来是一个完整的 App 登录流程，但是我们认为这个子流程之间的耦合度不高，所以选择了在中间解耦，变成两个流程分别测试。</li>
<li>在编写黑盒测试用例时，我们得到的组合集是：<br>a. 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5<br>b. 1 -&gt; 4 -&gt; 5<br>c. 1 -&gt; 4 -&gt; 3 -&gt; 4 -&gt; 5<br>外加一个绑定新身份时的表单验证。</li>
<li>在编写 E2E UI 自动化测试时，我们先实现最长基本流，然后实现剩下的短分支，所以最后编写的用例是：<br>a. 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5<br>b. 1 -&gt; 4 -&gt; 5<br>c. 1 -&gt; 4 -&gt; 3</li>
</ol>
<h2 id="测试规划"><a href="#测试规划" class="headerlink" title="测试规划"></a>测试规划</h2><p>在需求明确之后，有大致的测试用例之后，应该对测试的实施有一个大致的规划，一定程度的明确各个类型的测试做多少，怎么做。</p>
<p>比如对于复杂的项目，我们可能需要更多的单元测试，从而保证逻辑的正确性，对于简单的项目，可能一定的功能测试和 E2E 测试就可以了。</p>
<p>测试规划的时候，应该考虑到各种测试类型擅长的和不擅长的，合理安排比例以及覆盖场景，在成本可控的前提下实现效率的最大化。</p>
<h2 id="测试开发"><a href="#测试开发" class="headerlink" title="测试开发"></a>测试开发</h2><p>规划完毕之后，就可以和代码开发一起，进入测试开发的环节，在开发的过程中，一定会发现之前没有考虑到的情况，或者发现效率更高的方法，这时及时调整策略，优化方案。</p>
<h1 id="测试平台与工具"><a href="#测试平台与工具" class="headerlink" title="测试平台与工具"></a>测试平台与工具</h1><p>测试平台和工具包含测试工具相关的东西，通过优秀工具的使用和研发，让测试开发能够非常简单的进行，找到测试开发的乐趣。</p>
<h2 id="测试数据管理平台"><a href="#测试数据管理平台" class="headerlink" title="测试数据管理平台"></a>测试数据管理平台</h2><p>测试数据是进行高效测试的基础，尤其是对于我们这种 toB 复杂业务逻辑来说，如果没有良好基础测试数据的支持，我们将花费大量时间在测试数据的准备上，测试的编写和维护将会变成一件很难受的工作。</p>
<p>为了解决这个问题，我们引入测试数据管理平台，他能够帮助我们管理各种测试数据，需要的时候，通过很简单的方式就可能调用这些测试数据，减少人工构造的成本。</p>
<p>这之中的测试数据将主要用到以下四个地方：</p>
<ol>
<li>后端功能测试</li>
<li>前端 E2E 测试</li>
<li>demo 系统</li>
<li>开发环境</li>
</ol>
<p>对这个平台而言，它将提供如下功能：</p>
<ol>
<li>测试数据存储与管理</li>
<li>测试数据的写入与生成</li>
<li>多套后端服务的配置管理，同一个平台，可以向多个后端写入数据？</li>
<li>通过对外 API，能够通过 API 执行指定的命令</li>
<li>依据 client 请求执行单个&#x2F;批量数据请求&#x2F;写入操作</li>
</ol>
<p>目前这个平台主要提供一套相对固定的数据， 将来，它应该有能力按需及时生成一部分数据，能够用于对数据之间关系要求不高的场景。</p>
<h2 id="后端测试工具"><a href="#后端测试工具" class="headerlink" title="后端测试工具"></a>后端测试工具</h2><p>为了改善后端测试的效率，我们已经&#x2F;需要开发一些测试工具，让测试开发更简单，主要包含如下几个部分：</p>
<ol>
<li>基础测试工具，是对开源工具的改善和封装，比如 UTL <a href="https://git.seiue.com/open-source/utl/tree/master">https://git.seiue.com/open-source/utl/tree/master</a></li>
<li>应用层相关工具，比如 <a href="https://www.yuque.com/kovru3/gfdy75/ygtibk">https://www.yuque.com/kovru3/gfdy75/ygtibk</a> 这里面说的</li>
<li>与测试数据平台的交互，交互方式是什么？类似 UDS 注册的机制？</li>
<li>Reponse 与 schema 定义的一致性检查</li>
</ol>
<h2 id="前端测试工具"><a href="#前端测试工具" class="headerlink" title="前端测试工具"></a>前端测试工具</h2><p>同理，前端差不多，可能包含如下几个部分：</p>
<ol>
<li>基础测试工具最佳实践，封装</li>
<li>数据 Mock 的机制，什么时候 Mock</li>
<li>测试数据平台通信的方式</li>
</ol>
<h1 id="测试方法论"><a href="#测试方法论" class="headerlink" title="测试方法论"></a>测试方法论</h1><h2 id="编写可测试代码"><a href="#编写可测试代码" class="headerlink" title="编写可测试代码"></a>编写可测试代码</h2><p>为了良好的实施自动化测试，我们对各方实施一定的约束，以便能够高效的开展自动化测试，让自动化测试的效能最大化。</p>
<h2 id="被测主体约束"><a href="#被测主体约束" class="headerlink" title="被测主体约束"></a>被测主体约束</h2><p>被测试主体（包括但不限于后端服务，前端组件，数据层）都应该提供良好的数据测试支持，这样测试代码才能够很好的与测试主体进行交互，从而高效的完成测试。</p>
<p>比如，后端在进行 API 设计的时候需要考虑到测试的场景，能够通过 API 准备需要的测试数据，也可能需要给测试提供专用的 API。</p>
<p>前端可能将数据数据操作接口暴露到外部，能够让测试代码直接操作内部方法和数据，以便方便高效的完成自动化测试（见附[1]）。</p>
<p>被测试主体应该同时满足多方面的需求，包括但不限于：</p>
<ol>
<li>业务需求</li>
<li>测试需求</li>
<li>架构需求</li>
</ol>
<h3 id="代码约束"><a href="#代码约束" class="headerlink" title="代码约束"></a>代码约束</h3><p>为了进行良好的单元测试，对我们的代码也提出了更高的要求，我们的代码需要更好的可测试性，具体来说包含如下几个方面：</p>
<ol>
<li>功能划分清晰，职责分明，函数、类的实现应该高内聚，底耦合，一个方法只做一件事</li>
<li>外部依赖显式化，依赖的东西应该单独测试 附[2]</li>
<li>尽量避免副作用，输入输出应该简单统一</li>
<li>More needed</li>
</ol>
<h2 id="数据与行为分离"><a href="#数据与行为分离" class="headerlink" title="数据与行为分离"></a>数据与行为分离</h2><p>在测试中，有很多时候我们需要对同一个场景使用不同的数据进行测试，同时期望获取不同的结果，这时如果测试数据和测试代码耦合在一起，就需要将他们同时复制多份，代码可读性和维护起来都是一个问题。</p>
<p>这时，我们可以采用数据与行为分离的策略，将测试行为抽象出来，然后再用给定的数据跑测试。</p>
<p>在 PHP 项目中，我们可以 PHPUnit 的 DataProvider 实现这样的策略，在前端的 Jest 中，也可以使用 jest.each 达成同样的效果。不同测试框架都应该有类似的支持（hmmm, Cypress 好像没有原生的支持）。</p>
<h2 id="App-Actions"><a href="#App-Actions" class="headerlink" title="App Actions"></a>App Actions</h2><p>在 E2E 测试中，传统的做法是封装 PageObject，用来封装 UI 层的操作，以便让测试代码更加易于维护，但因为 UI 层的变化一般比较大，这一层的封装成本比较高，而且所有地方都通过 UI 来操作效率很低，稳定性也不好。</p>
<p>所以，Cypress 采用了另外的思路，就是直接在测试代码中操作应用的内部逻辑，我们把这种方式称作 App Actions。某种程度上去掉了和简化了 PageObject 这个封装，从而减少的响应的成本。</p>
<p>它的缺点是需要理解应用的内部状态，但因为我们是开发者自己写测试，所以这个反而变成了优点。</p>
<p>读者具体可以查看 <a href="https://www.cypress.io/blog/2019/01/03/stop-using-page-objects-and-start-using-app-actions/">Stop using Page Objects and Start using App Actions</a> 了解更详细的内容。</p>
<h1 id="实施计划"><a href="#实施计划" class="headerlink" title="实施计划"></a>实施计划</h1><p>测试数据平台<br>[ ] 测试平台准备工作（P0）<br>[ ] 方案优化空间<br>[ ] 环境初始化<br>[ ] 对外提供 API (P1)</p>
<p>测试数据<br>[ ] 用户数据 (P0)<br>[ ] What’s else?</p>
<p>测试工具<br>[ ] 后端测试工具整理和规范 UTL<br>[ ] 后端针对 Event 和 Job 的测试工具<br>[ ] 后端 response 与 schema 的一致性检查 (P0)<br>[ ] 后端与测试平台的交互机制？(P0)<br>[ ] 前端测试工具的实践<br>[ ] 前端与测试平台的交互机制 (P0)<br>[ ] 前端 Mock 的场景与机制</p>
<p>测试流程&#x2F;方法论<br>[ ] 形成最佳实践（跟随实践不断迭代）</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>[1] <a href="https://www.cypress.io/blog/2019/01/03/stop-using-page-objects-and-start-using-app-actions/">https://www.cypress.io/blog/2019/01/03/stop-using-page-objects-and-start-using-app-actions/</a><br>[2] <a href="http://www.voidcn.com/article/p-uyjitnuy-bno.html">http://www.voidcn.com/article/p-uyjitnuy-bno.html</a></p>
]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>兼容性</title>
    <url>/2023/12/15/compatibility/</url>
    <content><![CDATA[<h1 id="经常遇到的浏览器的兼容性有哪些？"><a href="#经常遇到的浏览器的兼容性有哪些？" class="headerlink" title="经常遇到的浏览器的兼容性有哪些？"></a>经常遇到的浏览器的兼容性有哪些？</h1><ol>
<li><p>IE 浏览器不支持 <code>Promise</code><br>babel-polyfill → webpack.config.js 的 entry 中设置 [‘babel-polyfill’, ‘.&#x2F;src&#x2F;main.js’]</p>
</li>
<li><p>各浏览器之间默认样式的差异<br>normalize.css<br>与 reset 区别 → normalize.css 消除各浏览器之间默认样式的差异、保留有用的默认样式；<br>而 reset 会清除所有的默认样式，过于暴力，例如会让 h 标题标签不再默认加粗，ul li 前面默认的小圆点也没了）</p>
<span id="more"></span></li>
<li><p>html5 某些新增标签不被识别<br>html5shiv.js - 解决 ie9 以下对 html5 某些新增标签不识别的问题（e.g. video 标签不识别不显示）<br>用法：[if lt IE 9]&gt;<script> src="<a href="http://html5shim.googlecode.com/svn/trunk/html5.js">http://html5shim.googlecode.com/svn/trunk/html5.js</a>"</script>&lt;![endif]<br>通过 <code>document.createElement</code> 方法产生的标签， 可以利用这一特性让这些浏览器支持 HTML5 新标签，浏览器支持新标签后，还需要添加标签默认的样式。</p>
</li>
<li><p>CSS3 媒体查询失效<br>respond.js - 能解决 ie9 以下不支持媒体查询问题</p>
</li>
<li><p>自动添加浏览器前缀<br>posscss-loader+autoprefixer</p>
</li>
<li><p>ie6 不支持 <code>min-height/width</code><br>添加额外的 _min-height ie6 识别</p>
</li>
<li><p>常见 <code>hack</code>（针对特定 ie 版本的样式控制）<br>_color - ie6 识别<br>*color - ie6&#x2F;7 识别<br>color: red\9; ie8 及以下识别</p>
</li>
<li><p>ie 条件注释写法：(lt 小于 | gt 大于 | lte 小于等于 | gte 大于等于 | ! 不等于)</p>
</li>
</ol>
<hr>
<h1 id="移动端兼容性？"><a href="#移动端兼容性？" class="headerlink" title="移动端兼容性？"></a>移动端兼容性？</h1><ol>
<li><p>移动端点透问题<a href="https://www.cnblogs.com/zhuzhenwei918/p/7588553.html">(解决办法)</a></p>
</li>
<li><p>ios 滚动卡顿<br>使用 better-scroll 插件</p>
</li>
<li><p>ios 顶部输入框 fixed 布局失效（当键盘弹起时）❌</p>
</li>
<li><p>安卓 键盘遮挡输入框 ❌</p>
</li>
<li><p>position:fixed; 在 android 下无效怎么处理？【❌ 待验证】</p>
<blockquote>
<p>原因：fixed 的元素是相对整个页面固定位置的，你在屏幕上滑动只是在移动这个所谓的 viewport ， 原来的网页还好好的在那，fixed 的内容也没有变过位置。</p>
</blockquote>
</li>
</ol>
<p>解决：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;meta</span><br><span class="line">  name=<span class="string">&quot;viewport&quot;</span></span><br><span class="line">  content=<span class="string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？❌<br>click 有 300ms 延迟,为了实现 safari 的双击事件的设计，浏览器要知道你是不是要双击操作。</li>
</ol>
<hr>
<h1 id="Polyfill"><a href="#Polyfill" class="headerlink" title="Polyfill"></a>Polyfill</h1><h2 id="什么是-Polyfill"><a href="#什么是-Polyfill" class="headerlink" title="什么是 Polyfill"></a>什么是 Polyfill</h2><p>polyfill 是“在旧版浏览器上复制标准 API 的 JavaScript 补充”,可以动态地加载 JavaScript 代码或库，在不支持这些标准 API 的浏览器中模拟它们。</p>
<p>例如，geolocation（地理位置）polyfill 可以在 navigator 对象上添加全局的 geolocation 对象，还能添加 getCurrentPosition 函数以及“坐标”回调对象， 所有这些都是 W3C 地理位置 API 定义的对象和函数。</p>
<p>因为 polyfill 模拟标准 API，所以能够以一种面向所有浏览器未来的方式针对这些 API 进行开发， 一旦对这些 API 的支持变成绝对大多数，则可以方便地去掉 polyfill，无需做任何额外工作。</p>
<ul>
<li>做的项目中，有没有用过或自己实现一些 polyfill 方案（兼容性处理方案）？❌<br>比如： html5shiv、Geolocation、Placeholder</li>
</ul>
<hr>
<h1 id="列举-IE-与其他浏览器不一样的特性？"><a href="#列举-IE-与其他浏览器不一样的特性？" class="headerlink" title="列举 IE 与其他浏览器不一样的特性？"></a>列举 IE 与其他浏览器不一样的特性？</h1><p><strong>事件目标对象</strong></p>
<p>触发事件的元素被认为是目标（target）。而在 IE 中，目标包含在 <code>event</code> 对象的 <code>srcElement</code> 属性</p>
<p><strong>获取字符代码</strong></p>
<p>如果按键代表一个字符（shift、ctrl、alt 除外），IE 的 <code>keyCode</code> 会返回字符代码（Unicode），DOM 中按键的代码和字符是分离的，要获取字符代码，需要使用 <code>charCode</code> 属性</p>
<p><strong>阻止某个事件的默认行为</strong></p>
<p>IE 中阻止某个事件的默认行为，必须将 <code>returnValue</code> 属性设置为 <code>false</code>，Mozilla 中，需要调用 <code>preventDefault()</code> 方法</p>
<p><strong>停止事件冒泡</strong></p>
<p>IE 中阻止事件进一步冒泡，需要设置 <code>cancelBubble</code> 为 true，Mozzilla 中，需要调用 <code>stopPropagation()</code></p>
]]></content>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>compose函数组合</title>
    <url>/2019/10/10/compose/</url>
    <content><![CDATA[<p>在函数式编程当中有一个很重要的概念就是函数组合，实际上就是<strong>把处理数据的函数像管道一样连接起来，然后让数据穿过管道得到最终的结果</strong></p>
<p>在多个框架源码中都有用到，比如 redux、koa 中多次遇到这个方法</p>
<span id="more"></span>

<p>效果：将一系列函数，通过 <code>compose</code> 函数组合起来，像管道一样连接起来，比如函数结合<code>[f, g, h ]</code>，通过 <code>compose</code> 最终达到这样的效果： <code>f(g(h()))</code></p>
<p>compose 函数要求：可执行同步方法，也可执行异步方法，两者都可以兼容</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compose</span>(<span class="params">list</span>) &#123;</span><br><span class="line">  <span class="comment">// 取出第一个函数，当做reduce函数的初始值</span></span><br><span class="line">  <span class="keyword">const</span> init = list.<span class="title function_">shift</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...arg</span>) &#123;</span><br><span class="line">    <span class="comment">// 执行compose函数，返回一个函数</span></span><br><span class="line">    <span class="keyword">return</span> list.<span class="title function_">reduce</span>(</span><br><span class="line">      <span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 返回list.reduce的结果，为一个promise实例，外部就可以通过then获取</span></span><br><span class="line">        <span class="keyword">return</span> pre.<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// pre始终为一个promise实例，result为结果的累加值</span></span><br><span class="line">          <span class="comment">// 在前一个函数的then中，执行当前的函数，并返回一个promise实例，实现累加传递的效果</span></span><br><span class="line">          <span class="keyword">return</span> cur.<span class="title function_">call</span>(<span class="literal">null</span>, result);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// Promise.resolve可以将非promise实例转为promise实例（一种兼容处理）</span></span><br><span class="line">      <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(init.<span class="title function_">apply</span>(<span class="literal">null</span>, arg))</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步方法案例</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">sync1</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sync1&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">sync2</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sync2&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> data + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">sync3</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sync3&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> data + <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> syncFn = <span class="title function_">compose</span>([sync1, sync2, sync3]);</span><br><span class="line"><span class="title function_">syncFn</span>(<span class="number">0</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 依次打印 sync1 → sync2 → sync3 → 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步方法案例</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">async1</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1&quot;</span>);</span><br><span class="line">      <span class="title function_">resolve</span>(data);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">async2</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async2&quot;</span>);</span><br><span class="line">      <span class="title function_">resolve</span>(data + <span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">async3</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async3&quot;</span>);</span><br><span class="line">      <span class="title function_">resolve</span>(data + <span class="number">2</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> composeFn = <span class="title function_">compose</span>([async1, async2, async3]);</span><br><span class="line"><span class="title function_">composeFn</span>(<span class="number">0</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 依次打印 async1 → async1 → async1 → 3</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS实现倒计时</title>
    <url>/2019/10/01/countdown/</url>
    <content><![CDATA[<p>天，小时，分钟，秒钟倒计时</p>
<span id="more"></span>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>倒计时<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;day&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;hour&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;minute&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;second&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> deadline = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;2019-10-1 00:00:00&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> dayElement = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.day&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> hourElement = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.hour&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> minuteElement = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.minute&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> secondElement = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.second&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> <span class="title function_">countDown</span> = (<span class="params"></span>) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> timeRemaining = deadline - <span class="keyword">new</span> <span class="title class_">Date</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> day, hour, minute, second;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (timeRemaining &lt; <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">return</span> <span class="number">0</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        day = <span class="title class_">Math</span>.<span class="title function_">floor</span>(timeRemaining / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> / <span class="number">24</span>);</span></span><br><span class="line"><span class="language-javascript">        hour = <span class="title class_">Math</span>.<span class="title function_">floor</span>((timeRemaining / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span>) % <span class="number">24</span>);</span></span><br><span class="line"><span class="language-javascript">        minute = <span class="title class_">Math</span>.<span class="title function_">floor</span>((timeRemaining / <span class="number">1000</span> / <span class="number">60</span>) % <span class="number">60</span>);</span></span><br><span class="line"><span class="language-javascript">        second = <span class="title class_">Math</span>.<span class="title function_">floor</span>((timeRemaining / <span class="number">1000</span>) % <span class="number">60</span>);</span></span><br><span class="line"><span class="language-javascript">        dayElement.<span class="property">innerHTML</span> = day + <span class="string">&quot;天&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        hourElement.<span class="property">innerHTML</span> = hour + <span class="string">&quot;时&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        minuteElement.<span class="property">innerHTML</span> = minute + <span class="string">&quot;分&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        secondElement.<span class="property">innerHTML</span> = second + <span class="string">&quot;秒&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="built_in">setTimeout</span>(countDown, <span class="number">1000</span>);</span></span><br><span class="line"><span class="language-javascript">      &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">countDown</span>();</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖节流函数</title>
    <url>/2023/12/18/debounce-throttle/</url>
    <content><![CDATA[<h1 id="防抖-debounce-重新开始"><a href="#防抖-debounce-重新开始" class="headerlink" title="防抖 debounce - 重新开始"></a>防抖 debounce - 重新开始</h1><p>应用场景：搜索框输入文字后调用对应搜索接口、文本编辑器实时保存</p>
<p>利用闭包，不管触发频率多高，在停止触发 n 秒后才会执行，如果重复触发，会清空之前的定时器，重新计时，直到最后一次 n 秒后执行</p>
<span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @param &#123;function&#125; fn - 需要防抖的函数</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; time - 多长时间执行一次</span></span><br><span class="line"><span class="comment"> * @param &#123;boolean&#125; flag - 第一次是否执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, time, flag</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="comment">// 在time时间段内重复执行，会清空之前的定时器，然后重新计时</span></span><br><span class="line">    timer &amp;&amp; <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    <span class="keyword">if</span> (flag &amp;&amp; !timer) &#123;</span><br><span class="line">      <span class="comment">// flag为true 第一次默认执行</span></span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;执行:&quot;</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> debounceFn = <span class="title function_">debounce</span>(fn, <span class="number">3000</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="title function_">debounceFn</span>(<span class="number">1</span>);</span><br><span class="line"><span class="title function_">debounceFn</span>(<span class="number">2</span>);</span><br><span class="line"><span class="title function_">debounceFn</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先打印：执行: 1</span></span><br><span class="line"><span class="comment">// 3s后打印: 执行: 3</span></span><br></pre></td></tr></table></figure>

<h1 id="节流-throttle-不要打断我"><a href="#节流-throttle-不要打断我" class="headerlink" title="节流 throttle - 不要打断我"></a>节流 throttle - 不要打断我</h1><p>应用场景： 下拉滚动加载、快速点击、resize 事件，鼠标滑动、scroll 事件，视频播放记录时间等</p>
<p>利用闭包，不管触发频率多高，每隔一段时间内执行一次</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @param &#123;function&#125; fn - 需要防抖的函数</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; time - 多长时间执行一次</span></span><br><span class="line"><span class="comment"> * @param &#123;boolean&#125; flag - 第一次是否执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, time, flag</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="comment">// flag控制第一次是否立即执行</span></span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">      <span class="comment">// 第一次执行完后，flag变为false；否则以后每次都会执行</span></span><br><span class="line">      flag = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">        <span class="comment">// 每次执行完重置timer</span></span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">      &#125;, time);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fn&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> throttleFn = <span class="title function_">throttle</span>(fn, <span class="number">3000</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">setInterval</span>(throttleFn, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试结果，一开始就打印&quot;fn&quot;, 以后每隔3s打印一次&quot;fn&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JS</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2021/10/14/design-patterns/</url>
    <content><![CDATA[<p>设计模式是从许多优秀的软件系统中，总结出的成功的、能够实现可维护性、复用的设计方案，使用这些方案将可以让我们避免做一些重复性的工作。</p>
<span id="more"></span>

<h1 id="单例模式-弹框"><a href="#单例模式-弹框" class="headerlink" title="单例模式(弹框)"></a>单例模式(弹框)</h1><p>一个类只能构造出唯一实例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Single</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getInstance</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">instance</span>) &#123;</span><br><span class="line">      <span class="comment">// 关键代码 this指向的是Single这个构造函数</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">instance</span> = <span class="keyword">new</span> <span class="title class_">Single</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">instance</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> single1 = <span class="title class_">Single</span>.<span class="title function_">getInstance</span>(<span class="string">&quot;name1&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> single2 = <span class="title class_">Single</span>.<span class="title function_">getInstance</span>(<span class="string">&quot;name2&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(single1 === single2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h1 id="策略模式-表单验证"><a href="#策略模式-表单验证" class="headerlink" title="策略模式(表单验证)"></a>策略模式(表单验证)</h1><p>根据不同参数命中不同的策略</p>
<h2 id="策略模式的表单验证示例"><a href="#策略模式的表单验证示例" class="headerlink" title="策略模式的表单验证示例"></a>策略模式的表单验证示例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 策略对象</span></span><br><span class="line"><span class="keyword">const</span> strategies = &#123;</span><br><span class="line">  <span class="comment">// 验证是否为空</span></span><br><span class="line">  <span class="attr">isNoEmpty</span>: <span class="keyword">function</span>(<span class="params">value, errorMsg</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value.<span class="title function_">trim</span>() === <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 验证最小长度</span></span><br><span class="line">  <span class="attr">minLength</span>: <span class="keyword">function</span>(<span class="params">value, length, errorMsg</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value.<span class="title function_">trim</span>().<span class="property">length</span> &lt; length) &#123;</span><br><span class="line">      <span class="keyword">return</span> errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 验证最大长度</span></span><br><span class="line">  <span class="attr">maxLength</span>: <span class="keyword">function</span>(<span class="params">value, length, errorMsg</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value.<span class="property">length</span> &gt; length) &#123;</span><br><span class="line">      <span class="keyword">return</span> errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 验证手机号</span></span><br><span class="line">  <span class="attr">isMobile</span>: <span class="keyword">function</span>(<span class="params">value, errorMsg</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      !<span class="regexp">/^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|17[7]|18[0|1|2|3|5|6|7|8|9])\d&#123;8&#125;$/</span>.<span class="title function_">test</span>(</span><br><span class="line">        value</span><br><span class="line">      )</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Validator</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span> = []; <span class="comment">// 存储要验证的方法</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">errList</span> = []; <span class="comment">// 存储最终的验证结果</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">add</span>(<span class="params">value, rules</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, rule; (rule = rules[i++]); ) &#123;</span><br><span class="line">      <span class="keyword">let</span> strategyAry = rule.<span class="property">strategy</span>.<span class="title function_">split</span>(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">      <span class="keyword">let</span> errorMsg = rule.<span class="property">errorMsg</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> strategy = strategyAry.<span class="title function_">shift</span>();</span><br><span class="line">        strategyAry.<span class="title function_">unshift</span>(value);</span><br><span class="line">        strategyAry.<span class="title function_">push</span>(errorMsg);</span><br><span class="line">        <span class="comment">// 执行策略对象中的不同验证规则</span></span><br><span class="line">        <span class="keyword">let</span> error = strategies[strategy](...strategyAry <span class="string">&quot;strategy&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">errList</span>.<span class="title function_">push</span>(error);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">start</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, validatorFunc; (validatorFunc = <span class="variable language_">this</span>.<span class="property">cache</span>[i++]); ) &#123;</span><br><span class="line">      <span class="title function_">validatorFunc</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">errList</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> validataFunc = <span class="keyword">function</span>(<span class="params">info</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> validator = <span class="keyword">new</span> <span class="title class_">Validator</span>();</span><br><span class="line">  validator.<span class="title function_">add</span>(info.<span class="property">userName</span>, [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">strategy</span>: <span class="string">&quot;isNoEmpty&quot;</span>,</span><br><span class="line">      <span class="attr">errorMsg</span>: <span class="string">&quot;用户名不可为空&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">strategy</span>: <span class="string">&quot;minLength:2&quot;</span>,</span><br><span class="line">      <span class="attr">errorMsg</span>: <span class="string">&quot;用户名长度不能小于2位&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]);</span><br><span class="line">  validator.<span class="title function_">add</span>(info.<span class="property">password</span>, [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">strategy</span>: <span class="string">&quot;minLength:6&quot;</span>,</span><br><span class="line">      <span class="attr">errorMsg</span>: <span class="string">&quot;密码长度不能小于6位&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]);</span><br><span class="line">  validator.<span class="title function_">add</span>(info.<span class="property">phoneNumber</span>, [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">strategy</span>: <span class="string">&quot;isMobile&quot;</span>,</span><br><span class="line">      <span class="attr">errorMsg</span>: <span class="string">&quot;请输入正确的手机号码格式&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]);</span><br><span class="line">  <span class="keyword">return</span> validator.<span class="title function_">start</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要验证表单的对象</span></span><br><span class="line"><span class="keyword">let</span> userInfo = &#123;</span><br><span class="line">  <span class="attr">userName</span>: <span class="string">&quot;王&quot;</span>,</span><br><span class="line">  <span class="attr">password</span>: <span class="string">&quot;1234&quot;</span>,</span><br><span class="line">  <span class="attr">phoneNumber</span>: <span class="string">&quot;666&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> errorMsg = <span class="title function_">validataFunc</span>(userInfo);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(errorMsg); <span class="comment">// [&#x27;用户名长度不能小于2位&#x27;, &#x27;密码长度不能小于6位&#x27;, &#x27;请输入正确的手机号码格式&#x27;]</span></span><br></pre></td></tr></table></figure>

<h1 id="代理模式-图片预加载"><a href="#代理模式-图片预加载" class="headerlink" title="代理模式(图片预加载)"></a>代理模式(图片预加载)</h1><p>代理对象和本体对象具有一致的接口</p>
<h2 id="图片代理模式示例"><a href="#图片代理模式示例" class="headerlink" title="图片代理模式示例"></a>图片代理模式示例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代理模式</span></span><br><span class="line"><span class="keyword">let</span> relImage = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> imgNode = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(imgNode);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">setSrc</span>(<span class="params">src</span>) &#123;</span><br><span class="line">      imgNode.<span class="property">src</span> = src;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">let</span> proxyImage = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">  <span class="comment">// 实际要加载的图片 加载成功后 替换调占位图</span></span><br><span class="line">  img.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    relImage.<span class="title function_">setSrc</span>(img.<span class="property">src</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">setSrc</span>(<span class="params">src</span>) &#123;</span><br><span class="line">      img.<span class="property">src</span> = src;</span><br><span class="line">      <span class="comment">// 设置占位图</span></span><br><span class="line">      relImage.<span class="title function_">setSrc</span>(</span><br><span class="line">        <span class="string">&quot;https://fuss10.elemecdn.com/e/5d/4a731a90594a4af544c0c25941171jpeg.jpeg&quot;</span></span><br><span class="line">      );</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置实际要加载的图片</span></span><br><span class="line">proxyImage.<span class="title function_">setSrc</span>(</span><br><span class="line">  <span class="string">&quot;https://cube.elemecdn.com/6/94/4d3ea53c084bad6931a56d5158a48jpeg.jpeg&quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h1 id="装饰者模式-在函数执行前后添加新的方法"><a href="#装饰者模式-在函数执行前后添加新的方法" class="headerlink" title="装饰者模式(在函数执行前后添加新的方法)"></a>装饰者模式(在函数执行前后添加新的方法)</h1><p>在不改变对象自身的基础上，动态地给某个对象添加一些额外的职责</p>
<h2 id="装饰者模式示例"><a href="#装饰者模式示例" class="headerlink" title="装饰者模式示例"></a>装饰者模式示例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fuc</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">before</span> = <span class="keyword">function</span> (<span class="params">beFn</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    beFn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>); <span class="comment">// 先执行插入到前面的方法，类似于二叉树的前序遍历</span></span><br><span class="line">    <span class="keyword">return</span> self.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>); <span class="comment">// 后执行当前的方法</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">after</span> = <span class="keyword">function</span> (<span class="params">afFn</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    self.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>); <span class="comment">// 先执行当前的方法</span></span><br><span class="line">    <span class="keyword">return</span> afFn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>); <span class="comment">// 后执行插入到后面的方法</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fuc1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fuc3</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fuc4</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fuc = fuc.<span class="title function_">before</span>(fuc1).<span class="title function_">before</span>(fuc4).<span class="title function_">after</span>(fuc3);</span><br><span class="line"><span class="title function_">fuc</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终打印结果：4 1 2 3</span></span><br></pre></td></tr></table></figure>

<h1 id="组合模式-打印文件目录"><a href="#组合模式-打印文件目录" class="headerlink" title="组合模式(打印文件目录)"></a>组合模式(打印文件目录)</h1><p>组合模式在对象间形成树形结构<br>组合模式中基本对象和组合对象被一致对待<br>无须关心对象有多少层, 调用时只需在根部进行调用</p>
<h2 id="函数组合模式示例"><a href="#函数组合模式示例" class="headerlink" title="函数组合模式示例"></a>函数组合模式示例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Combine</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">add</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">push</span>(fn);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>; <span class="comment">// 链式调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">excute</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">list</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">list</span>[i].<span class="title function_">excute</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> comb1 = <span class="keyword">new</span> <span class="title class_">Combine</span>();</span><br><span class="line">comb1</span><br><span class="line">  .<span class="title function_">add</span>(&#123;</span><br><span class="line">    <span class="title function_">excute</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">add</span>(&#123;</span><br><span class="line">    <span class="title function_">excute</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> comb2 = <span class="keyword">new</span> <span class="title class_">Combine</span>();</span><br><span class="line">comb2</span><br><span class="line">  .<span class="title function_">add</span>(&#123;</span><br><span class="line">    <span class="title function_">excute</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">add</span>(&#123;</span><br><span class="line">    <span class="title function_">excute</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> comb3 = <span class="keyword">new</span> <span class="title class_">Combine</span>();</span><br><span class="line">comb3</span><br><span class="line">  .<span class="title function_">add</span>(&#123;</span><br><span class="line">    <span class="title function_">excute</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">add</span>(&#123;</span><br><span class="line">    <span class="title function_">excute</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">comb2.<span class="title function_">add</span>(comb3);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> comb4 = <span class="keyword">new</span> <span class="title class_">Combine</span>();</span><br><span class="line">comb4.<span class="title function_">add</span>(comb1).<span class="title function_">add</span>(comb2);</span><br><span class="line">comb4.<span class="title function_">excute</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终打印结果：1 2 3 4 5 6</span></span><br></pre></td></tr></table></figure>

<h1 id="工厂模式-jquery-中的-window"><a href="#工厂模式-jquery-中的-window" class="headerlink" title="工厂模式(jquery 中的 window.$)"></a>工厂模式(jquery 中的 window.$)</h1><p>工厂模式是用来创建对象的一种最常用的设计模式</p>
<p>不暴露创建对象的具体逻辑，而是将逻辑封装在一个函数中，这个函数就可以被视为一个工厂</p>
<h2 id="工厂模式示例"><a href="#工厂模式示例" class="headerlink" title="工厂模式示例"></a>工厂模式示例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, color</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">create</span>(<span class="params">type</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;car&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;汽车&quot;</span>, <span class="string">&quot;白色&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;bicycle&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;自行车&quot;</span>, <span class="string">&quot;黑色&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="attr">default</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;没有该类型&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Factory</span>.<span class="title function_">create</span>(<span class="string">&quot;car&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Factory</span>.<span class="title function_">create</span>(<span class="string">&quot;bicycle&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1, p1 <span class="keyword">instanceof</span> <span class="title class_">Car</span>); <span class="comment">// &#123;name: &#x27;汽车&#x27;, color: &#x27;白色&#x27;&#125; true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2, p2 <span class="keyword">instanceof</span> <span class="title class_">Car</span>); <span class="comment">// &#123;name: &#x27;自行车&#x27;, color: &#x27;黑色&#x27;&#125; true</span></span><br></pre></td></tr></table></figure>

<h1 id="访问者模式-babel-插件"><a href="#访问者模式-babel-插件" class="headerlink" title="访问者模式(babel 插件)"></a>访问者模式(babel 插件)</h1><p>在不改变该对象的前提下访问其结构中元素的新方法</p>
<h2 id="访问者模式示例"><a href="#访问者模式示例" class="headerlink" title="访问者模式示例"></a>访问者模式示例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 元素类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, chinese, math, english</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">chinese</span> = chinese;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">math</span> = math;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">english</span> = english;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">accept</span>(<span class="params">visitor</span>) &#123;</span><br><span class="line">    visitor.<span class="title function_">visit</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问者类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChineseTeacher</span> &#123;</span><br><span class="line">  <span class="title function_">visit</span>(<span class="params">student</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`语文 <span class="subst">$&#123;student.chinese&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MathTeacher</span> &#123;</span><br><span class="line">  <span class="title function_">visit</span>(<span class="params">student</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`数学 <span class="subst">$&#123;student.math&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EnglishTeacher</span> &#123;</span><br><span class="line">  <span class="title function_">visit</span>(<span class="params">student</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`英语 <span class="subst">$&#123;student.english&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化元素类</span></span><br><span class="line"><span class="keyword">const</span> student = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">90</span>, <span class="number">80</span>, <span class="number">60</span>);</span><br><span class="line"><span class="comment">// 实例化访问者类</span></span><br><span class="line"><span class="keyword">const</span> chineseTeacher = <span class="keyword">new</span> <span class="title class_">ChineseTeacher</span>();</span><br><span class="line"><span class="keyword">const</span> mathTeacher = <span class="keyword">new</span> <span class="title class_">MathTeacher</span>();</span><br><span class="line"><span class="keyword">const</span> englishTeacher = <span class="keyword">new</span> <span class="title class_">EnglishTeacher</span>();</span><br><span class="line"><span class="comment">// 接受访问</span></span><br><span class="line">student.<span class="title function_">accept</span>(chineseTeacher); <span class="comment">// 语文90</span></span><br><span class="line">student.<span class="title function_">accept</span>(mathTeacher); <span class="comment">// 数学80</span></span><br><span class="line">student.<span class="title function_">accept</span>(englishTeacher); <span class="comment">// 英语60</span></span><br></pre></td></tr></table></figure>

<h1 id="发布订阅模式-EventBus"><a href="#发布订阅模式-EventBus" class="headerlink" title="发布订阅模式(EventBus)"></a>发布订阅模式(EventBus)</h1><p>订阅者订阅相关主题，发布者通过发布主题事件的方式，通知订阅该主题的对象</p>
<h2 id="手写发布订阅模式示例"><a href="#手写发布订阅模式示例" class="headerlink" title="手写发布订阅模式示例"></a>手写发布订阅模式示例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发布订阅模式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventBus</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">task</span> = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">on</span>(<span class="params">type, fn</span>) &#123;</span><br><span class="line">    <span class="comment">// on 注册事件</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">task</span>[type]) <span class="variable language_">this</span>.<span class="property">task</span>[type] = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">task</span>[type].<span class="title function_">push</span>(fn);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">emit</span>(<span class="params">type, ...args</span>) &#123;</span><br><span class="line">    <span class="comment">// emit 发送事件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">task</span>[type]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">task</span>[type].<span class="title function_">forEach</span>(<span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">        fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args); <span class="comment">// 注意this指向</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">off</span>(<span class="params">type, fn</span>) &#123;</span><br><span class="line">    <span class="comment">// 删除事件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">task</span>[type]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">task</span>[type] = <span class="variable language_">this</span>.<span class="property">task</span>[type].<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item !== fn);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">once</span>(<span class="params">type, fn</span>) &#123;</span><br><span class="line">    <span class="comment">// 只执行一次</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">      <span class="title function_">fn</span>(...args);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">off</span>(type, f);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">on</span>(type, f);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">let</span> event = <span class="keyword">new</span> <span class="title class_">EventBus</span>();</span><br><span class="line">event.<span class="title function_">on</span>(<span class="string">&quot;change&quot;</span>, <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(args);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 只执行一次</span></span><br><span class="line">event.<span class="title function_">once</span>(<span class="string">&quot;change&quot;</span>, <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(args);</span><br><span class="line">&#125;);</span><br><span class="line">event.<span class="title function_">emit</span>(<span class="string">&quot;change&quot;</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">event.<span class="title function_">emit</span>(<span class="string">&quot;change&quot;</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h1 id="观察者模式-vue-双向绑定"><a href="#观察者模式-vue-双向绑定" class="headerlink" title="观察者模式(vue 双向绑定)"></a>观察者模式(vue 双向绑定)</h1><p>一个对象有一系列依赖于它的观察者（watcher），当对象发生变化时，会通知观察者进行更新</p>
<h2 id="观察者模式示例"><a href="#观察者模式示例" class="headerlink" title="观察者模式示例"></a>观察者模式示例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;ming&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(data).<span class="title function_">forEach</span>(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> value = data[key];</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data, key, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;get&quot;</span>, value);</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;更新&quot;</span>);</span><br><span class="line">      value = newValue;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">data.<span class="property">name</span> = <span class="string">&quot;佩奇&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="property">name</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依次打印： 更新 → get 佩奇 → 佩奇</span></span><br></pre></td></tr></table></figure>

<h1 id="观察者与发布订阅模式的区别"><a href="#观察者与发布订阅模式的区别" class="headerlink" title="观察者与发布订阅模式的区别"></a>观察者与发布订阅模式的区别</h1><p>观察者模式：一个对象有一系列依赖于它的观察者（watcher），当对象发生变化时，会通知观察者进行更新</p>
<p>发布订阅模式：订阅者订阅相关主题，发布者通过发布主题事件的方式通知订阅该主题的对象，发布订阅模式中可以基于不同的主题去执行不同的自定义事件</p>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS 垃圾回收机制</title>
    <url>/2023/01/15/garbage-recycling-mechanism/</url>
    <content><![CDATA[<h1 id="一、垃圾回收机制——GC"><a href="#一、垃圾回收机制——GC" class="headerlink" title="一、垃圾回收机制——GC"></a>一、垃圾回收机制——GC</h1><p>Javascript 具有自动垃圾回收机制（GC：Garbage Collecation），也就是说，执行环境会负责管理代码执行过程中使用的内存。</p>
<p>原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。</p>
<p>通常情况下有两种实现方式：</p>
<span id="more"></span>

<h2 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2><p>js 中最常用的垃圾回收方式就是标记清除。</p>
<p>当变量进入环境时，例如，在函数中声明一个变量，就将这个变量<strong>标记为“进入环境”</strong>。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其<strong>标记为“离开环境”</strong>。</p>
<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p><strong>跟踪记录每个值被引用的次数</strong></p>
<p>当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为 0 的值所占用的内存。</p>
<h1 id="二、内存管理"><a href="#二、内存管理" class="headerlink" title="二、内存管理"></a>二、内存管理</h1><ol>
<li>Javascript 引擎基础 GC 方案是</li>
</ol>
<p>（simple GC）：mark and sweep（标记清除），即：</p>
<p>1）遍历所有可访问的对象；</p>
<p>2）回收已不可访问的对象。</p>
<ol start="2">
<li>GC 的缺陷</li>
</ol>
<p>和其他语言一样，JavaScript 的 GC 策略也无法避免一个问题：<strong>GC 时，停止响应其他操作</strong>，这是为了安全考虑。而 Javascript 的 GC 在 100ms 甚至以上，对一般的应用还好，但对于 JS 游戏，动画对连贯性要求比较高的应用，就麻烦了。<br>这就是新引擎需要优化的点：避免 GC 造成的长时间停止响应。</p>
<ol start="3">
<li>GC 优化策略</li>
</ol>
<p>1）分代回收（Generation GC）</p>
<p>这个和 Java 回收策略思想是一致的。目的是通过区分“临时”与“持久”对象；多回收“临时对象”区（young generation），少回收“持久对象”区（tenured generation），减少每次需遍历的对象，从而减少每次 GC 的耗时。</p>
<p>2）增量 GC</p>
<p>这个方案的思想很简单，就是“每次处理一点，下次再处理一点”，如此类推。</p>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>软链接和硬链接</title>
    <url>/2023/12/19/hard-symbol-link/</url>
    <content><![CDATA[<p>假设我们有一个文件，称为 <code>hello</code></p>
<p>通过 <code>ln -s</code> 创建一个软链接，通过 <code>ln</code> 可以创建一个硬链接。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ln -s hello hello-soft</span><br><span class="line">$ ln hello hello-hard</span><br><span class="line"></span><br><span class="line">$ ls -lh</span><br><span class="line">total 768</span><br><span class="line">45459612 -rw-r--r--  2 xiange  staff   153K 11 19 17:56 hello</span><br><span class="line">45459612 -rw-r--r--  2 xiange  staff   153K 11 19 17:56 hello-hard</span><br><span class="line">45463415 lrwxr-xr-x  1 xiange  staff     5B 11 19 19:40 hello-soft -&gt; hello</span><br></pre></td></tr></table></figure>

<p>他们的区别有以下几点:</p>
<ul>
<li>软链接可理解为指向源文件的指针，它是单独的一个文件，仅仅只有几个字节，它拥有独立的 inode</li>
<li>硬链接与源文件同时指向一个物理地址，它与源文件共享存储数据，它俩拥有相同的 inode</li>
</ul>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>实现图片的懒加载</title>
    <url>/2022/12/14/img-lazyload/</url>
    <content><![CDATA[<p>图片的懒加载原理： 当图片元素出现在屏幕中时，才给图片的 src 赋值对应的链接，去加载对应的图片</p>
<span id="more"></span>

<ol>
<li>scrollTop 和 img.offsetTop 判断</li>
</ol>
<p>图片加载条件： <code>img.offsetTop &lt; window.innerHeight + document.body.scrollTop</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;pic.png&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;pic.png&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;pic.png&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;pic.png&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;pic.png&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;pic.png&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> imgs = <span class="variable language_">document</span>.<span class="title function_">querySelectAll</span>(<span class="string">&quot;img&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">lazyLoad</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> scrollTop =</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollTop</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> winHeight = <span class="variable language_">window</span>.<span class="property">innerHeight</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; imgs.<span class="property">length</span>; i++) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">if</span> (imgs[i].<span class="property">offsetTop</span> &lt; scrollTop + winHeight) &#123;</span></span><br><span class="line"><span class="language-javascript">        imgs[i].<span class="property">src</span> = imgs[i].<span class="title function_">getAttribute</span>(<span class="string">&quot;data-src&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">onscroll</span> = <span class="title function_">lazyLoad</span>();</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>IntersectionObserver<br>使用 <code>IntersectionObserver</code> 监听元素来判断是否出现在视口，当图片出现在视口时，给 <code>img.src</code> 赋值</li>
</ol>
<p><code>IntersectionObserver</code> 替代监听 <code>scroll</code> 事件来判断元素是否在视口中，性能更高</p>
<p>图片懒加载示例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// html内容</span></span><br><span class="line"><span class="comment">// &lt;img src=&quot;./loading.jpg&quot; src=&quot;https://cube.elemecdn.com/6/94/4d3ea53c084bad6931a56d5158a48jpeg.jpeg&quot;&gt;</span></span><br><span class="line"><span class="comment">// &lt;img src=&quot;./loading.jpg&quot; src=&quot;https://fuss10.elemecdn.com/e/5d/4a731a90594a4af544c0c25941171jpeg.jpeg&quot;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">observerImg</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> imgList = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(<span class="function">(<span class="params">list</span>) =&gt;</span> &#123;</span><br><span class="line">    list.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 判断元素是否出现在视口</span></span><br><span class="line">      <span class="keyword">if</span> (item.<span class="property">intersectionRatio</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        item.<span class="property">target</span>.<span class="property">src</span> = item.<span class="property">target</span>.<span class="title function_">getAttribute</span>(<span class="string">&quot;src&quot;</span>);</span><br><span class="line">        observer.<span class="title function_">unobserve</span>(item.<span class="property">target</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; imgList.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 监听每个img元素</span></span><br><span class="line">    observer.<span class="title function_">observe</span>(imgList[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>indexedDB</title>
    <url>/2023/12/19/indexedDB/</url>
    <content><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>随着浏览器的功能不断增强，越来越多的网站开始考虑，将大量数据储存在客户端，这样可以减少从服务器获取数据，直接从本地获取数据。</p>
<p>现有的浏览器数据储存方案，都不适合储存大量数据：Cookie 的大小不超过 4KB，且每次请求都会发送回服务器；LocalStorage 在 2.5MB 到 10MB 之间（各家浏览器不同），而且不提供搜索功能，不能建立自定义的索引。所以，需要一种新的解决方案，这就是 IndexedDB 诞生的背景。</p>
<span id="more"></span>

<p>通俗地说，<strong>IndexedDB 就是浏览器提供的本地数据库，它可以被网页脚本创建和操作</strong>。IndexedDB 允许储存大量数据，提供查找接口，还能建立索引。这些都是 LocalStorage 所不具备的。就数据库类型而言，IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL 数据库。</p>
<p>IndexedDB 具有以下特点。</p>
<ul>
<li><p>（1）<strong>键值对储存</strong>。 IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以”键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。</p>
</li>
<li><p>（2）<strong>异步</strong>。 IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。</p>
</li>
</ul>
<ul>
<li><p>（3）<strong>支持事务</strong>。 IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。</p>
</li>
<li><p>（4）<strong>同源限制</strong>。 IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。</p>
</li>
<li><p>（5）<strong>储存空间大</strong>。 IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。</p>
</li>
<li><p>（6）<strong>支持二进制储存</strong>。 IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。</p>
</li>
</ul>
<h1 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h1><p>IndexedDB 是一个比较复杂的 API，涉及不少概念。它把不同的实体，抽象成一个个对象接口。学习这个 API，就是学习它的各种对象接口。</p>
<blockquote>
<ul>
<li>数据库：IDBDatabase 对象</li>
<li>对象仓库：IDBObjectStore 对象</li>
<li>索引： IDBIndex 对象</li>
<li>事务： IDBTransaction 对象</li>
<li>操作请求：IDBRequest 对象</li>
<li>指针： IDBCursor 对象</li>
<li>主键集合：IDBKeyRange 对象</li>
</ul>
</blockquote>
<p>下面是一些主要的概念。</p>
<p><strong>（1）数据库</strong></p>
<p>数据库是一系列相关数据的容器。每个域名（严格的说，是协议 + 域名 + 端口）都可以新建任意多个数据库。</p>
<p>IndexedDB 数据库有版本的概念。同一个时刻，只能有一个版本的数据库存在。如果要修改数据库结构（新增或删除表、索引或者主键），只能通过升级数据库版本完成。</p>
<p><strong>（2）对象仓库</strong></p>
<p>每个数据库包含若干个对象仓库（object store）。它类似于关系型数据库的表格。</p>
<p><strong>（3）数据记录</strong></p>
<p>对象仓库保存的是数据记录。每条记录类似于关系型数据库的行，但是只有主键和数据体两部分。主键用来建立默认的索引，必须是不同的，否则会报错。主键可以是数据记录里面的一个属性，也可以指定为一个递增的整数编号。</p>
<p><code>&#123; id: 1, text: &#39;foo&#39; &#125;</code><br>上面的对象中，id 属性可以当作主键。</p>
<p>数据体可以是任意数据类型，不限于对象。</p>
<p><strong>（4）索引</strong></p>
<p>为了加速数据的检索，可以在对象仓库里面，为不同的属性建立索引。</p>
<p><strong>（5）事务</strong></p>
<p>数据记录的读写和删改，都要通过事务完成。事务对象提供<code>error</code>、<code>abort</code>和<code>complete</code>三个事件，用来监听操作结果。</p>
<h1 id="三、操作流程"><a href="#三、操作流程" class="headerlink" title="三、操作流程"></a>三、操作流程</h1><p>IndexedDB 数据库的各种操作，一般是按照下面的流程进行的。这个部分只给出简单的代码示例，用于快速上手，详细的各个对象的 API 请看<a href="https://wangdoc.com/javascript/bom/indexeddb#indexeddb-%E5%AF%B9%E8%B1%A1">这里</a>。</p>
<h2 id="3-1-打开数据库"><a href="#3-1-打开数据库" class="headerlink" title="3.1 打开数据库"></a>3.1 打开数据库</h2><p>使用 IndexedDB 的第一步是打开数据库，使用<code>indexedDB.open()</code>方法。</p>
<p><code>var request = window.indexedDB.open(databaseName, version);</code></p>
<p>这个方法接受两个参数，第一个参数是字符串，表示数据库的名字。如果指定的数据库不存在，就会新建数据库。第二个参数是整数，表示数据库的版本。如果省略，打开已有数据库时，默认为当前版本；新建数据库时，默认为 1。</p>
<p><code>indexedDB.open()</code>方法返回一个 <code>IDBRequest</code> 对象。这个对象通过三种事件<code>error</code>、<code>success</code>、<code>upgradeneeded</code>，处理打开数据库的操作结果。</p>
<h3 id="1）error-事件"><a href="#1）error-事件" class="headerlink" title="1）error 事件"></a>1）error 事件</h3><p>error 事件表示打开数据库失败。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">request.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;数据库打开报错&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2）success-事件"><a href="#2）success-事件" class="headerlink" title="2）success 事件"></a>2）success 事件</h3><p>success 事件表示打开数据库成功。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> db;</span><br><span class="line">request.<span class="property">onsuccess</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  db = request.<span class="property">result</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;数据库打开成功&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这时，通过 request 对象的 result 属性拿到数据库对象。</p>
<h3 id="3）upgradeneeded-事件"><a href="#3）upgradeneeded-事件" class="headerlink" title="3）upgradeneeded 事件"></a>3）upgradeneeded 事件</h3><p>如果指定的版本号，大于数据库的实际版本号，就会发生数据库升级事件 upgradeneeded。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> db;</span><br><span class="line"></span><br><span class="line">request.<span class="property">onupgradeneeded</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  db = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这时通过事件对象的 target.result 属性，拿到数据库实例。</p>
<h2 id="3-2-新建数据库"><a href="#3-2-新建数据库" class="headerlink" title="3.2 新建数据库"></a>3.2 新建数据库</h2><p>新建数据库与打开数据库是同一个操作。如果指定的数据库不存在，就会新建。不同之处在于，后续的操作主要在 <code>upgradeneeded</code> 事件的监听函数里面完成，因为这时版本从无到有，所以会触发这个事件。</p>
<p>通常，新建数据库以后，第一件事是新建对象仓库（即新建表）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">request.<span class="property">onupgradeneeded</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  db = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">  <span class="keyword">var</span> objectStore = db.<span class="title function_">createObjectStore</span>(<span class="string">&quot;person&quot;</span>, &#123; <span class="attr">keyPath</span>: <span class="string">&quot;id&quot;</span> &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，数据库新建成功以后，新增一张叫做 person 的表格，主键是 id。</p>
<p>更好的写法是先判断一下，这张表格是否存在，如果不存在再新建。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">request.<span class="property">onupgradeneeded</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  db = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">  <span class="keyword">var</span> objectStore;</span><br><span class="line">  <span class="keyword">if</span> (!db.<span class="property">objectStoreNames</span>.<span class="title function_">contains</span>(<span class="string">&quot;person&quot;</span>)) &#123;</span><br><span class="line">    objectStore = db.<span class="title function_">createObjectStore</span>(<span class="string">&quot;person&quot;</span>, &#123; <span class="attr">keyPath</span>: <span class="string">&quot;id&quot;</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>主键（key）是默认建立索引的属性。比如，数据记录是<code>&#123; id: 1, name: &#39;张三&#39; &#125;</code>，那么 id 属性可以作为主键。主键也可以指定为下一层对象的属性，比如<code>&#123; foo: &#123; bar: &#39;baz&#39; &#125; &#125;</code>的 <code>foo.bar</code> 也可以指定为主键。</p>
<p>如果数据记录里面没有合适作为主键的属性，那么可以让 IndexedDB 自动生成主键。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> objectStore = db.<span class="title function_">createObjectStore</span>(<span class="string">&quot;person&quot;</span>, &#123; <span class="attr">autoIncrement</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，指定主键为一个递增的整数。</p>
<p>新建对象仓库以后，下一步可以新建索引。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">request.<span class="property">onupgradeneeded</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  db = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">  <span class="keyword">var</span> objectStore = db.<span class="title function_">createObjectStore</span>(<span class="string">&quot;person&quot;</span>, &#123; <span class="attr">keyPath</span>: <span class="string">&quot;id&quot;</span> &#125;);</span><br><span class="line">  objectStore.<span class="title function_">createIndex</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;name&quot;</span>, &#123; <span class="attr">unique</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">  objectStore.<span class="title function_">createIndex</span>(<span class="string">&quot;email&quot;</span>, <span class="string">&quot;email&quot;</span>, &#123; <span class="attr">unique</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>IDBObject.createIndex()</code>的三个参数分别为索引名称、索引所在的属性、配置对象（说明该属性是否包含重复的值）。</p>
<h2 id="3-3-新增数据"><a href="#3-3-新增数据" class="headerlink" title="3.3 新增数据"></a>3.3 新增数据</h2><p>新增数据指的是向对象仓库写入数据记录。这需要通过事务完成。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> request = db</span><br><span class="line">    .<span class="title function_">transaction</span>([<span class="string">&quot;person&quot;</span>], <span class="string">&quot;readwrite&quot;</span>)</span><br><span class="line">    .<span class="title function_">objectStore</span>(<span class="string">&quot;person&quot;</span>)</span><br><span class="line">    .<span class="title function_">add</span>(&#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>, <span class="attr">age</span>: <span class="number">24</span>, <span class="attr">email</span>: <span class="string">&quot;zhangsan@example.com&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">  request.<span class="property">onsuccess</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;数据写入成功&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  request.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;数据写入失败&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>();</span><br></pre></td></tr></table></figure>

<p>上面代码中，写入数据需要新建一个事务。新建时必须指定表格名称和操作模式（”只读”或”读写”）。新建事务以后，通过<code>IDBTransaction.objectStore(name)</code>方法，拿到 IDBObjectStore 对象，再通过表格对象的 add()方法，向表格写入一条记录。</p>
<p>写入操作是一个异步操作，通过监听连接对象的<code>success</code>事件和<code>error</code>事件，了解是否写入成功。</p>
<h2 id="3-4-读取数据"><a href="#3-4-读取数据" class="headerlink" title="3.4 读取数据"></a>3.4 读取数据</h2><p>读取数据也是通过事务完成。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">read</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> transaction = db.<span class="title function_">transaction</span>([<span class="string">&quot;person&quot;</span>]);</span><br><span class="line">  <span class="keyword">var</span> objectStore = transaction.<span class="title function_">objectStore</span>(<span class="string">&quot;person&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> request = objectStore.<span class="title function_">get</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  request.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;事务失败&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  request.<span class="property">onsuccess</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (request.<span class="property">result</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Name: &quot;</span> + request.<span class="property">result</span>.<span class="property">name</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Age: &quot;</span> + request.<span class="property">result</span>.<span class="property">age</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Email: &quot;</span> + request.<span class="property">result</span>.<span class="property">email</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;未获得数据记录&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">read</span>();</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>objectStore.get()</code>方法用于读取数据，参数是主键的值。</p>
<h2 id="3-5"><a href="#3-5" class="headerlink" title="3.5"></a>3.5</h2><p>遍历数据<br>遍历数据表格的所有记录，要使用指针对象 IDBCursor。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">readAll</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> objectStore = db.<span class="title function_">transaction</span>(<span class="string">&quot;person&quot;</span>).<span class="title function_">objectStore</span>(<span class="string">&quot;person&quot;</span>);</span><br><span class="line"></span><br><span class="line">  objectStore.<span class="title function_">openCursor</span>().<span class="property">onsuccess</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> cursor = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cursor) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Id: &quot;</span> + cursor.<span class="property">key</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Name: &quot;</span> + cursor.<span class="property">value</span>.<span class="property">name</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Age: &quot;</span> + cursor.<span class="property">value</span>.<span class="property">age</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Email: &quot;</span> + cursor.<span class="property">value</span>.<span class="property">email</span>);</span><br><span class="line">      cursor.<span class="title function_">continue</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;没有更多数据了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">readAll</span>();</span><br></pre></td></tr></table></figure>

<p>上面代码中，新建指针对象的<code>openCursor()</code>方法是一个异步操作，所以要监听<code>success</code>事件。</p>
<h2 id="3-6-更新数据"><a href="#3-6-更新数据" class="headerlink" title="3.6 更新数据"></a>3.6 更新数据</h2><p>更新数据要使用<code>IDBObject.put()</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> request = db</span><br><span class="line">    .<span class="title function_">transaction</span>([<span class="string">&quot;person&quot;</span>], <span class="string">&quot;readwrite&quot;</span>)</span><br><span class="line">    .<span class="title function_">objectStore</span>(<span class="string">&quot;person&quot;</span>)</span><br><span class="line">    .<span class="title function_">put</span>(&#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&quot;李四&quot;</span>, <span class="attr">age</span>: <span class="number">35</span>, <span class="attr">email</span>: <span class="string">&quot;lisi@example.com&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">  request.<span class="property">onsuccess</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;数据更新成功&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  request.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;数据更新失败&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">update</span>();</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>put()</code>方法自动更新了主键为 1 的记录。</p>
<h2 id="3-7-删除数据"><a href="#3-7-删除数据" class="headerlink" title="3.7 删除数据"></a>3.7 删除数据</h2><p><code>IDBObjectStore.delete()</code>方法用于删除记录。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">remove</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> request = db</span><br><span class="line">    .<span class="title function_">transaction</span>([<span class="string">&quot;person&quot;</span>], <span class="string">&quot;readwrite&quot;</span>)</span><br><span class="line">    .<span class="title function_">objectStore</span>(<span class="string">&quot;person&quot;</span>)</span><br><span class="line">    .<span class="title function_">delete</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  request.<span class="property">onsuccess</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;数据删除成功&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">remove</span>();</span><br></pre></td></tr></table></figure>

<h2 id="3-8-使用索引"><a href="#3-8-使用索引" class="headerlink" title="3.8 使用索引"></a>3.8 使用索引</h2><p>索引的意义在于，可以让你搜索任意字段，也就是说从任意字段拿到数据记录。如果不建立索引，默认只能搜索主键（即从主键取值）。</p>
<p>假定新建表格的时候，对 <code>name</code>字段建立了索引。</p>
<p><code>objectStore.createIndex(&#39;name&#39;, &#39;name&#39;, &#123; unique: false &#125;);</code><br>现在，就可以从 name 找到对应的数据记录了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> transaction = db.<span class="title function_">transaction</span>([<span class="string">&quot;person&quot;</span>], <span class="string">&quot;readonly&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> store = transaction.<span class="title function_">objectStore</span>(<span class="string">&quot;person&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> index = store.<span class="title function_">index</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> request = index.<span class="title function_">get</span>(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line"></span><br><span class="line">request.<span class="property">onsuccess</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = e.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">  <span class="keyword">if</span> (result) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>indexedDB</tag>
      </tags>
  </entry>
  <entry>
    <title>pnpm</title>
    <url>/2023/03/19/pnpm/</url>
    <content><![CDATA[<p>pnpm(performant npm) 通过软、硬链接（hark link、symbolic link） + 全局存储（store）结合的依赖管理方式完全实现了依赖树结构的包管理方式，解决了 npm3 及 yarn 中的幽灵依赖和 npm 分身的问题，提升了依赖包的安装速度，减小了磁盘空间占用。</p>
<span id="more"></span>

<h1 id="pnpm-为何节省空间"><a href="#pnpm-为何节省空间" class="headerlink" title="pnpm 为何节省空间"></a>pnpm 为何节省空间</h1><p>它解决了 npm&#x2F;yarn 平铺 node_modules 带来的依赖项重复的问题 (doppelgangers)</p>
<p>假设存在依赖依赖:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── package-a</span><br><span class="line">│   └── lodash@4.0.0</span><br><span class="line">├── package-b</span><br><span class="line">│   └── lodash@4.0.0</span><br><span class="line">├── package-c</span><br><span class="line">│   └── lodash@3.0.0</span><br><span class="line">└── package-d</span><br><span class="line">    └── lodash@3.0.0</span><br></pre></td></tr></table></figure>

<p>那么不可避免地在 npm 或者 yarn 中，<code>lodash@3.0.0</code> 会被多次安装，无疑造成了空间的浪费与诸多问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./node_modules/lodash</span><br><span class="line">./node_modules/package-a</span><br><span class="line">./node_modules/package-b</span><br><span class="line">./node_modules/package-c</span><br><span class="line">./node_modules/package-c/node_mdoules/lodash</span><br><span class="line">./node_modules/package-d</span><br><span class="line">./node_modules/package-d/node_mdoules/lodash</span><br></pre></td></tr></table></figure>

<p>这是一个较为常见的场景，在平时项目中有些库相同版本甚至会安装七八次，如 <code>postcss</code>、<code>ansi-styles</code>、<code>ansi-regex</code>、<code>braces</code> 等，可以去<code>yarn.lock/package-lock.json</code> 中搜索一下。</p>
<p>而在 pnpm 中，它改变了 npm&#x2F;yarn 的目录结构，采用<strong>软链接</strong>的方式，避免了 <code>doppelgangers</code> 问题更加节省空间。</p>
<p>它最终生成的 <code>node_modules</code> 如下所示，从中也可以看出它解决了<strong>幽灵依赖</strong>的问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./node_modules/package-a       -&gt;  .pnpm/package-a@1.0.0/node_modules/package-a</span><br><span class="line">./node_modules/package-b       -&gt;  .pnpm/package-b@1.0.0/node_modules/package-b</span><br><span class="line">./node_modules/package-c       -&gt;  .pnpm/package-c@1.0.0/node_modules/package-c</span><br><span class="line">./node_modules/package-d       -&gt;  .pnpm/package-d@1.0.0/node_modules/package-d</span><br><span class="line">./node_modules/.pnpm/lodash@3.0.0</span><br><span class="line">./node_modules/.pnpm/lodash@4.0.0</span><br><span class="line">./node_modules/.pnpm/package-a@1.0.0</span><br><span class="line">./node_modules/.pnpm/package-a@1.0.0/node_modules/package-a</span><br><span class="line">./node_modules/.pnpm/package-a@1.0.0/node_modules/lodash     -&gt; .pnpm/package-a@1.0.0/node_modules/lodash@4.0.0</span><br><span class="line">./node_modules/.pnpm/package-b@1.0.0</span><br><span class="line">./node_modules/.pnpm/package-b@1.0.0/node_modules/package-b</span><br><span class="line">./node_modules/.pnpm/package-b@1.0.0/node_modules/lodash     -&gt; .pnpm/package-b@1.0.0/node_modules/lodash@4.0.0</span><br><span class="line">./node_modules/.pnpm/package-c@1.0.0</span><br><span class="line">./node_modules/.pnpm/package-c@1.0.0/node_modules/package-c</span><br><span class="line">./node_modules/.pnpm/package-c@1.0.0/node_modules/lodash     -&gt; .pnpm/package-c@1.0.0/node_modules/lodash@3.0.0</span><br><span class="line">./node_modules/.pnpm/package-d@1.0.0</span><br><span class="line">./node_modules/.pnpm/package-d@1.0.0/node_modules/package-d</span><br><span class="line">./node_modules/.pnpm/package-d@1.0.0/node_modules/lodash     -&gt; .pnpm/package-d@1.0.0/node_modules/lodash@3.0.0</span><br></pre></td></tr></table></figure>

<p>如此，依赖软链接的方式，可解决重复依赖安装 (doppelgangers) 的问题，<strong>如果一个项目占用 1000 MB，那么使用 pnpm 可能仅占用 800 MB</strong></p>
<p>然而它除此之外，还有一个最大的好处，<strong>如果一个项目占用 1000 MB，传统方式十个项目占用 10000 MB，那么使用 pnpm 可能仅占用 3000 MB，而它得益于硬链接。</strong></p>
<p>再借用以上示例，<code>lodash@3.0.0</code> 与 <code>lodash@4.0.0</code> 会生成一个指向全局目录(<code>~/.pnpm-store</code>)的硬链接，如果新项目依赖二者，则可复用存储空间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./node_modules/.pnpm/lodash@3.0.0/node_modules/lodash   -&gt; hardlink</span><br><span class="line">./node_modules/.pnpm/lodash@4.0.0/node_modules/lodash   -&gt; hardlink</span><br></pre></td></tr></table></figure>

<h1 id="pnpm、yarn、npm-的区别"><a href="#pnpm、yarn、npm-的区别" class="headerlink" title="pnpm、yarn、npm 的区别"></a>pnpm、yarn、npm 的区别</h1><table>
<thead>
<tr>
<th>功能</th>
<th>pnpm</th>
<th>yarn</th>
<th>npm</th>
</tr>
</thead>
<tbody><tr>
<td>工作空间支持（monorepo）</td>
<td>O</td>
<td>O</td>
<td>O</td>
</tr>
<tr>
<td>隔离的 node_modules</td>
<td>O-默认</td>
<td>O</td>
<td>O</td>
</tr>
<tr>
<td>提升的 node_modules</td>
<td>O</td>
<td>O</td>
<td>O-默认</td>
</tr>
<tr>
<td>自动安装 peers</td>
<td>O</td>
<td>X</td>
<td>O</td>
</tr>
<tr>
<td>Plug’n’Play</td>
<td>O</td>
<td>O-默认</td>
<td>X</td>
</tr>
<tr>
<td>零安装</td>
<td>X</td>
<td>O</td>
<td>X</td>
</tr>
<tr>
<td>修补依赖项</td>
<td>O</td>
<td>O</td>
<td>X</td>
</tr>
<tr>
<td>管理 Node.js 版本</td>
<td>O</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>有锁文件</td>
<td>O-pnpm-lock.yaml</td>
<td>O-yarn.lock</td>
<td>O-package-lock.json</td>
</tr>
<tr>
<td>支持覆盖</td>
<td>O</td>
<td>O-通过 resolutions</td>
<td>O</td>
</tr>
<tr>
<td>内容可寻址存储</td>
<td>O</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>动态包执行</td>
<td>O-通过 pnpm dlx</td>
<td>O-通过 yarn dlx</td>
<td>O-通过 npx</td>
</tr>
<tr>
<td>Side-effects cache</td>
<td>O</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>Listing License</td>
<td>O-Vua pnpm licenses list</td>
<td>O-Via a plugin</td>
<td>X</td>
</tr>
</tbody></table>
<h1 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install -g pnpm</span><br><span class="line"></span><br><span class="line">pnpm -v</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">pnpm init</span><br><span class="line">pnpm install xxx</span><br><span class="line">pnpm run xxx</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置源</span></span><br><span class="line">pnpm config get registry</span><br><span class="line">pnpm config set registry &lt;淘宝源或其他源地址&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//管理依赖</span></span><br><span class="line">pnpm add xxx</span><br><span class="line">pnpm add -D xxx <span class="comment">//安装到devDependencies</span></span><br><span class="line">pnpm add -O xxx <span class="comment">//安装到optionalDependencies</span></span><br><span class="line">pnpm add -g xx <span class="comment">//全局安装依赖包</span></span><br><span class="line">pnpm install 或(pnpm i)</span><br><span class="line">pnpm update 或( pnpm up)</span><br><span class="line">pnpm remove 或(pnpm rm/uninstall/un)</span><br></pre></td></tr></table></figure>

<h2 id="查看依赖"><a href="#查看依赖" class="headerlink" title="查看依赖"></a>查看依赖</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pnpm list 或(pnpm ls)</span><br><span class="line">pnpm list --<span class="variable language_">global</span> 或(pnpm ls --g)</span><br><span class="line">pnpm outdated <span class="comment">//检查过期的依赖</span></span><br></pre></td></tr></table></figure>

<h2 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pnpm run xxx 或（pnpm xxx）</span><br><span class="line">pnpm test 运行test测试脚本</span><br><span class="line">pnpm create</span><br><span class="line">pnpm start</span><br></pre></td></tr></table></figure>

<h2 id="包存储-store"><a href="#包存储-store" class="headerlink" title="包存储 store"></a>包存储 store</h2><p>pnpm store: pnpm 资源在磁盘上的存储空间</p>
<p>可以通过 <code>pnpm store path</code>命令查看 store 存储目录的路径</p>
<p>在项目中执行<code>pnpm install</code>的时候，依赖包存在于 store 中，直接创建依赖包硬链接到 store 中，如果不存在，则从远程下载后存储在 store 中，并从项目的 node_modules 依赖包中创建硬链接到 store 中。</p>
<p><code>pnpm store prune</code>，从存储中删除未引用的包。</p>
<h2 id="workspce-协议"><a href="#workspce-协议" class="headerlink" title="workspce 协议"></a>workspce 协议</h2><blockquote>
<p>workspce:工作空间</p>
</blockquote>
<p><code>workspace:*</code>协议，表示依赖的就一直是本地的包，而不是从<code>npm registry</code>安装的包。</p>
<h3 id="别名引用"><a href="#别名引用" class="headerlink" title="别名引用"></a>别名引用</h3><p>假如工作区有一个名为 foo 的包，可以通过这样引用 <code>&quot;foo&quot;: &quot;workspace:&quot;</code>，如果是其它别名，可以这么引用：<code>&quot;bar&quot;: &quot;workspace:foo@*&quot;</code>。</p>
<h3 id="相对引用"><a href="#相对引用" class="headerlink" title="相对引用"></a>相对引用</h3><p>假如 packages 下有同层级的 foo、bar，其中 bar 依赖于 foo，则可以写作<code>&quot;bar&quot;: &quot;workspace:../foo&quot;</code>。</p>
<h3 id="发布-workspace-包"><a href="#发布-workspace-包" class="headerlink" title="发布 workspace 包"></a>发布 workspace 包</h3><p>当 workspace 包打包发布时，将会动态替换这些 workspace:依赖。</p>
<h1 id="npm-或-Yarn-转-pnpm"><a href="#npm-或-Yarn-转-pnpm" class="headerlink" title="npm 或 Yarn 转 pnpm"></a>npm 或 Yarn 转 pnpm</h1><p>操作步骤：</p>
<ol>
<li>全局安装 pnpm</li>
</ol>
<p><code>npm install -g pnpm</code></p>
<ol start="2">
<li>删除 npm 或 yarn 生成的 node_modules</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 项目目录下运行或手动物理删除</span><br><span class="line">rm -rf node_modules</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>pnpm import 从其他软件包管理器的 lock 文件生成  pnpm-lock.yaml，再执行 <code>pnpm install --frozen-lockfile</code>（相当于 npm ci）生成依赖，防止没有 lock 文件意外升级依赖包，导致项目出错</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 生成`pnpm-lock.yaml`</span><br><span class="line">pnpm import</span><br><span class="line"></span><br><span class="line"># 安装依赖</span><br><span class="line">pnpm install --frozen-lockfile</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>删除 npm 或 yarn 生成的 lock 文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 删除 package-lock.json</span><br><span class="line">rm -rf package-lock.json</span><br><span class="line"></span><br><span class="line"># 删除 yarn.lock</span><br><span class="line">rm -rf yarn.lock</span><br></pre></td></tr></table></figure>

<p>项目中的 npm 命令等修改为 pnpm，包括 README 文档、运行命令等</p>
<p><a href="https://juejin.cn/post/7124142007659790372">参考链接</a></p>
]]></content>
      <tags>
        <tag>pnpm</tag>
      </tags>
  </entry>
  <entry>
    <title>React 组件的编写</title>
    <url>/2022/03/08/react-components/</url>
    <content><![CDATA[<p>在编写 React 组件时，有一些最佳实践需要遵循：</p>
<span id="more"></span>

<h1 id="单一职责"><a href="#单一职责" class="headerlink" title="单一职责"></a>单一职责</h1><p>就像函数一样，组件也应当遵循单一职责的原则，即每个组件只能负责一个功能。请阅读<a href="https://zh-hans.reactjs.org/docs/thinking-in-react.html#step-1-break-the-ui-into-a-component-hierarchy">官方示例中的第一步</a>。</p>
<p>将一个功能复杂的大组件拆分为多个职责单一的小组件可以获得以下好处：</p>
<ol>
<li>可读性和可维护性的提升：小组件代码更短，且服务于同一目的；读者可以按层级理解代码。</li>
<li>可测试性的提升：小组件更容易做单元测试。</li>
<li>可复用性的提升：小组件可以在简单的调整和提取后被复用于其他场景。</li>
<li>性能的提升：state 的变化不再总是触发整个大组件的重渲染。</li>
</ol>
<h1 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h1><p>拆分组件时在文件结构上的最佳实践是，假设原来有一个大组件是 Complex.tsx，拆分后它应变成一个文件夹：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- Complex</span><br><span class="line">  - index.tsx // 简化后的大组件</span><br><span class="line">  - SubA.tsx // 拆分出来的小组件</span><br><span class="line">  - SubB.tsx // 拆分出来的小组件</span><br></pre></td></tr></table></figure>

<h1 id="State-最小集"><a href="#State-最小集" class="headerlink" title="State 最小集"></a>State 最小集</h1><p>渲染组件所需要的数据有以下来源：外部传入的 prop、组件内部的 state、全局 state（比如 redux store）、组件 scope 外的常量，以及由前面这些基础数据计算得到的间接数据（即 Vue 中的 computed）。</p>
<p>新人易犯的错误是将间接数据作为 state 来维护，然后用 <code>useEffect</code> 去监听其他 state&#x2F;prop 并重新计算该数据。</p>
<p>组件内部 state 应是一个最小集，不包含任何间接数据或常量。请阅读<a href="https://zh-hans.react.dev/learn/thinking-in-react#step-3-identify-the-minimal-but-complete-representation-of-ui-state">官方示例中的第三步</a>。</p>
<h1 id="Prop-的设计"><a href="#Prop-的设计" class="headerlink" title="Prop 的设计"></a>Prop 的设计</h1><p>Prop 的设计应尽量从组件本身的需求出发，而不是套用父组件已有的数据和方法。举例来说：</p>
<ol>
<li>如果子组件需要的数据 c 是由父组件中的 a 和 b 计算而来的，那么应该为 c 设计一个 prop，在父组件中用 a 和 b 计算出 c 之后传给子组件，而不是为 a 和 b 设计两个 prop，在子组件内部再计算 c。这一条原则也可以理解为 prop 最小集。</li>
<li>如果子组件需要反向传递数据去设置父组件的 state（假设要传递的数据是 date），不要设计一个 setDate prop 然后把父组件的 setDate 直接传给子组件，而是设计一个 onDateChange prop，允许父组件设置一个 callback 去监听子组件的 date 变化。子组件不关心父组件是要 setDate 还是做什么，子组件只负责“广播”自己的数据变化“事件”。</li>
</ol>
<h1 id="组件内的代码组织"><a href="#组件内的代码组织" class="headerlink" title="组件内的代码组织"></a>组件内的代码组织</h1><p>目前我们统一用 React hooks 编写组件，hooks 的一大优势就是允许我们将组件内的代码按业务逻辑而非性质分组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Bad</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// states</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [state1, setState1] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [state2, setState2] = <span class="title function_">useState</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// computed</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> computed1 = state1 + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> computed2 = !state2;</span><br><span class="line">  <span class="keyword">const</span> computed3 = <span class="string">`<span class="subst">$&#123;computed1&#125;</span> <span class="subst">$&#123;computed2&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// side effects</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">sideEffect1</span>();</span><br><span class="line">    <span class="title function_">sideEffect2</span>();</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Good</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// logic group 1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [state1, setState1] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> computed1 = state1 + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">sideEffect1</span>();</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// logic group 2</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [state2, setState2] = <span class="title function_">useState</span>(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">const</span> computed2 = !state2;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">sideEffect2</span>();</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// logic group 3</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> computed3 = <span class="string">`<span class="subst">$&#123;computed1&#125;</span> <span class="subst">$&#123;computed2&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果组件中有很多个逻辑分组，可能就是该组件需要进一步拆分的信号。</p>
<h1 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h1><p>当一个组件树中有很多不同层级的组件需要访问一批同样的数据时，完全用 prop 传递会导致中间层的组件为了往下传递而多出很多它自己并不关心的 prop，此时你通常需要 context 解决方案，请阅读<a href="https://zh-hans.legacy.reactjs.org/docs/context.html">官方文档</a>。</p>
<p>当需要层层传递的数据本身非常简单时，也有<a href="https://zh-hans.legacy.reactjs.org/docs/context.html#before-you-use-context">除了 context 之外的解决方案</a>。</p>
<h1 id="表现与逻辑的分离"><a href="#表现与逻辑的分离" class="headerlink" title="表现与逻辑的分离"></a>表现与逻辑的分离</h1><p>组件主要负责表现层（即 UI 层）的逻辑，因此复杂的数据处理逻辑原则上不属于组件的职责，应提取为工具函数而不是直接放一大段代码在组件内。这个职责分离的原则与上文组件拆分的原则在本质上是一致的，即每个单元应负责自己唯一的职责。</p>
]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>service worker</title>
    <url>/2023/02/19/service-worker/</url>
    <content><![CDATA[<p>了解 service work 前先了解一下 PWA，那么什么是 PWA 呢？</p>
<span id="more"></span>

<p><strong>渐进式网路应用 PWA</strong></p>
<ol>
<li>Web 应用和 Native 应用有着各自不同的优势和使用场景</li>
<li>PWA 结合了二者的优势</li>
<li>PWA 会越来越流行<blockquote>
<ul>
<li>Web 应用的资源存储在服务器，Native 的资源存储在本地。所以 Native 会比 Web 应用的加载速度和流畅性方面获得更好地表现；</li>
<li>PWA 旨在创造拥有更加流畅的用户体验的 Web 应用，和创建类 Native App 的沉浸式效果，而非浏览器端那样的外观和体验；</li>
<li>在各种网络和数据加载的条件下仍然可用－它可以在网络不稳定或者没有网络的情况下使用。</li>
</ul>
</blockquote>
</li>
</ol>
<h1 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h1><p>Service Worker 是 PWA 的关键技术，可以支持一些原始应用的功能</p>
<ul>
<li>友好的弱网和离线体验</li>
<li>定期的后台同步</li>
<li>推送通知</li>
</ul>
<p>Service workers  本质上充当 Web 应用程序、浏览器与网络（可用时）之间的代理服务器。</p>
<p>1.友好的弱网和离线体验<br>这个 API 旨在创建有效的离线体验，它会拦截网络请求并根据网络是否可用来采取适当的动作、更新来自服务器的的资源。它还提供入口以推送通知和访问后台同步 API。</p>
<h2 id="web-worker"><a href="#web-worker" class="headerlink" title="web worker"></a>web worker</h2><ul>
<li>JavaScript 是一个单线程的语言；</li>
<li>异步编程通过调度一部分代码在 <code>event loop</code> 中执行，从而让程序流畅地运行；</li>
<li>Web Workers 是真正的多线程</li>
<li>Service Worker 是 Web Worker 的一个子类</li>
</ul>
<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><ul>
<li>它是一种 Web worker，不能直接访问 DOM</li>
<li>它有自己独立的生命周期，不和特定网页相关联</li>
<li>是一个由事件驱动的 worker，它由源和路径组成</li>
<li>可以使用一些离线存储 API — Cache Storage 和 IndexedDB, 不能访问 localStorage</li>
<li>大量使用了 Promise</li>
<li>只能使用 HTTPS，localhost 也被允许</li>
</ul>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><ul>
<li>Service Worker 的生命周期和网页是相互独立的</li>
</ul>
<ul>
<li>在网页的 JS 代码中调用 Service Worker 的注册方法开始安装。在安装阶段可以进行一些缓存工作，缓存失败安装就会失败。如果安装成功，代表了缓存也成功完成了</li>
<li>安装成功后触发 activate 事件，Service Worker 处于激活状态</li>
<li>激活后的 Service Worker 线程可以控制页面、监听事件了，它可以根据情况被中止或者唤起</li>
</ul>
<h1 id="基本功能和用法"><a href="#基本功能和用法" class="headerlink" title="基本功能和用法"></a>基本功能和用法</h1><ul>
<li>install 事件会在注册完成之后触发。install 事件一般是被用来填充你的浏览器的离线缓存能力。</li>
</ul>
<p>为了达成这个目的，我们使用了 Service Worker 的新的标志性的存储 API — <strong>cache</strong> — 一个 service worker 上的全局对象，它使我们可以存储网络响应发来的资源，并且根据它们的请求来生成 key。<br>在安装事件的回调里我们需要完成一些缓存的工作，所以需要 <code>waitUntil()</code> 方法来暂时挂起代码，waitUntil 方法接受一个<code>promise</code>。</p>
<h2 id="使用-Cache-API-缓存资源"><a href="#使用-Cache-API-缓存资源" class="headerlink" title="使用 Cache API 缓存资源"></a>使用 Cache API 缓存资源</h2><p>Cache 接口为缓存的 <code>Request / Response</code> 对象对提供存储机制</p>
<p>一个域可以有多个命名 Cache 对象。</p>
<p>你需要在你的脚本 (例如，在 ServiceWorker 中)中处理缓存更新的方式。除非明确地更新缓存，否则缓存将不会被更新；除非删除，否则缓存数据不会过期。</p>
<p><code>CacheStorage</code> 接口表示 Cache 对象存储。</p>
<p>使用通过全局 caches 属性来访问 CacheStorage，可以在 window、Service Worker 中访问。</p>
<p><code>window.caches // CacheStorage&#123;&#125;</code></p>
<p>使用 <code>CacheStorage.open(cacheName)</code> 打开一个 Cache 对象，再使用 Cache 对象的方法去处理缓存。</p>
<blockquote>
<p>activate 事件在脚本激活后触发，一般在这里处理旧版本的缓存<br>fetch 事件监听客户端的请求，包括任何被 service worker 控制的文档和文档内引用的资源。配合 respondWith()  方法，可以劫持 HTTP 响应</p>
</blockquote>
<hr>
<ul>
<li><p>CacheStorage.open()</p>
</li>
<li><p>CacheStorage.keys()</p>
</li>
<li><p>CacheStorage.match()</p>
</li>
<li><p>Cache.addAll(requests)</p>
</li>
<li><p>Cache.add(request)</p>
</li>
<li><p>Cache.put(request,response)</p>
</li>
<li><p>Cache.match(request)</p>
</li>
<li><p>Cache.delete(request)</p>
</li>
</ul>
<h2 id="在-install-阶段缓存资源"><a href="#在-install-阶段缓存资源" class="headerlink" title="在 install 阶段缓存资源"></a>在 install 阶段缓存资源</h2><ul>
<li>打开缓存</li>
<li>缓存文件</li>
<li>确认是否所有的静态资源已缓存</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">self.<span class="title function_">addEventListener</span>(<span class="string">&quot;install&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  event.<span class="title function_">waitUntil</span>(</span><br><span class="line">    caches.<span class="title function_">open</span>(<span class="variable constant_">CACHE_NAME</span>).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">cache</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Opened cache&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> cache.<span class="title function_">addAll</span>(urlsToCache);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="缓存运行时请求"><a href="#缓存运行时请求" class="headerlink" title="缓存运行时请求"></a>缓存运行时请求</h2><ul>
<li>event.respondWith() 会决定如何响应 fetch 事件。 caches.match() 查询请求及查找之前创建的缓存中是否有任意缓存结果并返回 promise。</li>
<li>如果有，则返回该缓存数据。</li>
<li>否则，执行 fetch 。</li>
<li>检查返回的状态码是否是 200。同时检查响应类型是否为 basic，即检查请求是否同域。当前场景不缓存第三方资源的请求。</li>
<li>把返回数据添加到缓存中。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">self.<span class="title function_">addEventListener</span>(<span class="string">&quot;fetch&quot;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  event.<span class="title function_">respondWith</span>(</span><br><span class="line">    caches.<span class="title function_">match</span>(event.<span class="property">request</span>).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (response) &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//复制请求。请求是一个流且只能被使用一次。因为之前已经通过缓存使用过一次了，所以为了在浏览器中使用fetch，需要复制下该请求。</span></span><br><span class="line">      <span class="keyword">var</span> fetchRequest = event.<span class="property">request</span>.<span class="title function_">clone</span>();</span><br><span class="line">      <span class="comment">//没有找到缓存。所以我们需要执行 fetch 以发起请求并返回请求数据。</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">fetch</span>(fetchRequest).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">        <span class="comment">//检测返回数据是否有效</span></span><br><span class="line">        <span class="keyword">if</span> (!response || response.<span class="property">status</span> !== <span class="number">200</span> || response.<span class="property">type</span> !== <span class="string">&quot;basic&quot;</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//复制返回数据，因为它也是流。因为我们想要浏览器和缓存一样使用返回数据，所以必须复制它。这样就有两个流</span></span><br><span class="line">        <span class="keyword">var</span> responseToCache = response.<span class="title function_">clone</span>();</span><br><span class="line">        caches,</span><br><span class="line">          <span class="title function_">open</span>(<span class="variable constant_">CACHE_NAME</span>).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">cache</span>) &#123;</span><br><span class="line">            <span class="comment">//把请求添加到缓存中以备之后的查询用</span></span><br><span class="line">            cache.<span class="title function_">put</span>(event.<span class="property">request</span>, responseToCache);</span><br><span class="line">          &#125;);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="更新-Service-Worker"><a href="#更新-Service-Worker" class="headerlink" title="更新 Service Worker"></a>更新 Service Worker</h2><p>当用户访问网络应用的时候，浏览器会在后台重新下载包含 Service Worker 代码的  .js  文件。<br>如果下载下来的文件和当前的 Service Worker 代码文件不同，浏览器会认为文件发生了改变并且会创建一个新的 Service Worker。</p>
<p>创建新的 Service Worker 的过程将会启动，然后触发  install  事件。然而，这时候，旧的 Service Worker 仍然控制着网络应用的页面意即新的 Service Worker 将会处于  waiting  状态。</p>
<p>一旦关闭网络应用当前打开的页面，旧的 Service Worker 将会被浏览器杀死而新安装的 Service Worker 就可以上位了。这时候将会触发  activate  事件。</p>
<p>这是为了避免在不同选项卡中同时运行不同版本的的网络应用所造成的问题－<br>一些在网页中实际存在的问题且有可能会产生新的 bug（比如当在浏览器中本地存储数据的时候却拥有不同的数据库结构）。</p>
<h2 id="在-activate-阶段清理旧版本的缓存"><a href="#在-activate-阶段清理旧版本的缓存" class="headerlink" title="在 activate 阶段清理旧版本的缓存"></a>在 activate 阶段清理旧版本的缓存</h2><p>出现在 activate 回调中的一个常见任务是缓存管理。</p>
<p>这么做的原因是，如果在安装步骤中清除了任何旧缓存，则继续控制所有当前页面的任何旧 Service Worker 将突然无法从缓存中提供文件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//清除了旧版本的缓存</span></span><br><span class="line">self.<span class="title function_">addEventListener</span>(<span class="string">&quot;activate&quot;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  event.<span class="title function_">waitUntil</span>(</span><br><span class="line">    caches.<span class="title function_">keys</span>().<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">cacheNames</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(</span><br><span class="line">        cacheNames.<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">cacheName</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!expectedCaches.<span class="title function_">includes</span>(cacheNames)) &#123;</span><br><span class="line">            <span class="keyword">return</span> caches.<span class="title function_">delete</span>(key);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="如何在浏览器里面进行调试"><a href="#如何在浏览器里面进行调试" class="headerlink" title="如何在浏览器里面进行调试"></a>如何在浏览器里面进行调试</h1><h2 id="Update-on-reload"><a href="#Update-on-reload" class="headerlink" title="Update on reload"></a>Update on reload</h2><ul>
<li>重新提取 Service Worker。</li>
<li>即使字节完全相同，也将其作为新版本安装，这表示运行  install  事件并更新缓存。</li>
<li>跳过等待阶段，以激活新 Service Worker。</li>
<li>浏览页面。这意味着每次浏览时（包括刷新）都将进行更新，无需重新加载两次或关闭标签。</li>
</ul>
<h2 id="Offline-可以离线应用"><a href="#Offline-可以离线应用" class="headerlink" title="Offline 可以离线应用"></a>Offline 可以离线应用</h2><h2 id="Bypass-for-network-可以绕过-Service-Worker-的控制"><a href="#Bypass-for-network-可以绕过-Service-Worker-的控制" class="headerlink" title="Bypass for network 可以绕过 Service Worker 的控制"></a>Bypass for network 可以绕过 Service Worker 的控制</h2><p>Disable cache 选项不会影响 Service Worker 的缓存；<br>⌘ + ⇧ + R 强制刷新，会跳过 Service Worker 的控制；</p>
<p>打开 <code>chrome://inspect/#service-workers</code> 管理浏览器中的 Service Worker</p>
<p>参考资料：<br><a href="https://github.com/ChangbaFE/presentation">ChangbaFE&#x2F;presentation</a></p>
]]></content>
  </entry>
  <entry>
    <title>sleep 函数</title>
    <url>/2020/12/18/sleep-function/</url>
    <content><![CDATA[<p>JS 没有语言内置的休眠（sleep or wait）函数，所谓的 sleep 只是实现一种延迟执行的效果</p>
<p>等待指定时间后再执行对应方法</p>
<span id="more"></span>

<h2 id="方法一：伪死循环阻塞主线程"><a href="#方法一：伪死循环阻塞主线程" class="headerlink" title="方法一：伪死循环阻塞主线程"></a>方法一：伪死循环阻塞主线程</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 因为JS是单线程的，所以通过这种方式可以实现真正意义上的sleep</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sleep1</span>(<span class="params">fn, time</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> start = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>() - start &lt; time) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">fn</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方式二：-定时器"><a href="#方式二：-定时器" class="headerlink" title="方式二： 定时器"></a>方式二： 定时器</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sleep2</span>(<span class="params">fn, time</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(fn, time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方式三：promise"><a href="#方式三：promise" class="headerlink" title="方式三：promise"></a>方式三：promise</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function sleep3(fn, time) &#123;</span><br><span class="line">  new Promise(resolve =&gt; &#123;</span><br><span class="line">    setTimeout(resolve, time);</span><br><span class="line">  &#125;).then(() =&gt; &#123;</span><br><span class="line">    fn();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="方式四：async-await"><a href="#方式四：async-await" class="headerlink" title="方式四：async await"></a>方式四：async await</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">sleep4</span>(<span class="params">fn, time</span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, time);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="title function_">fn</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fn&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sleep1</span>(fn, <span class="number">2000</span>);</span><br><span class="line"><span class="title function_">sleep2</span>(fn, <span class="number">2000</span>);</span><br><span class="line"><span class="title function_">sleep3</span>(fn, <span class="number">2000</span>);</span><br><span class="line"><span class="title function_">sleep4</span>(fn, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>强缓存和协商缓存</title>
    <url>/2020/02/20/strong-cache/</url>
    <content><![CDATA[<h1 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h1><p>所谓强缓存，可以理解为强制缓存的意思，即<strong>浏览器在访问某个资源时会判断是否使用本地缓存里已经存在的资源文件，使用本地缓存的话则不会发送请求到服务器，从而达到减轻服务器访问压力的作用</strong>，且由于直接从本地缓存读取资源文件，大大提高了加载速度。</p>
<span id="more"></span>

<h2 id="强缓存的具体流程为："><a href="#强缓存的具体流程为：" class="headerlink" title="强缓存的具体流程为："></a>强缓存的具体流程为：</h2><p>浏览器第一次请求远程服务器的某个资源时，如果服务器希望浏览器得到该资源后一段时间内不要再发送请求过来，直接从浏览器里的缓存里取，则服务器可以通过在响应头里设置 <code>Cache-Control: max-age=31536000</code>，<code>max-age</code> 代表缓存时间，单位为秒，这里的数据换算过来就是一年，意味着在一年内浏览器不会再向服务器发送请求。</p>
<img src="/2020/02/20/strong-cache/max-age.png" class title="max-age">

<p>使用缓存的话，状态码 200 后面会标明情况。浏览器缓存资源的地方有两个：磁盘缓存（disk cache）和内存缓存（memory cache）。</p>
<p>Cache-Control 除了 max-age 外，还可以设置其它属性值：</p>
<ul>
<li>no-cache: 不使用强缓存（但仍会使用协商缓存）。</li>
<li>no-store: 不使用缓存（不使用强缓存也不使用协商缓存），每次都向服务器发送资源请求。</li>
<li>private： 只允许客户端使用缓存，不允许其他代理服务器进行缓存。</li>
<li>public: 客户端和代理服务器都可缓存。</li>
<li>s-maxage: 与 max-age 类似，区别是 s-maxage 是设定代理服务器的缓存时间。</li>
</ul>
<p>强缓存除了使用<code>Cache-Control</code>实现之外，还可以使用<code>Expires</code>字段，<code>Expires</code>是 Http1.0 规范，<code>Cache-Control</code>是 Http1.1 规范，<code>Expires</code>返回一个具体的时间值（如下图所示），代表缓存的有效期，在该日期内浏览器不会向服务器发起请求，而是直接从缓存里获取资源。</p>
<p>因为 Expires 参照的是本地客户端的时间，而客户端的时间是可以被修改的，所以会有误差产生的情况，这也是 Expires 的一个缺点，所以有了后来 Http1.1 规范的 Cache-control。<br>另外，Cache-control 的优先级要高于 Expires，如果两者同时设置，会优先使用 Cache-control 而忽略掉 Expires。</p>
<h1 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h1><p>在强缓存里，是否使用缓存是由浏览器来确定的，而协商缓存则是由<strong>服务器来告诉浏览器是否使用缓存资源，也就是浏览器每一次都要发送请求到服务器询问是否使用缓存</strong>，协商缓存的具体流程如下：</p>
<p>浏览器初次请求资源，服务器返回资源，同时生成一个<code>Etag</code>值携带在响应头里返回给浏览器，当浏览器再次请求资源时会在请求头里携带<code>If-None-Match</code>，值是之前服务器返回的<code>Etag</code>的值，服务器收到之后拿该值与资源文件最新的<code>Etag</code>值做对比。</p>
<ul>
<li>如果没有变化则返回 304，告诉浏览器继续使用缓存（不返回资源文件）。</li>
<li>如果发生变化，则返回 200 和最新的资源文件给浏览器使用。</li>
</ul>
<p>除了 Etag 外，还有一个 <code>Last-Modified</code> 的属性，它是 Http1.0 规范的，服务器返回 Last-Modified，浏览器请求头对应携带的是 <code>If-Modified-since</code>，与 Etag 不同的是，<code>Last-Modified</code> 的值是一个时间值，代表文件的修改时间，服务器通过对比文件的修改时间是否发生改变来判断是否使用缓存。</p>
<p>相比 <code>Last-Modified</code>，Etag 优先级更高，使用上也更精确一些，因为有时候会存在文件内容并没有改变，但文件的修改时间变更了，<code>Last-Modified</code> 不一致所以服务器会重新返回资源文件，实际上还是可以继续使用缓存的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>强缓存就是浏览器本地根据服务器设置的过期时间来判断是否使用缓存，未过期则从本地缓存里拿资源，已过期则重新请求服务器获取最新资源。</p>
<p>协商缓存则是浏览器本地每次都向服务器发起请求，由服务器来告诉浏览器是从缓存里拿资源还是返回最新资源给浏览器使用。</p>
<p><a href="https://juejin.cn/post/7259298281578889273">参考链接</a></p>
]]></content>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>todo</title>
    <url>/2019/12/18/todo/</url>
    <content><![CDATA[<span id="more"></span>

<p>图片标注<br>immer&#x2F;immutable<br>graphql&#x2F;node<br>navigator.online(rel)</p>
<h1 id="npm-package"><a href="#npm-package" class="headerlink" title="npm package"></a>npm package</h1><ul>
<li>包和模块的区别</li>
<li>如何避免业务项目被发布到 npm</li>
</ul>
<h1 id="monorepo"><a href="#monorepo" class="headerlink" title="monorepo"></a>monorepo</h1><p>ElectronJS</p>
<p>Hybrid</p>
<p>webpack、babel、postcss 等</p>
<p>taiwind</p>
<p>react 18</p>
<p>bff 层</p>
]]></content>
  </entry>
  <entry>
    <title>前端文件流、切片下载和上传</title>
    <url>/2023/12/22/upload-big-file/</url>
    <content><![CDATA[<h1 id="一、前端文件流操作"><a href="#一、前端文件流操作" class="headerlink" title="一、前端文件流操作"></a>一、前端文件流操作</h1><p>下面创建一个 <code>fileUpload</code> 的函数式组件，当用户选择文件时，通过<code>FileReader</code>将文件内容读取为 <code>ArrayButter</code>,然后将<code>ArrayBuffer</code>转换为十六进制字符串，并将结果显示在页面上。</p>
<span id="more"></span>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">FileInput</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [fileContent, setFileContent] = <span class="title function_">useState</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取文件内容到ArrayBuffer</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">readFileToArrayBuffer</span>(<span class="params">file</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 注册文件读取完成后的回调函数</span></span><br><span class="line">      reader.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> arrayBuffer = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">        <span class="title function_">resolve</span>(arrayBuffer);</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 读取文件内容到ArrayBuffer</span></span><br><span class="line">      reader.<span class="title function_">readAsArrayBuffer</span>(file);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将ArrayBuffer转为十六进制字符串</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">arrayBufferToHexString</span>(<span class="params">arrayBuffer</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> uint8Array = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(arrayBuffer);</span><br><span class="line">    <span class="keyword">let</span> hexString = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; uint8Array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> hex = uint8Array[i].<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">padStart</span>(<span class="number">2</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">      hexString += hex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hexString;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理文件选择事件</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleFileChange</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> file = event.<span class="property">target</span>.<span class="property">files</span>[<span class="number">0</span>]; <span class="comment">// 获取选中的文件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file) &#123;</span><br><span class="line">      <span class="title function_">readFileToArrayBuffer</span>(file)</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">(<span class="params">arrayBuffer</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> hexString = <span class="title function_">arrayBufferToHexString</span>(arrayBuffer);</span><br><span class="line">          <span class="title function_">setFileContent</span>(hexString);</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;文件读取失败:&quot;</span>, error);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">setFileContent</span>(<span class="string">&quot;请选择一个文件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">onChange</span>=<span class="string">&#123;handleFileChange&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h4</span>&gt;</span>文件内容：<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">pre</span>&gt;</span>&#123;fileContent&#125;<span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">FileInput</span>;</span><br></pre></td></tr></table></figure>

<h1 id="二、文件切片下载"><a href="#二、文件切片下载" class="headerlink" title="二、文件切片下载"></a>二、文件切片下载</h1><p>文件切片下载的好处：</p>
<ul>
<li>快速启动：客户端可以快速开始下载，因为只需要下载第一个切片即可。</li>
<li>并发下载：通过使用多个并发请求下载切片，可以充分利用带宽，并提高整体下载速度。</li>
<li>断点续传：如果下载中断，客户端只需要重新下载中断的切片，而不需要重新下载整个文件。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [selectedFile, setSelectedFile] = <span class="title function_">useState</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">const</span> [progress, setProgress] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 处理文件选择事件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleFileChange</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="title function_">setSelectedFile</span>(event.<span class="property">target</span>.<span class="property">files</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理文件上传事件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleFileUpload</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (selectedFile) &#123;</span><br><span class="line">    <span class="comment">// 计算切片数量和每个切片的大小</span></span><br><span class="line">    <span class="keyword">const</span> fileSize = selectedFile.<span class="property">size</span>;</span><br><span class="line">    <span class="keyword">const</span> chunkSize = <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// 设置切片大小为1MB</span></span><br><span class="line">    <span class="keyword">const</span> totalChunks = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(fileSize / chunkSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建FormData对象，并添加文件信息</span></span><br><span class="line">    <span class="keyword">const</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">    formData.<span class="title function_">append</span>(<span class="string">&quot;file&quot;</span>, selectedFile);</span><br><span class="line">    formData.<span class="title function_">append</span>(<span class="string">&quot;totalChunks&quot;</span>, totalChunks);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环上传切片</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> chunkNumber = <span class="number">0</span>; chunkNumber &lt; totalChunks; chunkNumber++) &#123;</span><br><span class="line">      <span class="keyword">const</span> start = chunkNumber * chunkSize;</span><br><span class="line">      <span class="keyword">const</span> end = <span class="title class_">Math</span>.<span class="title function_">min</span>(start + chunkSize, fileSize);</span><br><span class="line">      <span class="keyword">const</span> chunk = selectedFile.<span class="title function_">slice</span>(start, end);</span><br><span class="line">      formData.<span class="title function_">append</span>(<span class="string">`chunk-<span class="subst">$&#123;chunkNumber&#125;</span>`</span>, chunk, selectedFile.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起文件上传请求</span></span><br><span class="line">    axios</span><br><span class="line">      .<span class="title function_">post</span>(<span class="string">&quot;/upload&quot;</span>, formData, &#123;</span><br><span class="line">        <span class="attr">onUploadProgress</span>: <span class="function">(<span class="params">progressEvent</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> progress = <span class="title class_">Math</span>.<span class="title function_">round</span>(</span><br><span class="line">            (progressEvent.<span class="property">loaded</span> / progressEvent.<span class="property">total</span>) * <span class="number">100</span></span><br><span class="line">          );</span><br><span class="line">          <span class="title function_">setProgress</span>(progress);</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;文件上传成功:&quot;</span>, response.<span class="property">data</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;文件上传失败:&quot;</span>, error);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当用户选择文件后，通过 <code>handleFileChange</code> 函数处理文件选择事件，将选择的文件保存在 <code>selectedFile</code> 状态中。<br>当用户点击上传按钮时，通过 <code>handleFileUpload</code> 函数处理文件上传事件。<br>在 <code>handleFileUpload</code> 函数中，计算切片数量和每个切片的大小，并创建一个 <code>FormData</code> 对象用于存储文件信息和切片数据。</p>
</blockquote>
<h2 id="实现客户端切片下载的方案"><a href="#实现客户端切片下载的方案" class="headerlink" title="实现客户端切片下载的方案"></a>实现客户端切片下载的方案</h2><p>实现客户端切片下载的基本方案如下：</p>
<ol>
<li>服务器端将大文件切割成多个切片，并为每个切片生成唯一的标识符。</li>
<li>客户端发送请求获取切片列表，同时开始下载第一个切片。</li>
<li>客户端在下载过程中，根据切片列表发起并发请求下载其他切片，并逐渐拼接合并下载的数据。</li>
<li>当所有切片都下载完成后，客户端将下载的数据合并为完整的文件</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">downloadFile</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 发起文件下载请求</span></span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&quot;/download&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> totalSize = data.<span class="property">totalSize</span>;</span><br><span class="line">      <span class="keyword">const</span> totalChunks = data.<span class="property">totalChunks</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> downloadedChunks = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">let</span> chunks = [];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 下载每个切片</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> chunkNumber = <span class="number">0</span>; chunkNumber &lt; totalChunks; chunkNumber++) &#123;</span><br><span class="line">        <span class="title function_">fetch</span>(<span class="string">`/download/<span class="subst">$&#123;chunkNumber&#125;</span>`</span>, &#123;</span><br><span class="line">          <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">          .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> response.<span class="title function_">blob</span>())</span><br><span class="line">          .<span class="title function_">then</span>(<span class="function">(<span class="params">chunk</span>) =&gt;</span> &#123;</span><br><span class="line">            downloadedChunks++;</span><br><span class="line">            chunks.<span class="title function_">push</span>(chunk);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当所有切片都下载完成时</span></span><br><span class="line">            <span class="keyword">if</span> (downloadedChunks === totalChunks) &#123;</span><br><span class="line">              <span class="comment">// 合并切片</span></span><br><span class="line">              <span class="keyword">const</span> mergedBlob = <span class="keyword">new</span> <span class="title class_">Blob</span>(chunks);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 创建对象 URL，生成下载链接</span></span><br><span class="line">              <span class="keyword">const</span> downloadUrl = <span class="variable language_">window</span>.<span class="property">URL</span>.<span class="title function_">createObjectURL</span>(mergedBlob);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 创建 &lt;a&gt; 元素并设置属性</span></span><br><span class="line">              <span class="keyword">const</span> link = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">              link.<span class="property">href</span> = downloadUrl;</span><br><span class="line">              link.<span class="title function_">setAttribute</span>(<span class="string">&quot;download&quot;</span>, <span class="string">&quot;file.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 模拟点击下载</span></span><br><span class="line">              link.<span class="title function_">click</span>();</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 释放资源</span></span><br><span class="line">              <span class="variable language_">window</span>.<span class="property">URL</span>.<span class="title function_">revokeObjectURL</span>(downloadUrl);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;文件下载失败:&quot;</span>, error);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看下代码，首先使用 <code>BLOB</code> 对象创建一共对象 URL，用于生成下载连接，然后创建 a 标签并且设置 href 的属性为刚刚创建的对象 URL,继续设置 a 标签的 <code>download</code> 属性是文件名，方便点击的时候自动下载文件。</p>
<h2 id="显示下载进度和完成状态"><a href="#显示下载进度和完成状态" class="headerlink" title="显示下载进度和完成状态"></a>显示下载进度和完成状态</h2><p>为了显示下载进度和完成状态，可以在客户端实现以下功能：</p>
<ol>
<li>显示进度条：客户端可以通过监听每个切片的下载进度来计算整体下载进度，并实时更新进度条的显示。</li>
<li>显示完成状态：当所有切片都下载完成后，客户端可以显示下载完成的状态，例如显示一个完成的图标或者文本。<br>这里我们可以继续接着切片上传代码示例里的继续写。</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleFileDownload</span>(<span class="params"></span>) &#123;</span><br><span class="line">  axios.<span class="title function_">get</span>(<span class="string">&#x27;/download&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">responseType</span>: <span class="string">&#x27;blob&#x27;</span>,</span><br><span class="line">    <span class="attr">onDownloadProgress</span>: <span class="function"><span class="params">progressEvent</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> progress = <span class="title class_">Math</span>.<span class="title function_">round</span>((progressEvent.<span class="property">loaded</span> / progressEvent.<span class="property">total</span>) * <span class="number">100</span>);</span><br><span class="line">      <span class="title function_">setProgress</span>(progress);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 创建一个临时的URL对象用于下载</span></span><br><span class="line">      <span class="keyword">const</span> url = <span class="variable language_">window</span>.<span class="property">URL</span>.<span class="title function_">createObjectURL</span>(<span class="keyword">new</span> <span class="title class_">Blob</span>([response.<span class="property">data</span>]));</span><br><span class="line">      <span class="keyword">const</span> link = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">      link.<span class="property">href</span> = url;</span><br><span class="line">      link.<span class="title function_">setAttribute</span>(<span class="string">&#x27;download&#x27;</span>, <span class="string">&#x27;file.txt&#x27;</span>);</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(link);</span><br><span class="line">      link.<span class="title function_">click</span>();</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(link);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;文件下载失败:&#x27;</span>, error);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;button onClick=&#123;handleFileDownload&#125;&gt;下载文件&lt;/button&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>进度：&#123;progress&#125;%<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>当用户点击下载按钮时，通过 <code>handleFileDownload</code> 函数处理文件下载事件。</li>
<li>在 <code>handleFileDownload</code> 函数中，使用 <code>axios</code> 库发起文件下载请求，并设置 <code>responseType: &#39;blob&#39;</code> 表示返回二进制数据。</li>
<li>通过监听 <code>onDownloadProgress</code> 属性获取下载进度，并更新进度条的显示。</li>
<li>下载完成后，创建一个临时的 <code>URL</code> 对象用于下载，并通过动态创建 <code>&lt;a&gt;</code> 元素模拟点击下载。</li>
</ul>
<h1 id="实现断点续传的技术：记录和恢复上传状态"><a href="#实现断点续传的技术：记录和恢复上传状态" class="headerlink" title="实现断点续传的技术：记录和恢复上传状态"></a>实现断点续传的技术：记录和恢复上传状态</h1><ul>
<li>在前端，可以使用 <code>localStorage</code> 或 <code>sessionStorage</code> 来存储已上传的切片信息，包括已上传的切片索引、切片大小等。</li>
<li>每次上传前，先检查本地存储中是否存在已上传的切片信息，若存在，则从断点处继续上传。</li>
<li>在后端，可以使用一个临时文件夹或数据库来记录已接收到的切片信息，包括已上传的切片索引、切片大小等。</li>
<li>在上传完成前，保存上传状态，以便在上传中断后能够恢复上传进度。</li>
</ul>
<blockquote>
<p>在实现大文件上传时要考虑服务器端的处理能力和存储空间，以及安全性问题。同时，为了保障断点续传的准确性，应该尽量避免并发上传相同文件的情况，可以采用文件唯一标识符或用户会话标识符进行区分。</p>
</blockquote>
]]></content>
      <tags>
        <tag>JS</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>react</title>
    <url>/2024/01/02/react/</url>
    <content><![CDATA[<img src="/2024/01/02/react/dom.png" class title="dom">

<p>组件初始化—-render 方法—-&gt;生成虚拟 DOM—ReactDOM.render 方法—&gt;真实 DOM</p>
<p>组件更新—- render 方法—-&gt;生成新的虚拟 DOM—-diff 算法—-&gt;定位出两次虚拟 DOM 的差异</p>
]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs-Express</title>
    <url>/2023/12/27/NodeJs-Express/</url>
    <content><![CDATA[<h1 id="简单的-demo"><a href="#简单的-demo" class="headerlink" title="简单的 demo"></a>简单的 demo</h1><span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="comment">//HTTP请求体解析中间件</span></span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&quot;body-parser&quot;</span>);</span><br><span class="line"><span class="comment">//日志组件</span></span><br><span class="line"><span class="keyword">const</span> morgan = <span class="built_in">require</span>(<span class="string">&quot;morgan&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> jsonParser = bodyParser.<span class="title function_">json</span>(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">unknownEndpoint</span> = (<span class="params">request, response</span>) =&gt; &#123;</span><br><span class="line">  response.<span class="title function_">status</span>(<span class="number">404</span>).<span class="title function_">send</span>(&#123; <span class="attr">error</span>: <span class="string">&quot;unknown endpoint&quot;</span> &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(unknownEndpoint);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">json</span>());</span><br><span class="line"></span><br><span class="line">morgan.<span class="title function_">token</span>(<span class="string">&quot;body&quot;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(req.<span class="property">body</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">morgan.<span class="title function_">format</span>(</span><br><span class="line">  <span class="string">&quot;format&quot;</span>,</span><br><span class="line">  <span class="string">&quot;:method :url :status :res[content-length] - :response-time ms :body&quot;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">morgan</span>(<span class="string">&quot;format&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> persons = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Arto Hellas&quot;</span>,</span><br><span class="line">    <span class="attr">number</span>: <span class="string">&quot;040-123456&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Ada Lovelace&quot;</span>,</span><br><span class="line">    <span class="attr">number</span>: <span class="string">&quot;39-44-5323523&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Dan Abramov&quot;</span>,</span><br><span class="line">    <span class="attr">number</span>: <span class="string">&quot;12-43-234345&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Mary Poppendieck&quot;</span>,</span><br><span class="line">    <span class="attr">number</span>: <span class="string">&quot;39-23-6423122&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/api/persons&quot;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  response.<span class="title function_">json</span>(persons);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/info&quot;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> peopleNum = persons.<span class="property">length</span>;</span><br><span class="line">  response.<span class="title function_">send</span>(</span><br><span class="line">    <span class="string">`&lt;p&gt;Phonebook has info for <span class="subst">$&#123;peopleNum&#125;</span> people&lt;/p&gt;&lt;p&gt;<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>()&#125;</span>&lt;/p&gt;`</span></span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/api/persons/:id&quot;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> id = <span class="title class_">Number</span>(request.<span class="property">params</span>.<span class="property">id</span>);</span><br><span class="line">  <span class="keyword">const</span> person = persons.<span class="title function_">find</span>(<span class="function">(<span class="params">i</span>) =&gt;</span> i.<span class="property">id</span> === id);</span><br><span class="line">  <span class="keyword">if</span> (person) &#123;</span><br><span class="line">    response.<span class="title function_">json</span>(person);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    response.<span class="title function_">status</span>(<span class="number">404</span>).<span class="title function_">end</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">delete</span>(<span class="string">&quot;/api/persons/:id&quot;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> id = <span class="title class_">Number</span>(request.<span class="property">params</span>.<span class="property">id</span>);</span><br><span class="line">  persons = persons.<span class="title function_">filter</span>(<span class="function">(<span class="params">i</span>) =&gt;</span> i.<span class="property">id</span> !== id);</span><br><span class="line">  response.<span class="title function_">status</span>(<span class="number">204</span>).<span class="title function_">send</span>(&#123; <span class="attr">msg</span>: <span class="string">&quot;delete successful&quot;</span> &#125;).<span class="title function_">end</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&quot;/api/persons&quot;</span>, jsonParser, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> person = request.<span class="property">body</span>;</span><br><span class="line">  <span class="keyword">if</span> (!person.<span class="property">name</span>) &#123;</span><br><span class="line">    response.<span class="title function_">status</span>(<span class="number">400</span>).<span class="title function_">send</span>(&#123; <span class="attr">error</span>: <span class="string">&quot;please provide name&quot;</span> &#125;);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!person.<span class="property">number</span>) &#123;</span><br><span class="line">    response.<span class="title function_">status</span>(<span class="number">400</span>).<span class="title function_">send</span>(&#123; <span class="attr">error</span>: <span class="string">&quot;please provide number&quot;</span> &#125;);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> isExistName = persons.<span class="title function_">find</span>(<span class="function">(<span class="params">i</span>) =&gt;</span> i.<span class="property">name</span> === person.<span class="property">name</span>);</span><br><span class="line">  <span class="keyword">if</span> (isExistName) &#123;</span><br><span class="line">    response.<span class="title function_">status</span>(<span class="number">400</span>).<span class="title function_">send</span>(&#123; <span class="attr">error</span>: <span class="string">&quot;name must be unique&quot;</span> &#125;);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  person.<span class="property">id</span> = <span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (<span class="number">1000</span> - <span class="number">100000000</span>)) + <span class="number">100000000</span>;</span><br><span class="line"></span><br><span class="line">  persons = persons.<span class="title function_">concat</span>(person);</span><br><span class="line"></span><br><span class="line">  response.<span class="title function_">json</span>(person);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3001</span>);</span><br></pre></td></tr></table></figure>

<h1 id="中间件-（Middleware）"><a href="#中间件-（Middleware）" class="headerlink" title="中间件 （Middleware）"></a>中间件 （Middleware）</h1><p>中间件是可以用来处理 request 和 response 对象的函数。</p>
<p>我们之前使用的 <code>json-parser</code> 从请求中获取原始数据，这些数据存储在 <code>request</code> 对象中，将其解析为一个 JavaScript 对象，并将其作为一个新的属性 <code>body</code> 分配给 <code>request</code> 对象。</p>
<p>让我们来实现我们自己的中间件，它可以打印出发送到服务器的每个请求的信息。</p>
<p>中间件是一个接收三个参数的函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">requestLogger</span> = (<span class="params">request, response, next</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Method:&quot;</span>, request.<span class="property">method</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Path:  &quot;</span>, request.<span class="property">path</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Body:  &quot;</span>, request.<span class="property">body</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;---&quot;</span>);</span><br><span class="line">  <span class="title function_">next</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在函数体的最后，调用作为参数传递的 <code>next</code> 函数。这个<code>next</code> 函数将控制权交给下一个中间件。</p>
<p>中间件是这样被使用的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app.use(requestLogger)</span><br></pre></td></tr></table></figure>

<p>中间件函数的调用顺序是它们被 <code>Express</code> 服务器对象的 <code>use</code> 方法所使用的顺序。请注意，<code>json-parser</code> 是在 <code>requestLogger</code> 中间件之前被使用的，因为否则在执行记录器的时候，<code>request.body</code> 将不会被初始化。</p>
<p>如果我们想让中间件函数在路由事件处理程序被调用前执行，那么就必须在路由之前使用这些中间件函数。也有一些情况，我们想在路由之后定义中间件函数。在实践中，这意味着我们要定义的中间件函数只有在没有路由处理 HTTP 请求时才会被调用。</p>
<p>让我们在路由之后添加以下中间件，用于捕捉向不存在的路由发出的请求。对于这些请求，中间件将返回一个 JSON 格式的错误信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const unknownEndpoint = (request, response) =&gt; &#123;</span><br><span class="line">  response.status(404).send(&#123; error: &#x27;unknown endpoint&#x27; &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.use(unknownEndpoint)</span><br></pre></td></tr></table></figure>

<h1 id="morgan"><a href="#morgan" class="headerlink" title="morgan"></a>morgan</h1><p><a href="https://github.com/expressjs/morgan">github</a></p>
<blockquote>
<p>注意，即使在控制台中记录数据也是危险的，因为它可能包含敏感数据，并可能违反当地的隐私法（如欧盟的 GDPR）或商业标准。</p>
</blockquote>
<h2 id="自定义日志格式"><a href="#自定义日志格式" class="headerlink" title="自定义日志格式"></a>自定义日志格式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">morgan.<span class="title function_">format</span>(</span><br><span class="line">  <span class="string">&quot;format&quot;</span>,</span><br><span class="line">  <span class="string">&quot;:method :url :status :res[content-length] - :response-time ms :body&quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="自定义-token"><a href="#自定义-token" class="headerlink" title="自定义 token"></a>自定义 token</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">morgan.<span class="title function_">token</span>(<span class="string">&quot;body&quot;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(req.<span class="property">body</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="控制台运行结果"><a href="#控制台运行结果" class="headerlink" title="控制台运行结果"></a>控制台运行结果</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /api/persons 400 31 - 0.621 ms &#123;&quot;name&quot;:&quot;aapls&quot;,&quot;number&quot;:&quot;0asd20-8780&quot;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="mongoose"><a href="#mongoose" class="headerlink" title="mongoose"></a>mongoose</h1><ol>
<li>在 <a href="https://cloud.mongodb.com/">https://cloud.mongodb.com/</a> 上建好 project 后，本地连接上（这个步骤不记得的可以上网搜索）</li>
<li>安装 mongoose</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install mongoose</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>node</tag>
        <tag>express</tag>
      </tags>
  </entry>
  <entry>
    <title>BFF(Backend For Frontend)</title>
    <url>/2024/01/16/BFF/</url>
    <content><![CDATA[<p>BFF，既 Backend For Frontend。 中文翻译过来的意思是前端的后端。</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>前端后端 (BFF) 是一种架构模式，涉及为每个客户端应用程序创建单独的后端。这可以更好地分离关注点，因为可以根据客户端应用程序的需求专门定制后端。BFF 还可以通过减少客户端和服务器之间需要传输的数据量来提高性能和可扩展性。</p>
<span id="more"></span>

<h1 id="比喻"><a href="#比喻" class="headerlink" title="比喻"></a>比喻</h1><p>前端后端（BFF）架构可以类比为一套量身定制的套装。正如西装是根据穿着者的具体尺寸和偏好量身定制的一样，BFF 也是根据客户端应用程序的特定需求和要求量身定制的。这可以更好地分离关注点并提高性能，类似于合身的西装如何增强穿着者的舒适度和外观。</p>
<h1 id="何时使用-BFF-模式？"><a href="#何时使用-BFF-模式？" class="headerlink" title="何时使用 BFF 模式？"></a>何时使用 BFF 模式？</h1><h2 id="1-微服务架构"><a href="#1-微服务架构" class="headerlink" title="1.微服务架构"></a>1.微服务架构</h2><p>BFF 在微服务架构中特别有用，其中每个微服务都可以有自己的 BFF。这使得微服务之间具有更大的灵活性和独立性，因为每个微服务都可以为其特定的客户端应用程序拥有自己定制的后端。</p>
<h2 id="2-架构解耦"><a href="#2-架构解耦" class="headerlink" title="2. 架构解耦"></a>2. 架构解耦</h2><p>与其他架构模式（例如微前端）结合使用，它创建了一个更具凝聚力和模块化的系统</p>
<h2 id="3-跨平台开发"><a href="#3-跨平台开发" class="headerlink" title="3. 跨平台开发"></a>3. 跨平台开发</h2><p>当构建多个客户端应用程序时，需要不同的后端来保持更好的关注点分离。</p>
<h2 id="4-敏捷开发"><a href="#4-敏捷开发" class="headerlink" title="4. 敏捷开发"></a>4. 敏捷开发</h2><p>BFF 还可以在不影响后端的情况下更轻松地维护和更新客户端应用程序，从而帮助简化开发过程。</p>
<h2 id="5-性能优势"><a href="#5-性能优势" class="headerlink" title="5.性能优势"></a>5.性能优势</h2><p>使用 BFF 可以通过减少客户端和服务器之间传输的数据量来提高性能和可扩展性</p>
<h2 id="6-构建微前端"><a href="#6-构建微前端" class="headerlink" title="6. 构建微前端"></a>6. 构建微前端</h2><p>在构建微前端时，将前端分解为更小、更易于管理的部分，以便可以独立开发和部署。每个微前端都可以有自己的 BFF，这可以提高关注点分离和灵活性</p>
<h1 id="何时不使用-BFF-模式？"><a href="#何时不使用-BFF-模式？" class="headerlink" title="何时不使用 BFF 模式？"></a>何时不使用 BFF 模式？</h1><h2 id="1-小团队"><a href="#1-小团队" class="headerlink" title="1.小团队"></a>1.小团队</h2><p>BFF 可能会带来额外的复杂性和维护开销，因为每个客户端应用程序都有自己的后端需要维护。对于资源有限的小型团队和初创公司来说，这尤其具有挑战性。</p>
<h2 id="2-产品可行性"><a href="#2-产品可行性" class="headerlink" title="2. 产品可行性"></a>2. 产品可行性</h2><p>当构建不需要复杂客户端应用程序的产品时，不需要根据特定客户端应用程序的需求定制后端</p>
<h2 id="3-Rest-足够了"><a href="#3-Rest-足够了" class="headerlink" title="3.Rest 足够了"></a>3.Rest 足够了</h2><p>在构建需要传统 RESTful API 架构（这是 Web API 最常见的架构）的应用程序时。</p>
<h2 id="4-编排延迟"><a href="#4-编排延迟" class="headerlink" title="4. 编排延迟"></a>4. 编排延迟</h2><p>在构建需要直接客户端到微服务通信的应用程序时，这样做是为了减少解耦微服务之间的附加通信层带来的延迟。</p>
<h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><p>以下是使用 React.js 的 BFF（前端后端）代码示例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = <span class="title function_">useState</span>([]);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">&quot;/api&quot;</span>)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line"></span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> <span class="title function_">setData</span>(data));</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;data.map((item) =&gt; (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;item.id&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;item.title&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;item.body&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      ))&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此代码设置一个 React 组件，该组件从 BFF API 端点获取数据并将其呈现在页面上。useEffect 挂钩用于在组件安装后立即获取数据。使用 useState 挂钩将获取的数据存储在组件的状态中，然后进行映射以显示数据数组中的每个项目。</p>
<h1 id="BFF-模式的替代方案"><a href="#BFF-模式的替代方案" class="headerlink" title="BFF 模式的替代方案"></a>BFF 模式的替代方案</h1><p>BFF 并不是唯一支持复杂 Web 开发的架构模式。还有其他流行的模式可以独立使用或与 BFF 一起使用：</p>
<h2 id="API-网关模式"><a href="#API-网关模式" class="headerlink" title="API 网关模式"></a>API 网关模式</h2><p>在此模式中，单个 API 网关负责处理所有客户端请求并与适当的微服务和后端进行通信。这可以简化架构并减少维护开销，因为客户端和后端之间只有一个接触点。但是，在处理 API 网关和微服务&#x2F;后端之间的路由和通信时，它也可能会带来额外的延迟和复杂性。</p>
<h2 id="无服务器架构"><a href="#无服务器架构" class="headerlink" title="无服务器架构"></a>无服务器架构</h2><p>该架构基于按需运行代码的概念，而不是始终运行专用服务器或服务器集群。这有助于降低成本并简化架构。</p>
<h2 id="GraphQL"><a href="#GraphQL" class="headerlink" title="GraphQL"></a>GraphQL</h2><p><a href="https://graphql.org/">GraphQL</a> 是 RESTful API 的替代方案，允许客户端指定他们需要的确切数据并仅接收该数据。这可以减少客户端和服务器之间传输的数据量并提高性能。</p>
<blockquote>
<p>GraphQL is a query language for APIs and a runtime for fulfilling those queries with your existing data. GraphQL provides a complete and understandable description of the data in your API, gives clients the power to ask for exactly what they need and nothing more, makes it easier to evolve APIs over time, and enables powerful developer tools.</p>
</blockquote>
<h2 id="微前端"><a href="#微前端" class="headerlink" title="微前端"></a>微前端</h2><p>这种架构模式涉及将前端分解为更小、更易于管理的部分，这些部分可以独立开发和部署。每个微前端都可以有自己的 BFF，这可以提高关注点分离和灵活性。</p>
<h2 id="服务网格架构"><a href="#服务网格架构" class="headerlink" title="服务网格架构"></a>服务网格架构</h2><p>在此架构中，添加了专用基础设施层来处理服务到服务的通信。这可以简化架构并降低处理服务之间通信的复杂性。</p>
<h2 id="API-成分"><a href="#API-成分" class="headerlink" title="API 成分"></a>API 成分</h2><p>这涉及将多个 API 聚合到单个 API 中，这可以简化架构并减少检索数据所需的请求数量。</p>
<h2 id="客户端到微服务的直接通信"><a href="#客户端到微服务的直接通信" class="headerlink" title="客户端到微服务的直接通信"></a>客户端到微服务的直接通信</h2><p>在此架构中，客户端直接与微服务通信，而不是通过 BFF 或 API 网关。这可以减少额外通信层带来的复杂性和延迟。然而，这也会降低灵活性和关注点分离。<br>事件驱动架构<br>这种架构涉及使用事件来触发系统中的操作，这可以提高可扩展性和模块化性。</p>
<h2 id="SOA（面向服务的架构）"><a href="#SOA（面向服务的架构）" class="headerlink" title="SOA（面向服务的架构）"></a>SOA（面向服务的架构）</h2><p>这涉及将系统分解为可以独立开发和部署的单独服务。每个服务都可以有自己的 BFF 或 API 网关。这可以提高可扩展性和灵活性。</p>
<h2 id="传统-RESTful-API"><a href="#传统-RESTful-API" class="headerlink" title="传统 RESTful API"></a>传统 RESTful API</h2><p>这是 Web API 最常见的架构，客户端通过 RESTful API 与服务器进行通信。</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://www.linkedin.com/pulse/bff-pattern-good-bad-alternatives-chandra-sharma-#:~:text=Backend%20for%20Frontend%20(BFF)%20is,of%20the%20client%2Dside%20application.">BFF Pattern: The Good, the Bad, and the Alternatives. - LinkedIn</a></p>
]]></content>
      <tags>
        <tag>BFF</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx</title>
    <url>/2024/01/16/nginx/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Nginx（发音为”engine-x”）是一个高性能的开源 Web 服务器和反向代理服务器。以下是 Nginx 的一些关键特点和简介：</p>
<p><strong>高性能</strong>： Nginx 以高性能而著称，能够处理大量并发连接，同时占用较少的系统资源。它的事件驱动架构和非阻塞 IO 模型有助于实现高效的性能。</p>
<p><strong>轻量级和可扩展</strong>： Nginx 的设计目标之一是保持简单、轻量级且可扩展。它的模块化架构使得用户可以根据需要选择性地添加功能模块。</p>
<p><strong>反向代理</strong>： Nginx 可以用作反向代理服务器，接收客户端请求并将其转发到后端服务器。这使得它成为负载均衡和提高 Web 应用性能的理想选择。</p>
<p><strong>负载均衡</strong>： Nginx 支持基于轮询、IP 哈希等算法的负载均衡，能够平均分配流量到多个后端服务器，提高系统的可用性和稳定性。</p>
<span id="more"></span>

<p><strong>静态文件服务</strong>： Nginx 非常擅长提供静态文件服务，可以快速地传送静态内容，减轻后端服务器的负担。</p>
<p><strong>SSL&#x2F;TLS 支持</strong>： Nginx 支持 SSL&#x2F;TLS 协议，能够提供安全的加密通信，用于保护网站和应用程序的数据传输。</p>
<p><strong>虚拟主机</strong>： Nginx 支持虚拟主机配置，允许多个域名共享同一台服务器，并根据域名或其他条件进行不同的配置。</p>
<p><strong>日志记录</strong>： Nginx 提供详细的访问日志和错误日志，有助于进行故障排除和性能优化。</p>
<p><strong>社区支持和活跃</strong>： Nginx 是一个开源项目，拥有庞大的用户社区，有许多第三方模块和插件可用。它也有商业版本（NGINX Plus）提供额外的功能和支持。</p>
<p>总体而言，Nginx 是一个强大、灵活且高性能的 Web 服务器，适用于处理各种 Web 应用程序和场景。由于其卓越的性能和可扩展性，它被广泛用于互联网和企业环境中</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="1-包管理安装"><a href="#1-包管理安装" class="headerlink" title="1. 包管理安装"></a>1. 包管理安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install nginx</span><br></pre></td></tr></table></figure>

<p>or</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install nginx</span><br></pre></td></tr></table></figure>

<h2 id="2-编译安装"><a href="#2-编译安装" class="headerlink" title="2. 编译安装"></a>2. 编译安装</h2><p>下载源码，预编译，编译，安装，比较灵活，可以自定义配置一些东西，但比较麻烦</p>
<h2 id="3-使用-Docker-安装"><a href="#3-使用-Docker-安装" class="headerlink" title="3. 使用 Docker 安装"></a>3. 使用 Docker 安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure>

<h1 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h1><ol>
<li>启动命令：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></table></figure>

<blockquote>
<p>没有消息就是好消息</p>
</blockquote>
<ol start="2">
<li><p>打开浏览器输入 localhost,能打开页面看到 Welcome to nginx! ,说明启动成功</p>
</li>
<li><p><code>ps -ef|grep nginx</code>可查看 nginx 进程</p>
</li>
<li><p>nginx -s signal<br>quit : 优雅停止<br>stop: 立即停止<br>reload：重新配置文件<br>reopen：重新打开日志文件</p>
</li>
<li><p>nginx -V<br>可以查看 Nginx 的安装目录，编译参数等等</p>
</li>
<li><p>如何查看 nginx 运行的网页的位置</p>
</li>
<li><p><code>nginx -V</code></p>
</li>
<li><p>找到–prefix，例如： –prefix&#x3D;&#x2F;opt&#x2F;homebrew&#x2F;Cellar&#x2F;nginx&#x2F;1.21.6_1</p>
</li>
<li><p><code>cd /opt/homebrew/Cellar/nginx/1.21.6_1</code></p>
</li>
<li><p><code>ls -ltr </code>可以看到列表中有 html</p>
</li>
<li><p><code>cd html</code></p>
</li>
<li><p><code>ls -ltr</code></p>
</li>
<li><p><code>code index.html</code></p>
</li>
</ol>
<h1 id="搭建一个属于自己的个人博客网站"><a href="#搭建一个属于自己的个人博客网站" class="headerlink" title="搭建一个属于自己的个人博客网站"></a>搭建一个属于自己的个人博客网站</h1><ol>
<li>新建博客</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line">cd blog;npm install</span><br><span class="line">hexo server/ hexo s</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>部署到 nginx 上<br>然后将 hexo 生成的网页文件(在 public 目录下)，复制到 nginx 中</li>
</ol>
<p><code>cp -rf * /opt/homebrew/var/www</code></p>
<h1 id="nginx-配置"><a href="#nginx-配置" class="headerlink" title="nginx 配置"></a>nginx 配置</h1><h2 id="1-基本的服务器配置"><a href="#1-基本的服务器配置" class="headerlink" title="1. 基本的服务器配置"></a>1. 基本的服务器配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80; # 监听端口</span><br><span class="line">    server_name example.com www.example.com; # 域名配置</span><br><span class="line">    root /path/to/your/webroot; # 网站根目录</span><br><span class="line">    index index.html index.htm; # 默认首页</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        # 其他配置</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-反向代理配置"><a href="#2-反向代理配置" class="headerlink" title="2. 反向代理配置"></a>2. 反向代理配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name example.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://backend_server; # 后端服务器地址</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        # 其他反向代理配置</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-负载均衡配置"><a href="#3-负载均衡配置" class="headerlink" title="3. 负载均衡配置"></a>3. 负载均衡配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    server backend1.example.com;</span><br><span class="line">    server backend2.example.com;</span><br><span class="line">    # 添加更多后端服务器</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name example.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://backend;</span><br><span class="line">        # 其他负载均衡配置</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-SSL-TLS-配置"><a href="#4-SSL-TLS-配置" class="headerlink" title="4. SSL&#x2F;TLS 配置"></a>4. SSL&#x2F;TLS 配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name secure.example.com;</span><br><span class="line"></span><br><span class="line">    ssl_certificate /path/to/ssl_certificate.crt;</span><br><span class="line">    ssl_certificate_key /path/to/ssl_certificate.key;</span><br><span class="line"></span><br><span class="line">    # 其他SSL/TLS配置</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="5-重定向配置"><a href="#5-重定向配置" class="headerlink" title="5. 重定向配置"></a>5. 重定向配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name www.example.com;</span><br><span class="line">    return 301 http://example.com$request_uri; # 重定向到非www域名</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="反向代理和负载均衡"><a href="#反向代理和负载均衡" class="headerlink" title="反向代理和负载均衡"></a>反向代理和负载均衡</h1><h2 id="正向代理和反向代理"><a href="#正向代理和反向代理" class="headerlink" title="正向代理和反向代理"></a>正向代理和反向代理</h2><p>正向代理 代理客户端（client）（VPN）<br>反向代理 代理服务端（server） （比如我们通过 Google 搜索内容，我们只通过一个域名访问，但其实转发到了后面很多个不同的服务器端上，从而隐藏了真实的服务器 IP 地址、端口等信息）</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><ol>
<li>首先先用 go 生成一个简单的 web 页面，在端口 8000 监听，这里我是用 chatGPT 自动帮我生成：</li>
</ol>
<blockquote>
<p>如果没有安装 go,请先安装，我这边直接用<code>brew install go</code></p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 设置路由</span></span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		fmt.Fprintf(w, <span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动服务器并监听8000端口</span></span><br><span class="line">	port := <span class="number">8000</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;服务器正在监听端口 %d...\n&quot;</span>, port)</span><br><span class="line">	err := http.ListenAndServe(fmt.Sprintf(<span class="string">&quot;:%d&quot;</span>, port), <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;启动服务器时发生错误:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>我们将上面的文件再复制出两个文件，分别改写端口号为 8001、8002，分别运行在浏览器中。</p>
</li>
<li><p>然后我们再修改一下 nginx 的配置文件<br><code>code /opt/homebrew/etc/nginx/nginx.conf</code><br>添加<code>upstream</code>的配置，这个就是反向代理的配置</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream backend&#123;</span><br><span class="line">      server 127.0.0.1:8000;</span><br><span class="line">      server 127.0.0.1:8001;</span><br><span class="line">      server 127.0.0.1:8002;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在 下面的 server 配置中再添加一个 location 的配置，访问 app 都将代理到刚刚的配置中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location /app&#123;</span><br><span class="line">           proxy_pass http://backend;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>重新 reload 一下 nginx 配置<br><code>nginx -s reload </code></li>
</ol>
<h1 id="https-配置"><a href="#https-配置" class="headerlink" title="https 配置"></a>https 配置</h1><p>http + ssl 证书 -&gt; https<br>http 默认端口： 80<br>https 默认端口： 443<br>在主流的云平台（腾讯云，阿里云，AWS，GCP）上都可以申请免费的 ssl 证书，证书申请完后会得到证书文件(cacert.pem)和私钥文件（private.key），如果没有云平台也没有关系，我们可以通过 openssl 来自己生成一个自签名的证书</p>
<h2 id="openssl-生成证书"><a href="#openssl-生成证书" class="headerlink" title="openssl 生成证书"></a>openssl 生成证书</h2><ol>
<li>生成私钥文件（private key）<br><code>openssl genrsa -out private.key 2048</code></li>
<li>根据私钥生成证书签名请求文件<br><code>openssl req -new -key private.key -out cert.csr</code></li>
<li>使用私钥对证书申请进行签名从而生成证书（pem 文件）<br><code>openssl x509 -req -in cert.csr -out cacert.pem -signkey private.key</code></li>
</ol>
<h2 id="nginx-配置-1"><a href="#nginx-配置-1" class="headerlink" title="nginx 配置"></a>nginx 配置</h2><p>这两个文件需要放置到服务器上<code>证书文件(cacert.pem)和私钥文件（private.key）</code>,然后在 nginx 的配置文件中进行配置</p>
<ol>
<li>在监听后加上 ssl<br><code> listen    443 ssl;</code></li>
<li>将证书和私钥填写进入</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssl_certificate    /opt/homebrew/etc/nginx/cacert.pem</span><br><span class="line">ssl_certificate_key    /opt/homebrew/etc/nginx/private.key</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>然后再加上一些验证配置和加密协议，这些配置基本是固定的</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name your_domain.com;</span><br><span class="line"></span><br><span class="line">    ssl_certificate /etc/nginx/ssl/your_domain.crt;</span><br><span class="line">    ssl_certificate_key /etc/nginx/ssl/your_domain.key;</span><br><span class="line"></span><br><span class="line">    # 可选：配置 SSL 优化和安全性</span><br><span class="line">    ssl_protocols TLSv1.2 TLSv1.3;</span><br><span class="line">    ssl_prefer_server_ciphers off;</span><br><span class="line">    ssl_ciphers &#x27;TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384&#x27;;</span><br><span class="line"></span><br><span class="line">    # 其他 SSL 配置...</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        # 配置其他相关的代理或静态文件服务...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们的证书是自签名的，没有经过 ca 认证，所以打开网站会提示不安全</p>
</blockquote>
<h3 id="配置-http-重定向到-https"><a href="#配置-http-重定向到-https" class="headerlink" title="配置 http 重定向到 https"></a>配置 http 重定向到 https</h3><p>server {<br>listen 80;<br>server_name your_domain.com <a href="http://www.your_domain.com/">www.your_domain.com</a>;</p>
<pre><code># 重定向到 HTTPS
return 301 https://$host$request_uri;
</code></pre>
<p>}</p>
<h1 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h1><p>虚拟主机可以在一个服务器上部署多个站点</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>nginx 中通过<code>server</code>块来配置虚拟主机，每个<code>server</code>块就是一个虚拟主机</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80; # 监听端口</span><br><span class="line"></span><br><span class="line">    server_name your_domain.com www.your_domain.com; # 替换为你的域名</span><br><span class="line"></span><br><span class="line">    root /path/to/your/webroot; # 替换为你的网站根目录</span><br><span class="line"></span><br><span class="line">    index index.html index.htm; # 默认首页</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        # 配置其他参数，比如代理、缓存等</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 配置其他特定的location块，如果需要的话</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="如何将一个-vue-项目部署到服务器上"><a href="#如何将一个-vue-项目部署到服务器上" class="headerlink" title="如何将一个 vue 项目部署到服务器上"></a>如何将一个 vue 项目部署到服务器上</h2><ol>
<li><p>创建一个 vue 项目，并打包好</p>
</li>
<li><p>open nginx 配置项目</p>
</li>
</ol>
<ul>
<li><code>cd /opt/homebrew/etc/nginx</code></li>
<li><code>code .</code></li>
<li>新建一个 servers 文件夹，在 servers 里建<code>vue.conf</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    listen 5173;</span><br><span class="line">    server_name localhost;//替换成域名</span><br><span class="line">    location / &#123;</span><br><span class="line">        root /Users/mei/vue-demo/dist;//打包项目地址</span><br><span class="line">        index index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>nginx -s reload</code><br>在浏览器中输入 localhost:5173 就可以看到 vue 项目。</li>
</ul>
]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>docker</title>
    <url>/2024/01/19/docker/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>Docker 是一个用于 <strong>构建、运行、传送</strong> 应用程序的平台。</p>
<p>将以下这些打包，以便在任何环境中都可以正确地运行：</p>
<span id="more"></span>

<ul>
<li>配置文件、启动命令</li>
<li>应用程序、环境变量</li>
<li>第三方软件库和依赖包</li>
<li>运行时环境</li>
<li>操作系统（OS）</li>
</ul>
<h2 id="为什么要使用-Docker"><a href="#为什么要使用-Docker" class="headerlink" title="为什么要使用 Docker"></a>为什么要使用 Docker</h2><ol>
<li><p><strong>环境一致性</strong>： Docker 容器包含应用程序及其依赖项，确保在不同的环境中具有一致的运行结果。这有助于避免”在我的机器上可以运行”这类问题。</p>
</li>
<li><p><strong>轻量级</strong>： Docker 容器与虚拟机相比更轻量，因为它们共享主机操作系统的内核。这使得 Docker 容器更快速启动、占用更少资源，并提供更高的性能。</p>
</li>
<li><p><strong>快速部署</strong>： Docker 容器可以快速部署，几乎可以在任何支持 Docker 的环境中运行。这加速了应用程序的交付流程，使得新版本的应用程序可以更快地投入生产环境。</p>
</li>
<li><p><strong>易于扩展</strong>： Docker 容器可以在分布式环境中轻松扩展，实现负载均衡和高可用性。通过使用 Docker Swarm 或 Kubernetes 等容器编排工具，可以方便地管理多个容器的部署和伸缩。</p>
</li>
<li><p><strong>隔离性</strong>： Docker 容器提供了隔离的运行环境，每个容器之间相互隔离，不会相互影响。这使得应用程序更加安全，同时也更容易管理多个服务或应用。</p>
</li>
<li><p><strong>版本控制和回滚</strong>： Docker 允许将应用程序和其依赖项打包成镜像，并通过版本控制来管理。这样，可以方便地回滚到之前的版本，降低了部署过程中的风险。</p>
</li>
<li><p><strong>生态系统和社区支持</strong>： Docker 拥有庞大的社区，有大量的公开可用的镜像和工具。这使得开发人员可以轻松地获取和分享容器化的应用程序组件，加速了开发和部署过程。</p>
</li>
<li><p><strong>跨平台</strong>： Docker 容器可以在各种操作系统上运行，包括 Linux、Windows 和 macOS 等。这种跨平台性使得开发、测试和部署更加灵活。</p>
</li>
</ol>
<h2 id="Docker-和虚拟机的区别"><a href="#Docker-和虚拟机的区别" class="headerlink" title="Docker 和虚拟机的区别"></a>Docker 和虚拟机的区别</h2><p>Docker 容器和虚拟机（VM）是两种不同的虚拟化技术，它们在实现和性能方面存在一些关键的区别。以下是 Docker 容器和虚拟机之间的主要区别：</p>
<ol>
<li><strong>架构差异</strong>：</li>
</ol>
<ul>
<li>Docker 容器： Docker 容器共享主机操作系统的内核，但在容器中运行的应用程序有自己独立的用户空间。这使得 Docker 容器相对轻量，启动迅速。</li>
<li>虚拟机： 虚拟机通过使用虚拟化层创建独立的虚拟硬件，每个虚拟机都运行一个完整的操作系统实例。这增加了虚拟机的重量和启动时间。</li>
</ul>
<ol start="2">
<li><strong>资源占用</strong>：</li>
</ol>
<ul>
<li>Docker 容器： 由于容器共享主机内核，它们占用的资源更少，启动更快。容器可以在同一主机上运行成百上千个实例而不会显著增加资源开销。</li>
<li>虚拟机： 每个虚拟机都需要独立的操作系统和虚拟硬件，因此它们通常占用更多的资源，并且启动时间较长。</li>
</ul>
<ol start="3">
<li><strong>隔离性</strong>：</li>
</ol>
<ul>
<li>Docker 容器： 容器提供了一定程度的隔离，但容器共享主机内核，因此在安全性上相对较弱。</li>
<li>虚拟机： 虚拟机提供更强的隔离，因为它们运行独立的操作系统。虚拟机通常在安全性方面更有优势。</li>
</ul>
<ol start="4">
<li><strong>跨平台性</strong>：</li>
</ol>
<ul>
<li>Docker 容器： 容器可以在不同操作系统上运行，前提是它们使用相同的 Docker 引擎。这增加了跨平台的灵活性。</li>
<li>虚拟机： 虚拟机通常依赖于特定的虚拟化技术和操作系统，因此在不同平台之间移植性较差。</li>
</ul>
<ol start="5">
<li><strong>镜像大小</strong>：</li>
</ol>
<ul>
<li>Docker 容器： Docker 镜像通常比虚拟机镜像小得多，因为它们只包含应用程序及其依赖项，而不包括整个操作系统。</li>
<li>虚拟机： 虚拟机镜像包含完整的操作系统，因此它们通常较大。</li>
</ul>
<p>根据应用程序的需求和部署场景，选择使用 Docker 容器还是虚拟机取决于具体情况。一些场景中它们也可以结合使用，例如在虚拟机中运行 Docker 容器。</p>
<h1 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h1><ol>
<li><p>下载 Docker Desktop for Mac：<br>访问 Docker 官方网站下载 Docker Desktop for Mac。安装程序将包含 Docker 引擎以及 Docker CLI 等组件。</p>
</li>
<li><p>安装 Docker Desktop：<br>双击下载的 Docker.dmg 文件，将 Docker 图标拖动到 Applications 文件夹中，然后在 Applications 文件夹中运行 Docker。</p>
</li>
<li><p>运行 Docker Desktop：<br>打开 Docker 应用程序，它将启动 Docker 引擎。</p>
</li>
<li><p>验证 Docker 安装：<br>打开终端（Terminal）并运行以下命令检查 Docker 版本</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker --version</span><br></pre></td></tr></table></figure>

<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p>Docker 提供了丰富的命令行工具，用于管理和操作 Docker 容器、镜像等。以下是一些常用的 Docker 命令：</p>
<h2 id="镜像命令："><a href="#镜像命令：" class="headerlink" title="镜像命令："></a>镜像命令：</h2><p>查看本地镜像列表：</p>
<p><code>docker images</code><br>从 Docker Hub 下载镜像：</p>
<p><code>docker pull image_name:tag</code><br>构建镜像：</p>
<p><code>docker build -t image_name:tag .</code><br>删除本地镜像：</p>
<p><code>docker rmi image_name:tag</code></p>
<h2 id="容器命令："><a href="#容器命令：" class="headerlink" title="容器命令："></a>容器命令：</h2><ol>
<li>启动容器：<br><code>docker run image_name:tag</code></li>
<li>启动容器并指定名称：<br><code>docker run --name container_name image_name:tag</code></li>
<li>查看运行中的容器：<br><code>docker ps</code></li>
<li>查看所有容器（包括停止的）：<br><code>docker ps -a</code></li>
<li>停止容器：<br><code> docker stop container_id/container_name</code></li>
<li>删除容器：<br><code>docker rm container_id/container_name</code></li>
<li>进入运行中的容器：<br><code>docker exec -it container_id/container_name /bin/bash</code></li>
</ol>
<h2 id="日志和信息："><a href="#日志和信息：" class="headerlink" title="日志和信息："></a>日志和信息：</h2><ol>
<li><p>查看容器日志：<br><code>docker logs container_id/container_name</code></p>
</li>
<li><p>查看容器详细信息：<br><code>docker inspect container_id/container_name</code></p>
</li>
</ol>
<h2 id="网络命令："><a href="#网络命令：" class="headerlink" title="网络命令："></a>网络命令：</h2><ol>
<li>查看网络列表：<br><code>docker network ls</code></li>
<li>查看网络详细信息：<br><code>docker network inspect network_name</code></li>
</ol>
<h2 id="其他常用命令："><a href="#其他常用命令：" class="headerlink" title="其他常用命令："></a>其他常用命令：</h2><ol>
<li>查看 Docker 版本：<br><code>docker version</code></li>
<li>查看 Docker 信息：<br><code>docker info</code></li>
<li>清理无用资源（镜像、容器等）：<br><code>docker system prune</code></li>
<li>查看 Docker 帮助：<br><code>docker --help</code></li>
</ol>
<h1 id="构造镜像、运行容器"><a href="#构造镜像、运行容器" class="headerlink" title="构造镜像、运行容器"></a>构造镜像、运行容器</h1><p>构建 Docker 镜像是通过定义一个 <code>Dockerfile</code> 文件来描述镜像的构建过程。以下是一个简单的 <code>Dockerfile</code> 示例，演示如何构建一个基于 Node.js 的简单 Web 应用的镜像</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用官方Node.js镜像作为基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">14</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将应用程序的依赖项文件拷贝到工作目录</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> package*.json ./</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装应用程序的依赖项</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm install</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将应用程序文件拷贝到工作目录</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露应用程序监听的端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义启动命令</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;node&quot;</span>, <span class="string">&quot;app.js&quot;</span>]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述 Dockerfile 的主要步骤包括：</p>
<blockquote>
<p>使用官方 Node.js 14 镜像作为基础镜像。<br>设置工作目录为&#x2F;app。<br>将应用程序的 <code>package.json</code> 和 <code>package-lock.json</code> 拷贝到工作目录。<br>运行 <code>npm install</code> 安装应用程序的依赖项。<br>将应用程序文件拷贝到工作目录。<br>暴露应用程序监听的端口（这里是 3000）。<br>定义启动容器时运行的命令。</p>
</blockquote>
<p>接下来，可以使用以下命令在 <code>Dockerfile</code>所在的目录中构建镜像：</p>
<p><code>docker build -t your_image_name:tag .</code><br>其中，your_image_name 是你为镜像定义的名称，tag 是版本标签。最后的点.表示 Dockerfile 所在的当前目录。</p>
<p>构建完成后，你可以使用以下命令查看构建的镜像<br><code>docker images</code></p>
<p>然后，你可以使用构建的镜像来运行容器：<br><code>docker run -p 3000:3000 -d your_image_name:tag</code></p>
<h1 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h1><h2 id="特点和用途"><a href="#特点和用途" class="headerlink" title="特点和用途:"></a>特点和用途:</h2><p>Docker Compose 是 Docker 官方提供的工具，用于定义和运行多容器的 Docker 应用。<br>使用 <code>YAML</code> 文件定义多容器应用的服务、网络和卷等配置。<br>主要用于开发和测试环境，以便在本地一次性启动多个相关联的容器。<br>简化了通过 <code>docker-compose up</code> 一键启动整个应用程序的过程。</p>
<h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念:"></a>基本概念:</h3><ul>
<li>services: 定义应用中的各个服务，每个服务对应一个容器。</li>
<li>networks: 定义服务之间的网络连接。</li>
<li>volumes: 定义服务使用的数据卷。</li>
</ul>
<h4 id="示例-docker-compose-yml-文件"><a href="#示例-docker-compose-yml-文件" class="headerlink" title="示例 docker-compose.yml 文件"></a>示例 docker-compose.yml 文件</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:80&quot;</span></span><br><span class="line">  <span class="attr">app:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">your_app_image</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;5000:5000&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack</title>
    <url>/2024/01/23/webpack/</url>
    <content><![CDATA[<h1 id="如何提升-webpack-的构造性能"><a href="#如何提升-webpack-的构造性能" class="headerlink" title="如何提升 webpack 的构造性能"></a>如何提升 webpack 的构造性能</h1><h2 id="1-speed-measure-webpack-plugin"><a href="#1-speed-measure-webpack-plugin" class="headerlink" title="1. speed-measure-webpack-plugin"></a>1. speed-measure-webpack-plugin</h2><p>优化你的 webpack 构建速度的第一步是要知道你应该把注意力集中在哪里，在这里推荐一个插件：<a href="https://www.npmjs.com/package/speed-measure-webpack-plugin">speed-measure-webpack-plugin</a>，这个插件可以测量你的 webpack 构建速度</p>
<span id="more"></span>

<h3 id="install"><a href="#install" class="headerlink" title="install"></a>install</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save-dev speed-measure-webpack-plugin</span><br></pre></td></tr></table></figure>

<p>or</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yarn add -D speed-measure-webpack-plugin</span><br></pre></td></tr></table></figure>

<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="keyword">new</span> <span class="title class_">MyPlugin</span>(), <span class="keyword">new</span> <span class="title class_">MyOtherPlugin</span>()],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>to</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">SpeedMeasurePlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;speed-measure-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> smp = <span class="keyword">new</span> <span class="title class_">SpeedMeasurePlugin</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = smp.<span class="title function_">wrap</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="keyword">new</span> <span class="title class_">MyPlugin</span>(), <span class="keyword">new</span> <span class="title class_">MyOtherPlugin</span>()],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="2-更快的-loader：swc"><a href="#2-更快的-loader：swc" class="headerlink" title="2. 更快的 loader：swc"></a>2. 更快的 loader：swc</h2><p>在 webpack 中耗时最久的当属负责 AST 转换的 loader。我们可以使用速度更快的<a href="https://www.npmjs.com/package/swc-loader">swc</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.m?js$/</span>,</span><br><span class="line">      <span class="attr">exclude</span>: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">      <span class="attr">use</span>: &#123;</span><br><span class="line">        <span class="comment">// Use `.swcrc` to configure swc</span></span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&quot;swc-loader&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何配置-swc"><a href="#如何配置-swc" class="headerlink" title="如何配置 swc"></a>如何配置 swc</h3><p>SWC can be configured with an .swcrc file.</p>
<p>this is <a href="https://www.swc.net.cn/docs/configuration/swcrc">Compilation</a></p>
<p>如果你是使用的 babel,swc 官方网站拥有提供从 babel 迁移到 swc 的<a href="https://swc.rs/docs/migrating-from-babel">指南</a></p>
<h2 id="3-持久化缓存：cache"><a href="#3-持久化缓存：cache" class="headerlink" title="3. 持久化缓存：cache"></a>3. 持久化缓存：cache</h2><p>webpack5 内置了关于缓存的插件，可以通过配置来开启，它将<code>Module</code>、<code>Chunk</code>、<code>ModuleChunk</code>等信息序列化到磁盘中，二次构建避免重复编译计算，编译速度得到很大的提升</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">cache</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;filesystem&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当开启了持久化缓存功能，最耗时的 AST 解析将能够从磁盘的缓存中获取，再次编译时无需再次进行解析 AST。</p>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>对称加密和非对称加密</title>
    <url>/2023/02/19/encryption/</url>
    <content><![CDATA[<h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>对称加密采用了对称密码编码技术，它的特点是文件加密和解密使用<strong>相同的密钥</strong>加密。</p>
<span id="more"></span>

<p>也就是密钥也可以用作解密密钥，这种方法在密码学中叫做对称加密算法，对称加密算法使用起来简单快捷，密钥较短，且破译困难，除了数据加密标准（DES），另一个对称密钥加密系统是国际数据加密算法（IDEA），它比 DES 的加密性好，而且对计算机功能要求也没有那么高</p>
<h3 id="对称加密算法在电子商务交易过程中存在几个问题："><a href="#对称加密算法在电子商务交易过程中存在几个问题：" class="headerlink" title="对称加密算法在电子商务交易过程中存在几个问题："></a>对称加密算法在电子商务交易过程中存在几个问题：</h3><p>1、要求提供一条安全的渠道使通讯双方在首次通讯时协商一个共同的密钥。直接的面对面协商可能是不现实而且难于实施的，所以双方可能需要借助于邮件和电话等其它相对不够安全的手段来进行协商；</p>
<p>2、密钥的数目难于管理。因为对于每一个合作者都需要使用不同的密钥，很难适应开放社会中大量的信息交流；</p>
<p>3、对称加密算法一般不能提供信息完整性的鉴别。它无法验证发送者和接受者的身份；</p>
<p>4、对称密钥的管理和分发工作是一件具有潜在危险的和烦琐的过程。对称加密是基于共同保守秘密来实现的，采用对称加密技术的贸易双方必须保证采用的是相同的密钥，保证彼此密钥的交换是安全可靠的，同时还要设定防止密钥泄密和更改密钥的程序。</p>
<p>假设两个用户需要使用对称加密方法加密然后交换数据，则用户最少需要 2 个密钥并交换使用，如果企业内用户有 n 个，则整个企业共需要 n×(n-1) 个密钥，密钥的生成和分发将成为企业信息部门的恶梦。</p>
<p>常见的对称加密算法有 DES、3DES、Blowfish、IDEA、RC4、RC5、RC6 和 AES</p>
<h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>与对称加密算法不同，非对称加密算法需要两个密钥：<strong>公开密钥</strong>（publickey）和<strong>私有密钥</strong>（privatekey）。</p>
<ul>
<li>公钥用于加密数据，私钥用于解密数据。这意味着公钥可以公开分享，而私钥必须保持机密。</li>
<li>公钥用于加密的数据只能使用相应的私钥进行解密，这使得非对称加密适合用于安全通信和数字签名等场景</li>
</ul>
<p>常见的非对称加密算法包括 RSA（Rivest-Shamir-Adleman）、DSA（Digital Signature Algorithm）、ECC（Elliptic Curve Cryptography）等。</p>
<h3 id="非对称加密算法实现机密信息交换的基本过程"><a href="#非对称加密算法实现机密信息交换的基本过程" class="headerlink" title="非对称加密算法实现机密信息交换的基本过程"></a>非对称加密算法实现机密信息交换的基本过程</h3><p>甲方生成一对密钥并将其中的一把作为公用密钥向其它方公开；得到该公用密钥的乙方使用该密钥对机密信息进行加密后再发送给甲方；甲方再用自己保存的另一把专用密钥对加密后的信息进行解密。甲方只能用其专用密钥解密由其公用密钥加密后的任何信息。</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p><strong>1、对称加密中加密和解密使用的秘钥是同一个；非对称加密中采用两个密钥，一般使用公钥进行加密，私钥进行解密。</strong></p>
<blockquote>
<p>对称加密的加密过程和解密过程使用的同一个密钥，加密过程相当于用原文+密钥可以传输出密文，同时解密过程用密文-密钥可以推导出原文。<br>但非对称加密采用了两个密钥，一般使用公钥进行加密，使用私钥进行解密。</p>
</blockquote>
<p><strong>2、对称加密解密的速度比较快，非对称加密和解密花费的时间长、速度相对较慢。</strong></p>
<blockquote>
<p>对称加密解密的速度比较快，适合数据比较长时的使用。非对称加密和解密花费的时间长、速度相对较慢，只适合对少量数据的使用。</p>
</blockquote>
<p><strong>3、对称加密的安全性相对较低，非对称加密的安全性较高。</strong></p>
<blockquote>
<p>对称加密的过程中无法确保密钥被安全传递，密文在传输过程中是可能被第三方截获的，如果密码本也被第三方截获，则传输的密码信息将被第三方破获，安全性相对较低。</p>
</blockquote>
<blockquote>
<p>非对称加密算法中私钥是基于不同的算法生成不同的随机数，私钥通过一定的加密算法推导出公钥，但私钥到公钥的推导过程是单向的，也就是说公钥无法反推导出私钥。所以安全性较高。</p>
</blockquote>
]]></content>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>三次握手和四次挥手</title>
    <url>/2022/09/19/tree-way-handshake/</url>
    <content><![CDATA[<p>三次握手（Three-Way Handshake）和四次挥手（Four-Way Handshake）是 <strong>TCP</strong>（Transmission Control Protocol，传输控制协议）连接建立和断开的过程。</p>
<span id="more"></span>

<h2 id="三次握手："><a href="#三次握手：" class="headerlink" title="三次握手："></a>三次握手：</h2><h3 id="第一步（SYN）："><a href="#第一步（SYN）：" class="headerlink" title="第一步（SYN）："></a>第一步（SYN）：</h3><p>客户端向服务器发送一个 SYN（同步）包，表示客户端请求建立连接，并选择一个初始序列号（Sequence Number）。</p>
<h3 id="第二步（SYN-ACK）："><a href="#第二步（SYN-ACK）：" class="headerlink" title="第二步（SYN-ACK）："></a>第二步（SYN-ACK）：</h3><p>服务器接收到 SYN 包后，会发送一个 SYN-ACK 包作为响应。该包中包含了确认号（Acknowledgment Number），其值为客户端发送的序列号+1，同时服务器也选择一个初始序列号。</p>
<h3 id="第三步（ACK）："><a href="#第三步（ACK）：" class="headerlink" title="第三步（ACK）："></a>第三步（ACK）：</h3><p>客户端接收到服务器发送的 SYN-ACK 包后，会发送一个 ACK（确认）包作为确认。该 ACK 包中的确认号为服务器发送的序列号+1，表示客户端已经接收到了服务器的确认。<br>这样，通过这三次握手，TCP 连接就建立起来了，双方都可以开始进行数据传输。</p>
<h2 id="四次挥手："><a href="#四次挥手：" class="headerlink" title="四次挥手："></a>四次挥手：</h2><h3 id="第一步（FIN）："><a href="#第一步（FIN）：" class="headerlink" title="第一步（FIN）："></a>第一步（FIN）：</h3><p>当客户端想要关闭连接时，会向服务器发送一个 FIN（结束）包，表示客户端不再发送数据。</p>
<h3 id="第二步（ACK）："><a href="#第二步（ACK）：" class="headerlink" title="第二步（ACK）："></a>第二步（ACK）：</h3><p>服务器接收到客户端发送的 FIN 包后，会发送一个 ACK 包作为确认。但是，服务器可能还有未发送完的数据，因此服务器此时不会立即关闭连接。</p>
<h3 id="第三步（FIN）："><a href="#第三步（FIN）：" class="headerlink" title="第三步（FIN）："></a>第三步（FIN）：</h3><p>当服务器完成发送所有数据后，会向客户端发送一个 FIN 包，表示服务器已经准备好关闭连接了。</p>
<h3 id="第四步（ACK）："><a href="#第四步（ACK）：" class="headerlink" title="第四步（ACK）："></a>第四步（ACK）：</h3><p>客户端接收到服务器发送的 FIN 包后，会发送一个 ACK 包作为确认。然后，客户端等待一段时间（TIME_WAIT 状态），以确保服务器已经接收到了最后的 ACK 包，然后关闭连接。<br>这样，通过这四次挥手，TCP 连接就彻底关闭了。</p>
<p>总的来说，三次握手是建立 TCP 连接的过程，而四次挥手则是断开 TCP 连接的过程。这些过程确保了数据的可靠传输和连接的正常终止。</p>
]]></content>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>ssl</title>
    <url>/2022/02/19/ssl/</url>
    <content><![CDATA[<p>SSL（Secure Sockets Layer，安全套接层）是一种用于<strong>保护网络通信安全</strong>的协议。SSL 最初由网景公司（Netscape）开发，后来发展为 <strong>TLS</strong>（Transport Layer Security，传输层安全），TLS 取代了 SSL 成为更安全和更先进的协议。然而，人们通常仍然使用术语 SSL 来指代 TLS。</p>
<span id="more"></span>

<p>SSL&#x2F;TLS 协议提供了以下主要功能：</p>
<ol>
<li><p>加密（Encryption）：<br>SSL&#x2F;TLS 使用加密技术对数据进行加密，从而确保在网络上传输的数据在传输过程中不会被未经授权的人员窃听或窃取。常用的加密算法包括<strong>对称加密</strong>（如 AES）和<strong>非对称加密</strong>（如 RSA）。</p>
</li>
<li><p>身份认证（Authentication）：<br>SSL&#x2F;TLS 协议使用<strong>数字证书</strong>来验证通信双方的身份。数字证书由可信的第三方机构（CA，Certificate Authority）颁发，用于证明通信实体的身份。这样，通信双方可以确保他们正在与预期的对方进行通信，而不是中间人（Man-in-the-Middle）攻击。</p>
</li>
<li><p>数据完整性（Data Integrity）：<br>SSL&#x2F;TLS 使用哈希函数和消息认证码（MAC，Message Authentication Code）来保证数据在传输过程中不会被篡改。这确保了数据在传输过程中的完整性，即接收方能够检测到任何数据被篡改的情况。</p>
</li>
</ol>
<p><strong>SSL&#x2F;TLS 协议的工作流程大致如下</strong>：</p>
<ul>
<li><p>握手阶段：客户端发送一个连接请求给服务器，服务器在确认客户端的身份后，发送数字证书给客户端。客户端验证数字证书，然后生成一个随机密钥，用服务器的公钥加密后发送给服务器。接着，服务器使用私钥解密随机密钥。这样，双方就拥有了共享的密钥，用于后续的加密和解密操作。</p>
</li>
<li><p>加密通信：双方使用共享密钥进行加密和解密操作，确保了数据在传输过程中的安全性。</p>
</li>
<li><p>断开连接：通信结束后，双方发送关闭连接的通知，然后安全地关闭连接。</p>
</li>
</ul>
<p>SSL&#x2F;TLS 协议被广泛应用于 Web 浏览器和服务器之间的安全通信，以及其他需要保护通信安全性的场景，如电子邮件传输、文件传输等。</p>
]]></content>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>Cookie、sessionStorage、localStorage 的区别</title>
    <url>/2022/02/19/cookie-storage/</url>
    <content><![CDATA[<p>cookie、sessionStorage 和 localStorage 都是在 Web 浏览器中用于存储数据的机制，但它们之间有一些重要的区别。</p>
<span id="more"></span>

<h1 id="1-cookie："><a href="#1-cookie：" class="headerlink" title="1. cookie："></a>1. cookie：</h1><p>cookie 是由服务器发送到客户端并存储在客户端的文本文件，每次客户端向同一服务器发送请求时都会附上这些 cookie。主要用于跟踪用户的会话状态、记录用户的偏好设置等。</p>
<h3 id="Cookie-的特点包括："><a href="#Cookie-的特点包括：" class="headerlink" title="Cookie 的特点包括："></a>Cookie 的特点包括：</h3><ul>
<li>存储容量较小（每个 Cookie 通常限制在 4KB 左右）。</li>
<li>每次 HTTP 请求都会发送到服务器，包括 Cookie 信息，因此可能会影响性能。</li>
<li>可以设置 Cookie 的过期时间，使得 Cookie 在一定时间后失效。</li>
</ul>
<h1 id="2-sessionStorage："><a href="#2-sessionStorage：" class="headerlink" title="2. sessionStorage："></a>2. sessionStorage：</h1><p>sessionStorage 是 HTML5 引入的新特性，用于在客户端临时存储会话数据，该数据在当前会话期间有效，关闭标签页或浏览器时会被清除。</p>
<h3 id="sessionStorage-的特点包括："><a href="#sessionStorage-的特点包括：" class="headerlink" title="sessionStorage 的特点包括："></a>sessionStorage 的特点包括：</h3><ul>
<li>数据仅在当前会话期间有效，关闭标签页或浏览器时会被清除。</li>
<li>存储容量较大，通常比 Cookie 大得多（通常限制在 5MB 左右）。</li>
</ul>
<ul>
<li>数据仅在同一标签页或同一窗口中共享，不同标签页或窗口间不共享。</li>
</ul>
<h1 id="3-localStorage："><a href="#3-localStorage：" class="headerlink" title="3. localStorage："></a>3. localStorage：</h1><p>localStorage 也是 HTML5 引入的新特性，与 sessionStorage 相似，用于在客户端存储数据。不同的是，localStorage 中存储的数据在关闭标签页或浏览器后仍然保留，直到被用户手动清除。</p>
<h3 id="localStorage-的特点包括："><a href="#localStorage-的特点包括：" class="headerlink" title="localStorage 的特点包括："></a>localStorage 的特点包括：</h3><ul>
<li>存储容量较大，通常比 Cookie 大得多（通常限制在 5MB 左右）。</li>
<li>数据在浏览器关闭后仍然保留，直到被用户手动清除。</li>
<li>数据在同一域名下的所有标签页和窗口中共享。</li>
</ul>
<p>综上所述，Cookie 主要用于在客户端和服务器之间传递会话信息，而 sessionStorage 和 localStorage 用于在客户端存储临时数据。其中，sessionStorage 的数据在当前会话期间有效，而 localStorage 的数据则持久保存在客户端，直到被用户清除。localStorage 和 sessionStorage 的存储容量通常比 Cookie 大得多，并且可以更高效地使用。</p>
]]></content>
      <tags>
        <tag>JS</tag>
        <tag>http</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>xss攻击</title>
    <url>/2021/01/19/xss/</url>
    <content><![CDATA[<p>XSS（Cross-Site Scripting，跨站脚本攻击）是一种常见的 Web 安全漏洞，攻击者利用这种漏洞向网页中<strong>插入恶意脚本</strong>，从而在用户的浏览器中执行恶意代码。XSS 攻击通常分为三种类型：</p>
<span id="more"></span>

<h3 id="1-存储型-XSS："><a href="#1-存储型-XSS：" class="headerlink" title="1. 存储型 XSS："></a>1. 存储型 XSS：</h3><p>存储型 XSS 攻击，也称为持久型 XSS 攻击，是攻击者将恶意脚本存储在服务器端的数据库中。当用户访问包含恶意脚本的页面时，这些脚本从服务器端获取并执行，从而对用户进行攻击。</p>
<h3 id="2-反射型-XSS："><a href="#2-反射型-XSS：" class="headerlink" title="2. 反射型 XSS："></a>2. 反射型 XSS：</h3><p>反射型 XSS 攻击，也称为非持久型 XSS 攻击，是攻击者将恶意脚本作为 URL 参数发送给受害者。当受害者点击包含恶意脚本的链接时，这些脚本会反射到受害者的浏览器中执行，从而对用户进行攻击。</p>
<h3 id="3-DOM-型-XSS："><a href="#3-DOM-型-XSS：" class="headerlink" title="3. DOM 型 XSS："></a>3. DOM 型 XSS：</h3><p>DOM 型 XSS 攻击是攻击者利用客户端的漏洞，通过修改页面的 <code>DOM</code> 结构来执行恶意脚本。与存储型和反射型 XSS 不同，DOM 型 XSS 攻击不会将恶意脚本发送到服务器端，而是直接操作客户端的 DOM 来实现攻击。</p>
<p><strong>为了防止 XSS 攻击，可以采取以下措施</strong> ：</p>
<h3 id="1-输入验证："><a href="#1-输入验证：" class="headerlink" title="1.输入验证："></a>1.输入验证：</h3><p>对所有用户输入的数据进行验证和过滤，防止恶意脚本的注入。可以使用白名单机制来限制输入数据的类型和格式，过滤掉所有不合法的输入。</p>
<h3 id="2-输出编码："><a href="#2-输出编码：" class="headerlink" title="2.输出编码："></a>2.输出编码：</h3><p>在将用户输入的数据输出到页面时，使用适当的编码方式对数据进行转义，防止恶意脚本的执行。常用的编码方式包括 HTML 实体编码、JavaScript 转义编码等。</p>
<h3 id="3-设置-HTTP-头部："><a href="#3-设置-HTTP-头部：" class="headerlink" title="3.设置 HTTP 头部："></a>3.设置 HTTP 头部：</h3><p>使用<code>X-Content-Type-Options</code> 头部来防止浏览器的 MIME 类型猜测行为，使用 <code>Content-Security-Policy</code> 头部来限制页面加载的资源来源，防止恶意脚本的执行。</p>
<h3 id="4-Cookie-安全："><a href="#4-Cookie-安全：" class="headerlink" title="4.Cookie 安全："></a>4.Cookie 安全：</h3><p>设置 <code>HTTPOnly</code> 属性来限制 <code>Cookie</code> 只能通过 HTTP 协议传输，防止 JavaScript 脚本获取 <code>Cookie</code> 信息，从而减少受到 XSS 攻击的可能性。</p>
<h3 id="5-安全的开发实践："><a href="#5-安全的开发实践：" class="headerlink" title="5. 安全的开发实践："></a>5. 安全的开发实践：</h3><p>开发人员应当采用安全的编码实践，如避免使用 <code>eval</code> 函数、使用 CSP（Content Security Policy）等来限制页面加载的资源来源。</p>
<p>通过以上措施，可以有效地减少 XSS 攻击的风险，并提升 Web 应用程序的安全性</p>
]]></content>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟DOM和fiber</title>
    <url>/2023/11/10/virtual-dom-fiber/</url>
    <content><![CDATA[<p>在 React 中，Virtual DOM（虚拟 DOM）是一种内存中的表示，它是由 React 创建和维护的一种树形结构，用于表示真实 DOM 的抽象。当状态发生变化时，React 会通过比较新的 Virtual DOM 和旧的 Virtual DOM 的差异来确定需要更新的部分，并将这些变化应用到真实的 DOM 中，从而实现页面的更新。</p>
<span id="more"></span>

<h2 id="Virtual-DOM-的引入带来了以下好处："><a href="#Virtual-DOM-的引入带来了以下好处：" class="headerlink" title="Virtual DOM 的引入带来了以下好处："></a>Virtual DOM 的引入带来了以下好处：</h2><ol>
<li><p><strong>提高性能</strong>：<br>Virtual DOM 通过将真实 DOM 的操作转换为对虚拟 DOM 的操作，然后批量更新到真实 DOM 中，减少了对真实 DOM 的频繁操作。这样可以提高页面渲染的性能，减少了浏览器重绘和重排的次数，提升了用户体验。</p>
</li>
<li><p><strong>简化开发</strong>：<br>使用 Virtual DOM 可以使开发人员更专注于应用程序的逻辑和数据，而不必过多地关注 DOM 操作的细节。通过使用组件化开发模式，开发人员可以将 UI 拆分成小而独立的组件，每个组件都有自己的状态和行为，这样可以更容易地管理和维护应用程序的代码。</p>
</li>
<li><p><strong>跨平台兼容性</strong>：<br>由于 Virtual DOM 是一个与平台无关的抽象层，因此可以轻松地将 React 应用程序移植到不同的平台上，包括 Web、移动端和桌面端等。这样可以提高应用程序的可移植性和跨平台兼容性。</p>
</li>
<li><p><strong>方便的测试</strong>：<br>使用 Virtual DOM 可以方便地进行单元测试和集成测试，因为可以在内存中操作虚拟 DOM，而无需真实的浏览器环境。这样可以加快测试速度，提高开发效率。</p>
</li>
</ol>
<h3 id="实现虚拟-DOM-例子"><a href="#实现虚拟-DOM-例子" class="headerlink" title="实现虚拟 DOM 例子"></a>实现虚拟 DOM 例子</h3><ol>
<li>定义虚拟 DOM 元素</li>
<li>创建文本节点</li>
<li>将虚拟 DOM 渲染为真实 DOM</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义虚拟 DOM 元素</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">createElement</span> = (<span class="params">type, props, ...children</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      ...props,</span><br><span class="line">      <span class="attr">children</span>: children.<span class="title function_">map</span>(<span class="function">(<span class="params">child</span>) =&gt;</span></span><br><span class="line">        <span class="keyword">typeof</span> child === <span class="string">&quot;object&quot;</span> ? child : <span class="title function_">createTextElement</span>(child)</span><br><span class="line">      ),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建文本节点</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">createTextElement</span> = (<span class="params">text</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;TEXT_ELEMENT&quot;</span>,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">nodeValue</span>: text,</span><br><span class="line">      <span class="attr">children</span>: [],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将虚拟 DOM 渲染为真实 DOM</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">render</span> = (<span class="params">element, container</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> dom =</span><br><span class="line">    element.<span class="property">type</span> === <span class="string">&quot;TEXT_ELEMENT&quot;</span></span><br><span class="line">      ? <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">      : <span class="variable language_">document</span>.<span class="title function_">createElement</span>(element.<span class="property">type</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">isProperty</span> = (<span class="params">key</span>) =&gt; key !== <span class="string">&quot;children&quot;</span>;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(element.<span class="property">props</span>)</span><br><span class="line">    .<span class="title function_">filter</span>(isProperty)</span><br><span class="line">    .<span class="title function_">forEach</span>(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">      dom[name] = element.<span class="property">props</span>[name];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  element.<span class="property">props</span>.<span class="property">children</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">child</span>) =&gt;</span> <span class="title function_">render</span>(child, dom));</span><br><span class="line">  container.<span class="title function_">appendChild</span>(dom);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// React 的 createElement 和 render 函数使用</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyReact</span> = &#123;</span><br><span class="line">  createElement,</span><br><span class="line">  render,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">const</span> element = <span class="title class_">MyReact</span>.<span class="title function_">createElement</span>(</span><br><span class="line">  <span class="string">&quot;div&quot;</span>,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&quot;container&quot;</span> &#125;,</span><br><span class="line">  <span class="title class_">MyReact</span>.<span class="title function_">createElement</span>(<span class="string">&quot;h1&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;Hello, World!&quot;</span>),</span><br><span class="line">  <span class="title class_">MyReact</span>.<span class="title function_">createElement</span>(<span class="string">&quot;p&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;This is a paragraph.&quot;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> container = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>);</span><br><span class="line"><span class="title class_">MyReact</span>.<span class="title function_">render</span>(element, container);</span><br></pre></td></tr></table></figure>

<h3 id="diff-算法"><a href="#diff-算法" class="headerlink" title="diff 算法"></a>diff 算法</h3><ol>
<li><p>虚拟 DOM 树比较：在进行更新时，React 会将当前的虚拟 DOM 树与新的虚拟 DOM 树进行比较，找出差异。</p>
</li>
<li><p>差异检测：React 使用 深度优先搜索算法（DFS）对比两棵虚拟 DOM 树，找出两棵树之间的差异。它会逐个比较节点及其子节点，找出哪些节点需要更新、添加或删除。</p>
</li>
<li><p>Diff 策略：React 使用了一些优化策略来减少 DOM 操作次数：</p>
</li>
</ol>
<ul>
<li>同层比较：React 只会对比相同层级的节点，不会跨层级比较。</li>
<li>唯一标识：在进行节点比较时，React 会使用节点的唯一标识（通常是 key 属性）来判断节点是否相同，从而避免不必要的更新操作。</li>
<li>节点移动：React 会尽量复用已存在的节点，而不是重新创建新的节点。如果节点顺序改变，React 会尝试通过移动节点来达到更新效果，而不是直接删除和重新插入节点。</li>
<li>批量更新：React 会将多个更新操作合并成一个批量更新，然后一次性更新到真实 DOM 中，以减少页面重绘和重排的次数。</li>
</ul>
<ol start="4">
<li>应用差异：一旦找到了两棵虚拟 DOM 树之间的差异，React 就会根据这些差异来进行相应的操作，更新真实 DOM。</li>
</ol>
<h2 id="Fiber"><a href="#Fiber" class="headerlink" title="Fiber"></a>Fiber</h2><p>Fiber 是 React v16 中引入的一种新的协调算法，用于调度和管理 React 的渲染和更新过程。Fiber 的目标是使 React 应用程序更加流畅和响应，减少页面卡顿和掉帧的情况。<br>Fiber 的核心思想是将 React 的渲染过程分解为可中断的小任务，并且可以根据优先级来调度这些任务的执行顺序。这样可以使 React 在执行渲染任务时更加灵活，可以根据页面的需要来调整任务的优先级和执行顺序，从而提高用户体验。</p>
<p>Fiber 的引入使得 React 具备了更高的并发能力和更灵活的调度策略，使得 React 应用程序可以更好地适应不同的场景和用户需求。</p>
<p>综上所述，Virtual DOM 和 Fiber 是 React 内部机制中的两个关键概念，它们共同作用于 React 的渲染和更新过程中，提高了 React 应用程序的性能、效率和响应能力。Virtual DOM 优化了对真实 DOM 的操作，而 Fiber 则优化了 React 的渲染和更新调度过程。</p>
]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>CI/CD</title>
    <url>/2023/11/19/CICD/</url>
    <content><![CDATA[<h3 id="什么是-CICD"><a href="#什么是-CICD" class="headerlink" title="什么是 CICD"></a>什么是 CICD</h3><p>CICD（Continuous Integration and Continuous Deployment，持续集成和持续部署）是一种软件开发实践，旨在通过自动化软件构建、测试和部署过程，以便快速、频繁地将代码交付给生产环境。CICD 流程包括持续集成（Continuous Integration，CI）、持续交付（Continuous Delivery，CD）和持续部署（Continuous Deployment，CD）。</p>
<span id="more"></span>

<p><strong>持续集成（CI）</strong>是指开发人员频繁地将代码集成到共享的代码仓库中，并通过自动化构建和测试过程来验证代码的质量。这有助于减少集成问题、加快开发周期，并增强团队的协作。</p>
<p><strong>持续交付（CD）</strong>是指在通过持续集成验证后，自动地将代码部署到预发布环境中，以便进行进一步的测试和验证。持续交付可以确保软件的可靠性和稳定性，并使团队能够更快地将新功能交付给用户。</p>
<p><strong>持续部署（CD）</strong>是指在通过持续交付验证后，自动地将代码部署到生产环境中，以便向用户交付新功能和修复 bug。持续部署可以加快软件交付速度，并降低交付的风险。</p>
<p>要配置 CICD 流程，可以使用各种工具和平台，如 Jenkins、GitLab CI&#x2F;CD、Travis CI、CircleCI 等。通常，配置 CICD 流程需要以下步骤：</p>
<ol>
<li><p><strong>版本控制</strong>：将代码托管到版本控制系统中，如 Git，确保团队成员可以共享和协作开发代码。</p>
</li>
<li><p><strong>自动化构建</strong>：设置自动化构建过程，包括编译代码、运行单元测试、生成构建产物等。这可以通过构建工具如 Maven、Gradle、Webpack 等来实现。</p>
</li>
<li><p><strong>自动化测试</strong>：编写自动化测试脚本，包括单元测试、集成测试、端到端测试等，确保代码的质量和可靠性。</p>
</li>
<li><p><strong>持续集成</strong>：设置持续集成服务器，如 Jenkins，在代码提交后自动触发构建和测试过程，以验证代码的正确性。</p>
</li>
<li><p><strong>持续交付</strong>：在通过持续集成验证后，设置持续交付流程，自动将代码部署到预发布环境中进行进一步的测试和验证。</p>
</li>
<li><p><strong>持续部署</strong>：在通过持续交付验证后，设置持续部署流程，自动将代码部署到生产环境中，向用户交付新功能和修复 bug。</p>
</li>
<li><p><strong>监控和反馈</strong>：设置监控和日志记录机制，及时发现和解决生产环境中的问题，并收集用户反馈以改进产品。</p>
</li>
</ol>
<p>通过配置 CICD 流程，团队可以实现快速、可靠和持续地交付高质量的软件，提高开发效率和用户满意度。</p>
<h3 id="一段简单的-CICD-配置"><a href="#一段简单的-CICD-配置" class="headerlink" title="一段简单的 CICD 配置"></a>一段简单的 CICD 配置</h3><p>以下是一个简单的 CICD 配置示例，使用了 GitHub 作为版本控制系统，Jenkins 作为持续集成工具，和 Docker 作为容器化部署的工具。这个配置会在代码提交后，自动触发构建、测试和部署流程。</p>
<ol>
<li>GitHub 配置：</li>
</ol>
<p>在 GitHub 上创建一个新的代码仓库，并将你的代码上传到仓库中。</p>
<ol start="2">
<li>Jenkins 配置：</li>
</ol>
<p>在 Jenkins 中创建一个新的 Pipeline 项目，并将 GitHub 仓库链接到该项目。<br>在项目配置中，设置触发器，选择 GitHub Webhook 触发器，并添加 GitHub 仓库的 URL 和身份验证信息。<br>编写 Jenkinsfile，定义 Pipeline 的各个阶段和步骤，例如拉取代码、构建、测试、打包等。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">&#x27;Checkout&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                <span class="comment">// 拉取代码</span></span><br><span class="line">                git <span class="string">&#x27;https://github.com/your-repo.git&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;Build&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                <span class="comment">// 构建应用程序</span></span><br><span class="line">                sh <span class="string">&#x27;npm install&#x27;</span> <span class="comment">// 举例：使用npm进行构建</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;Test&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                <span class="comment">// 运行自动化测试</span></span><br><span class="line">                sh <span class="string">&#x27;npm test&#x27;</span> <span class="comment">// 举例：使用npm运行测试</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;Deploy&#x27;</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                <span class="comment">// 部署应用程序</span></span><br><span class="line">                sh <span class="string">&#x27;npm run deploy&#x27;</span> <span class="comment">// 举例：使用npm运行部署脚本</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    post &#123;</span><br><span class="line">        always &#123;</span><br><span class="line">            <span class="comment">// 清理工作目录</span></span><br><span class="line">            cleanWs()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>自动化测试：</li>
</ol>
<p>在代码仓库中编写自动化测试脚本，包括单元测试、集成测试等。<br>在 Jenkinsfile 中添加测试阶段，调用自动化测试脚本执行测试，并根据测试结果决定是否继续下一步。</p>
<ol start="4">
<li>Docker 配置：</li>
</ol>
<p>编写 Dockerfile，定义 Docker 镜像的构建过程，包括基础镜像、依赖安装、应用程序部署等。<br>在 Jenkinsfile 中添加 Docker 构建和部署阶段，使用 Docker 命令构建镜像并推送到镜像仓库，然后在目标服务器上拉取镜像并运行容器。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用官方 Node.js 14 镜像作为基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">14</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制 package.json 和 package-lock.json 到工作目录</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> package*.json ./</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装项目依赖</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm install</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将应用程序代码复制到工作目录</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义容器启动命令</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;npm&quot;</span>, <span class="string">&quot;start&quot;</span>]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>触发构建：</li>
</ol>
<p>提交代码到 GitHub 仓库中，Jenkins 会收到 Webhook 通知并自动触发 Pipeline 项目的构建流程。<br>Jenkins 会根据 Jenkinsfile 中定义的流程执行构建、测试和部署过程，最终将应用程序部署到目标服务器上。</p>
<p>这只是一个简单的 CICD 配置示例，实际的配置可能会更加复杂，涉及到更多的流程、工具和环境。但是通过这个示例，你可以了解到 CICD 配置的一般流程和步骤，以及如何使用 Jenkins、GitHub 和 Docker 等工具来实现自动化的构建、测试和部署流程。</p>
]]></content>
      <tags>
        <tag>前端质量保障</tag>
      </tags>
  </entry>
  <entry>
    <title>react和Vue中的key</title>
    <url>/2023/12/10/react-key/</url>
    <content><![CDATA[<p>在 React 或 Vue 项目中，在列表组件中为每个列表项指定一个唯一的 key 是很重要的，其作用主要有以下几点：</p>
<span id="more"></span>

<ol>
<li><p>优化性能：<br>在进行列表渲染时，React 和 Vue 都会使用虚拟 DOM（Virtual DOM）来比较新旧 DOM 树，从而确定需要更新的部分。使用 key 可以帮助 React 或 Vue 识别每个列表项的身份，从而更准确地确定哪些列表项需要更新，从而优化渲染性能。</p>
</li>
<li><p>避免重复元素：<br>如果列表项没有指定唯一的 key，当列表中的元素发生增删操作时，React 或 Vue 可能会错误地将新元素与旧列表中的元素混淆，导致不正确的更新或重复渲染相同的元素。</p>
</li>
<li><p>保持组件状态：<br>在 React 中，当组件重新渲染时，React 会尽量保持每个元素的状态不变，即使元素的位置发生了变化。通过为每个列表项指定唯一的 key，React 可以更好地跟踪元素的状态，从而确保组件的状态正确地保持在每个列表项上。</p>
</li>
<li><p>便于查找和调试：<br>使用 key 可以使得列表项在 React 或 Vue 的开发者工具中更易于查找和调试。你可以通过 key 来追踪每个列表项的变化，更好地理解渲染逻辑，并快速定位问题。</p>
</li>
</ol>
<p>因此，无论是在 React 还是 Vue 项目中，在列表组件中为每个列表项指定一个唯一的 key 是很重要的，它能够提高性能、避免问题、保持组件状态，并且方便调试。</p>
]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>模块化发展历程</title>
    <url>/2024/02/19/ModularDevelopmentHistory/</url>
    <content><![CDATA[<p>模块化的发展历程经历了多个阶段，从早期的自执行函数（IIFE）到现代的 ES Module，每个阶段都在不断地解决代码组织、依赖管理和模块加载等问题。下面是模块化发展历程的简要介绍：</p>
<h2 id="1-IIFE（立即执行函数）："><a href="#1-IIFE（立即执行函数）：" class="headerlink" title="1. IIFE（立即执行函数）："></a>1. IIFE（立即执行函数）：</h2><p>在早期的 JavaScript 开发中，为了避免全局变量的污染和命名冲突，开发者经常使用自执行函数（Immediately Invoked Function Expression，IIFE）来创建一个独立的作用域，将代码封装起来，达到模块化的效果。但是这种方式并没有真正解决模块化的问题，只是通过作用域的隔离来减少了全局污染的风险。</p>
<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用IIFE创建模块</span></span><br><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> privateVariable = <span class="string">&quot;I am private&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">privateFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;This is a private function&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 导出公共接口</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">MyModule</span> = &#123;</span><br><span class="line">    <span class="attr">publicMethod</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;This is a public method&quot;</span>);</span><br><span class="line">      <span class="title function_">privateFunction</span>();</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h2 id="2-AMD（异步模块定义）："><a href="#2-AMD（异步模块定义）：" class="headerlink" title="2. AMD（异步模块定义）："></a>2. AMD（异步模块定义）：</h2><p>AMD 是由 RequireJS 提出的一种模块定义规范，它允许开发者异步加载模块，从而提高了页面的加载性能。AMD 规范定义了 <code>define</code> 函数用于定义模块，以及 <code>require</code> 函数用于加载模块。通过 AMD，开发者可以明确地声明模块之间的依赖关系，并在需要时异步加载这些依赖模块。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用AMD定义模块</span></span><br><span class="line"><span class="title function_">define</span>([<span class="string">&quot;dependency1&quot;</span>, <span class="string">&quot;dependency2&quot;</span>], <span class="keyword">function</span> (<span class="params">dependency1, dependency2</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> privateVariable = <span class="string">&quot;I am private&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">privateFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;This is a private function&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 导出公共接口</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">publicMethod</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;This is a public method&quot;</span>);</span><br><span class="line">      <span class="title function_">privateFunction</span>();</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="3-CMD（通用模块定义）："><a href="#3-CMD（通用模块定义）：" class="headerlink" title="3. CMD（通用模块定义）："></a>3. CMD（通用模块定义）：</h2><p>CMD 是由 SeaJS 提出的一种模块定义规范，与 AMD 类似，但更加注重模块的延迟执行。CMD 规范定义了 <code>define</code> 函数用于定义模块，以及 <code>require</code>函数用于加载模块。相比于 AMD，CMD 更加倾向于将模块的加载放在模块内部，以便实现模块的按需加载。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用CMD定义模块</span></span><br><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="variable language_">module</span></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> dependency1 = <span class="built_in">require</span>(<span class="string">&quot;dependency1&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> dependency2 = <span class="built_in">require</span>(<span class="string">&quot;dependency2&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> privateVariable = <span class="string">&quot;I am private&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">privateFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;This is a private function&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 导出公共接口</span></span><br><span class="line">  <span class="built_in">exports</span>.<span class="property">publicMethod</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;This is a public method&quot;</span>);</span><br><span class="line">    <span class="title function_">privateFunction</span>();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="4-CommonJS："><a href="#4-CommonJS：" class="headerlink" title="4. CommonJS："></a>4. CommonJS：</h2><p>CommonJS 是一种服务器端模块的规范，最初是为 Node.js 设计的，后来也被广泛应用于前端开发中。CommonJS 规范定义了 <code>require</code> 函数用于加载模块，以及 <code>module.exports</code> 和 <code>exports</code> 对象用于导出模块。通过 CommonJS，开发者可以在 Node.js 环境下实现模块化的开发，并使用类似于服务器端的模块加载机制。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用CommonJS定义模块</span></span><br><span class="line"><span class="keyword">var</span> dependency1 = <span class="built_in">require</span>(<span class="string">&quot;dependency1&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> dependency2 = <span class="built_in">require</span>(<span class="string">&quot;dependency2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> privateVariable = <span class="string">&quot;I am private&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">privateFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;This is a private function&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出公共接口</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">publicMethod</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;This is a public method&quot;</span>);</span><br><span class="line">    <span class="title function_">privateFunction</span>();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5-UMD（通用模块定义）："><a href="#5-UMD（通用模块定义）：" class="headerlink" title="5. UMD（通用模块定义）："></a>5. UMD（通用模块定义）：</h2><p>UMD 是一种通用的模块定义规范，可以兼容 AMD、CMD 和 CommonJS 等多种模块加载机制。UMD 模块可以在浏览器端和 Node.js 环境下通用，使得开发者可以更灵活地选择适合自己项目的模块加载方式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用UMD定义模块</span></span><br><span class="line">(<span class="keyword">function</span> (<span class="params">root, factory</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">&quot;function&quot;</span> &amp;&amp; define.<span class="property">amd</span>) &#123;</span><br><span class="line">    <span class="comment">// AMD</span></span><br><span class="line">    <span class="title function_">define</span>([<span class="string">&quot;dependency1&quot;</span>, <span class="string">&quot;dependency2&quot;</span>], factory);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">exports</span> === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// CommonJS</span></span><br><span class="line">    <span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">factory</span>(<span class="built_in">require</span>(<span class="string">&quot;dependency1&quot;</span>), <span class="built_in">require</span>(<span class="string">&quot;dependency2&quot;</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 浏览器全局变量</span></span><br><span class="line">    root.<span class="property">MyModule</span> = <span class="title function_">factory</span>(root.<span class="property">dependency1</span>, root.<span class="property">dependency2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="variable language_">this</span>, <span class="keyword">function</span> (<span class="params">dependency1, dependency2</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> privateVariable = <span class="string">&quot;I am private&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">privateFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;This is a private function&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 导出公共接口</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">publicMethod</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;This is a public method&quot;</span>);</span><br><span class="line">      <span class="title function_">privateFunction</span>();</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="6-webpack（require-ensure）："><a href="#6-webpack（require-ensure）：" class="headerlink" title="6. webpack（require.ensure）："></a>6. webpack（require.ensure）：</h2><p>webpack 是一种现代化的模块打包工具，它支持多种模块化的规范，包括 CommonJS、AMD、ES Module 等。在 webpack 中，开发者可以使用 require.ensure 来实现按需加载模块，从而提高页面的加载性能。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在需要时动态加载模块</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">loadModule</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">require</span>.<span class="title function_">ensure</span>([<span class="string">&quot;./module&quot;</span>], <span class="keyword">function</span> (<span class="params"><span class="built_in">require</span></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable language_">module</span> = <span class="built_in">require</span>(<span class="string">&quot;./module&quot;</span>);</span><br><span class="line">    <span class="variable language_">module</span>.<span class="title function_">doSomething</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主程序入口</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 加载模块</span></span><br><span class="line">  <span class="title function_">loadModule</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动主程序</span></span><br><span class="line"><span class="title function_">main</span>();</span><br></pre></td></tr></table></figure>

<h2 id="7-ES-Module："><a href="#7-ES-Module：" class="headerlink" title="7. ES Module："></a>7. ES Module：</h2><p>ES Module 是 JavaScript 的官方模块化规范，从 ES6 开始被纳入到 JavaScript 的标准中。ES Module 允许开发者使用 <code>import</code> 和 <code>export</code> 语法来定义和导出模块，从而实现了原生的模块化开发。ES Module 在浏览器和 Node.js 环境下都得到了广泛的支持，并成为了现代 JavaScript 开发的主流模块化方式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用ES Module定义模块</span></span><br><span class="line"><span class="keyword">import</span> dependency1 <span class="keyword">from</span> <span class="string">&quot;dependency1&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> dependency2 <span class="keyword">from</span> <span class="string">&quot;dependency2&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> privateVariable = <span class="string">&quot;I am private&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">privateFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;This is a private function&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出公共接口</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">publicMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;This is a public method&quot;</span>);</span><br><span class="line">  <span class="title function_">privateFunction</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-："><a href="#8-：" class="headerlink" title="8. &lt;script type=&quot;module&quot;&gt;："></a>8. <code>&lt;script type=&quot;module&quot;&gt;</code>：</h2><p>HTML 的<code>&lt;script type=&quot;module&quot;&gt;</code>标签是浏览器原生支持的 ES Module 的加载方式。通过在 HTML 中直接使用这个标签，开发者可以加载并执行 ES Module，从而实现了在浏览器端的模块化开发。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>ES Module Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用ES Module加载模块 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">import</span> &#123; publicMethod &#125; <span class="keyword">from</span> <span class="string">&quot;./module.js&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">publicMethod</span>();</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title>闭包</title>
    <url>/2023/06/20/closure/</url>
    <content><![CDATA[<p>闭包是指函数与其词法环境的组合，函数可以访问其词法作用域中的变量，即使在函数定义之后执行也可以访问到。闭包可以在函数内部创建私有变量，并且可以通过返回函数或传递函数作为参数的方式，将这些私有变量暴露给外部作用域。闭包是 JavaScript 中非常强大和常用的特性，它能够帮助开发者实现许多功能，例如模块化、封装、延迟执行等。</p>
<span id="more"></span>

<p>以下是闭包的常用场景：</p>
<h2 id="1-封装私有变量："><a href="#1-封装私有变量：" class="headerlink" title="1. 封装私有变量："></a>1. 封装私有变量：</h2><p>使用闭包可以创建具有私有变量的函数，这些变量对外部代码是不可见的。通过在函数内部定义变量，并在返回的函数中引用这些变量，可以实现私有变量的封装，防止外部代码直接访问和修改。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ++count;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = <span class="title function_">createCounter</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">counter</span>()); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">counter</span>()); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h2 id="2-模块化开发："><a href="#2-模块化开发：" class="headerlink" title="2. 模块化开发："></a>2. 模块化开发：</h2><p>闭包可以用于实现模块化开发，通过将模块的功能封装在闭包中，并返回一个包含公共接口的对象或函数，从而隐藏模块内部的实现细节，只暴露必要的方法或属性给外部使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> calculator = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">subtract</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">add</span>: add,</span><br><span class="line">    <span class="attr">subtract</span>: subtract,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(calculator.<span class="title function_">add</span>(<span class="number">5</span>, <span class="number">3</span>)); <span class="comment">// 8</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(calculator.<span class="title function_">subtract</span>(<span class="number">5</span>, <span class="number">3</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h2 id="3-事件处理程序："><a href="#3-事件处理程序：" class="headerlink" title="3. 事件处理程序："></a>3. 事件处理程序：</h2><p>闭包常用于事件处理程序中，可以在事件处理函数中访问外部作用域的变量。这种方式使得事件处理程序可以访问和修改定义事件处理程序的函数中的变量，而不需要将这些变量暴露给全局作用域。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createButton</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> button = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;button&quot;</span>);</span><br><span class="line">  button.<span class="property">textContent</span> = <span class="string">&quot;Click me&quot;</span>;</span><br><span class="line">  button.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Button clicked <span class="subst">$&#123;count&#125;</span> times`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> button;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> button = <span class="title function_">createButton</span>();</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(button);</span><br></pre></td></tr></table></figure>

<h2 id="4-延迟执行："><a href="#4-延迟执行：" class="headerlink" title="4. 延迟执行："></a>4. 延迟执行：</h2><p>闭包可以用于实现延迟执行，即将一个函数作为参数传递给另一个函数，并在需要时调用该函数。由于闭包可以访问外部作用域的变量，因此可以在内部函数中引用外部作用域的变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">delay</span>(<span class="params">callback, milliseconds</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(callback, milliseconds);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">delay</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Delayed message&quot;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>这些是闭包的一些常用场景，闭包在 JavaScript 中被广泛应用于函数式编程、模块化开发、事件处理、异步编程等方面，是 JavaScript 中非常重要和强大的特性之一。</p>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>Dom树怎么形成</title>
    <url>/2023/09/20/generate-dom/</url>
    <content><![CDATA[<p>当浏览器加载 HTML 文档时，它会执行一系列步骤来解析文档并构建 DOM 树。这个过程可以分为以下几个阶段：</p>
<span id="more"></span>

<ol>
<li><p><strong>字节流转换为字符流</strong>：<br>首先，浏览器会将接收到的字节流（例如从服务器传输过来的数据）转换为字符流。这个过程通常涉及到字符编码的转换，例如将字节流解码成 <code>UTF-8</code> 字符流。</p>
</li>
<li><p><strong>词法分析（Tokenization）</strong>：<br>接着，浏览器将字符流分解成一个个标记（Token），这个过程称为词法分析。标记通常对应 HTML 文档中的词法单元，比如元素、属性、文本内容等。词法分析器会识别出标签、属性和文本等各种不同类型的标记，并且为每个标记分配一个标识符。</p>
</li>
<li><p><strong>构建节点对象</strong>：<br>一旦词法分析完成，浏览器就会根据这些标记构建 DOM 节点对象。每个 HTML 元素对应一个 <code>DOM</code> 节点，每个 <code>DOM</code> 节点都有相应的属性和方法。节点之间的关系由标记之间的层级关系来确定。例如，标签内的文本会成为该标签的子节点。</p>
</li>
<li><p><strong>构建 DOM 树</strong>：<br>接下来，浏览器将构建的 DOM 节点组织成一棵树，这棵树就是 DOM 树。DOM 树的根节点是<code>&lt;html&gt;</code>元素，它的子节点包括<code>&lt;head&gt;</code>和<code>&lt;body&gt;</code>等。根据 HTML 文档的结构，DOM 树的每个节点都有相应的父节点和子节点。</p>
</li>
<li><p><strong>CSS 解析和样式计算</strong>：<br>一旦 DOM 树构建完成，浏览器会继续解析外部 <code>CSS</code> 样式表和内部样式，并将这些样式应用到 DOM 树上的相应节点。这个过程称为样式计算，它会确定每个节点的最终样式。</p>
</li>
<li><p><strong>渲染页面</strong>：<br>最后，浏览器将 DOM 树和样式表结合起来，计算每个节点的布局信息，并将页面的内容绘制到屏幕上。这个过程称为页面渲染，它包括计算布局、绘制文本和图形等操作，最终呈现出用户所看到的页面。</p>
</li>
</ol>
<p>通过这些步骤，浏览器可以将 HTML 文档解析并渲染成用户可见的页面，同时构建出一棵表示页面结构和内容的 DOM 树，开发者可以通过 JavaScript 来操作这棵树，实现页面的动态交互和更新。</p>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack的热更新原理</title>
    <url>/2024/02/20/hot-module-replacement/</url>
    <content><![CDATA[<p>Webpack 的热更新（Hot Module Replacement，HMR）是一种使得开发者在修改代码时，无需手动刷新浏览器页面即可立即查看到更新效果的技术。其原理如下：</p>
<span id="more"></span>

<ol>
<li><p><strong>启动 HMR 服务器</strong>：<br>当你在 Webpack 配置中启用了热更新时，Webpack 会启动一个内置的 HMR 服务器，用于监听文件变化并通知浏览器进行更新。</p>
</li>
<li><p><strong>监视文件变化</strong>：<br>当你修改了一个文件并保存时，Webpack 会检测到文件的变化，并根据配置文件中的规则决定哪些模块需要进行热更新。</p>
</li>
<li><p><strong>构建新模块</strong>：<br>一旦 Webpack 确定了哪些模块需要更新，它会重新构建这些模块，并生成新的模块代码。</p>
</li>
<li><p><strong>向浏览器发送更新通知</strong>：<br>完成模块的重新构建后，Webpack 会将更新的模块代码通过 <code>WebSocket</code> 或者 <code>XHR</code> 等方式发送到浏览器端。</p>
</li>
<li><p><strong>浏览器端更新模块</strong>：<br>浏览器接收到更新的模块代码后，会利用 Webpack 的运行时环境（runtime）来替换对应的模块，从而实现页面的更新。Webpack 的运行时环境会自动地将新模块的代码注入到当前页面中，并更新相关的组件、样式等，同时保持页面的状态不变。</p>
</li>
</ol>
<p>通过这种方式，Webpack 的热更新技术使得开发者可以在修改代码后立即查看到更新效果，无需手动刷新浏览器页面，提高了开发效率和体验。需要注意的是，热更新仅适用于开发环境，在生产环境中仍然需要手动刷新页面以获取最新的代码。</p>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>React 中的合成事件</title>
    <url>/2024/01/11/React-SyntheticEvent/</url>
    <content><![CDATA[<p>React 中的合成事件（SyntheticEvent）是一种封装了原生浏览器事件的虚拟事件对象。React 通过合成事件来处理浏览器事件，而不直接使用原生的事件对象。这样做的原因有以下几点：</p>
<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  handleClick = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 阻止事件的默认行为</span></span><br><span class="line">    event.<span class="title function_">preventDefault</span>();</span><br><span class="line">    <span class="comment">// 输出事件对象</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Clicked!&quot;</span>, event);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">MyComponent</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在这个示例中，我们定义了一个 MyComponent 组件，并在组件中定义了一个点击事件处理函数 handleClick。在 render 方法中，我们将 handleClick 函数绑定到了按钮的 onClick 事件上。当按钮被点击时，React 会自动创建一个合成事件对象，并将它传递给 handleClick 函数。在 handleClick 函数中，我们可以像使用原生事件对象一样使用合成事件对象，例如阻止默认行为、获取事件目标等。</p>
</blockquote>
<ol>
<li><p><strong>跨浏览器兼容性</strong>：<br>React 的合成事件是跨浏览器兼容的，它会自动处理不同浏览器之间的差异，使得开发者无需关心不同浏览器的兼容性问题。</p>
</li>
<li><p><strong>性能优化</strong>：<br>React 的合成事件采用了事件委托机制，将事件处理逻辑集中在顶层容器上，而不是将事件处理函数直接绑定到每个 DOM 元素上。这样可以减少内存占用和事件绑定数量，提高页面性能。</p>
</li>
<li><p><strong>事件池</strong>：<br>React 的合成事件采用了事件池（Event Pool）机制，重用了事件对象，减少了对象创建和销毁的开销。当事件处理函数执行完毕后，事件对象会被重置并放回到事件池中，以供下次使用。</p>
</li>
<li><p><strong>事件系统扩展</strong>：<br>React 的合成事件系统提供了丰富的 API 和功能，可以方便地进行事件的捕获、冒泡、阻止默认行为、停止事件传播等操作，同时还支持事件委托和事件代理等高级特性。</p>
</li>
</ol>
<p>综上所述，React 使用合成事件来统一处理浏览器事件，提供了跨浏览器兼容性、性能优化和丰富的事件处理功能，使得开发者可以更轻松地编写可维护、高性能的 React 应用。</p>
]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>从浏览器地址栏输入url到请求返回发生了什么</title>
    <url>/2020/08/25/input-url-brower/</url>
    <content><![CDATA[<p>当我们在浏览器地址栏输入 url(统一资源定位符)，例如： <a href="https://example.com/">https://example.com</a>, 浏览器会执行以下步骤：</p>
<h2 id="1-URL-解析"><a href="#1-URL-解析" class="headerlink" title="1. URL 解析"></a>1. URL 解析</h2><span id="more"></span>

<p>浏览器会解析你输入的 URL，提取出协议（HTTP&#x2F;HTTPS）、主机名（例如 <a href="http://www.example.com)、路径(例如/path/to/resource%EF%BC%89%E7%AD%89%E4%BF%A1%E6%81%AF%E3%80%82">www.example.com）、路径（例如/path/to/resource）等信息。</a></p>
<h2 id="2-DNS-解析"><a href="#2-DNS-解析" class="headerlink" title="2. DNS 解析"></a>2. DNS 解析</h2><p>如果主机名是一个域名而不是 IP 地址，浏览器会执行 DNS 解析，将域名解析为对应的 IP 地址。这通常涉及向 DNS 服务器发送查询请求，获取到对应的 IP 地址。</p>
<h3 id="DNS-是什么"><a href="#DNS-是什么" class="headerlink" title="DNS 是什么"></a>DNS 是什么</h3><p>DNS（Domain Name System，域名系统）是互联网中用于将域名（如 example.com）转换为相应 IP 地址的分布式命名系统。它充当了互联网上域名和 IP 地址之间的映射关系数据库。</p>
<h3 id="DNS-解析"><a href="#DNS-解析" class="headerlink" title="DNS 解析"></a>DNS 解析</h3><p>DNS 解析是指将域名解析成相应的 IP 地址的过程。当你在浏览器中输入一个域名时，例如 <a href="http://www.example.com,浏览器首先需要将这个域名解析为对应的/">www.example.com，浏览器首先需要将这个域名解析为对应的</a> IP 地址，才能向服务器发送请求。DNS 解析的过程如下：</p>
<h4 id="1-浏览器缓存"><a href="#1-浏览器缓存" class="headerlink" title="1. 浏览器缓存"></a>1. 浏览器缓存</h4><p>浏览器会首先检查自己的 DNS 缓存，看是否已经解析过这个域名。如果之前已经解析过，并且缓存未过期，浏览器会直接使用缓存中的 IP 地址，无需进行 DNS 查询。</p>
<h4 id="2-操作系统缓存"><a href="#2-操作系统缓存" class="headerlink" title="2. 操作系统缓存"></a>2. 操作系统缓存</h4><p>如果浏览器缓存中没有找到对应的记录，浏览器会检查操作系统的 DNS 缓存。操作系统也会缓存之前解析过的域名和 IP 地址，以提高解析效率。</p>
<h4 id="3-本地-DNS-解析器"><a href="#3-本地-DNS-解析器" class="headerlink" title="3. 本地 DNS 解析器"></a>3. 本地 DNS 解析器</h4><p>如果在操作系统缓存中也没有找到对应的记录，浏览器会向本地 DNS 解析器发起查询请求。通常，本地 DNS 解析器由你的 ISP（互联网服务提供商）或者其他网络服务提供商提供。本地 DNS 解析器会首先查看自己的缓存，如果有相应的记录，则返回 IP 地址；否则，它会向根域名服务器发起查询请求。</p>
<h4 id="4-递归查询"><a href="#4-递归查询" class="headerlink" title="4. 递归查询"></a>4. 递归查询</h4><p>如果本地 DNS 解析器在缓存中没有找到对应的记录，它会向根域名服务器发送递归查询请求。根域名服务器复杂存储顶级域名服务器（如.com、.org、.net 等）的 IP 地址。根域名服务器会返回顶级域名服务器的 IP 地址给本地 DNS 解析器。</p>
<h4 id="5-迭代查询"><a href="#5-迭代查询" class="headerlink" title="5. 迭代查询"></a>5. 迭代查询</h4><p>本地 DNS 解析器收到顶级域名服务器的 IP 地址后，会向顶级域名服务器发起迭代查询请求，询问下一级域名服务器的 IP 地址。例如，如果要解析的域名是<a href="http://www.example.com,那么顶级域名服务器会返回.com域的权威域名服务器的ip地址./">www.example.com,那么顶级域名服务器会返回.com域的权威域名服务器的IP地址。</a></p>
<h4 id="6-权威域名服务器查询"><a href="#6-权威域名服务器查询" class="headerlink" title="6. 权威域名服务器查询"></a>6. 权威域名服务器查询</h4><p>本地 DNS 解析器收到权威域名服务器的 IP 地址后，会向权威域名服务器发起查询请求，获取要解析域名的具体 IP 地址。例如，权威域名服务器会返回 <a href="http://www.example.com/">www.example.com</a> 的 IP 地址给本地 DNS 解析器。</p>
<h4 id="7-返回解析结果"><a href="#7-返回解析结果" class="headerlink" title="7. 返回解析结果"></a>7. 返回解析结果</h4><p>本地 DNS 解析器收到 IP 地址后，会将结果返回给浏览器，浏览器会将这个 IP 地址用于建立 TCP 连接，并向服务器发送请求。</p>
<h2 id="3-建立-TCP-连接"><a href="#3-建立-TCP-连接" class="headerlink" title="3. 建立 TCP 连接"></a>3. 建立 TCP 连接</h2><p>浏览器通过 IP 地址和端口号（默认 HTTP 的端口是 80，HTTPS 的端口是 443）与服务器建立 TCP 连接。这个过程中会进行三次握手以确立连接。</p>
<h2 id="4-发起-HTTP-请求"><a href="#4-发起-HTTP-请求" class="headerlink" title="4. 发起 HTTP 请求"></a>4. 发起 HTTP 请求</h2><p>一旦建立了 TCP 连接，浏览器就会发送一个 HTTP 请求到服务器。这个请求包含了之前解析得到的 URL 中的信息，例如主机名、路径等，以及其他的请求头部信息（如用户代理、cookie 等）。</p>
<h2 id="5-服务器处理请求"><a href="#5-服务器处理请求" class="headerlink" title="5. 服务器处理请求"></a>5. 服务器处理请求</h2><p>服务器收到请求后，会根据请求的内容进行处理，可能会访问数据库、执行后端代码等操作，然后生成一个 HTTP 响应。</p>
<h2 id="6-返回-HTTP-响应"><a href="#6-返回-HTTP-响应" class="headerlink" title="6. 返回 HTTP 响应"></a>6. 返回 HTTP 响应</h2><p>服务器会将生成的 HTTP 响应发送回浏览器。这个响应包括一个状态码（例如 200 表示成功，404 表示未找到资源等）、响应头部（包含内容类型、内容长度等信息），以及响应体（实际的内容）。</p>
<h2 id="7-浏览器处理响应"><a href="#7-浏览器处理响应" class="headerlink" title="7. 浏览器处理响应"></a>7. 浏览器处理响应</h2><p>浏览器收到响应后，会根据响应的内容进行相应的处理。这可能涉及渲染 HTML、执行 JavaScript、应用 CSS 样式等操作。</p>
<blockquote>
<p>浏览器会根据响应头部中的内容类型（Content-Type）来确定如何处理响应体。常见的内容类型包括：</p>
</blockquote>
<ul>
<li>text&#x2F;html：HTML 文档。</li>
<li>text&#x2F;css：CSS 样式表。</li>
<li>application&#x2F;javascript：JavaScript 文件。</li>
<li>image&#x2F;png、image&#x2F;jpeg：图片文件等。<br>如果是 HTML 文档，浏览器会将其解析成 DOM 树，并开始渲染页面；如果是 CSS 文件，浏览器会应用样式；如果是 JavaScript 文件，浏览器会执行其中的脚本代码等等。</li>
</ul>
<p>一旦浏览器解析了 HTML 文档并构建了 DOM 树，它会开始渲染页面。这个过程包括:</p>
<ul>
<li>根据 DOM 树和 CSS 样式计算每个元素的大小、位置等属性。</li>
<li>将元素布局到页面上的正确位置。</li>
<li>将元素绘制到屏幕上</li>
</ul>
<p>在渲染过程中，浏览器还会处理 JavaScript 代码的执行、事件绑定等操作。</p>
<h2 id="8-显示页面"><a href="#8-显示页面" class="headerlink" title="8. 显示页面"></a>8. 显示页面</h2><p>最后，浏览器会根据响应的内容将页面呈现给用户，在用户界面中显示网页内容。</p>
]]></content>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>CI环境下的npm优化及工程化问题解析</title>
    <url>/2024/02/25/ci-npm/</url>
    <content><![CDATA[<h2 id="CI-环境下的-npm-优化"><a href="#CI-环境下的-npm-优化" class="headerlink" title="CI 环境下的 npm 优化"></a>CI 环境下的 npm 优化</h2><p>CI 环境下的 npm 配置 和 本地环境下的 npm 操作有些许不同，我们首先来看看 CI 环境下的 npm 优化方法</p>
<h3 id="1-合理使用-npm-ci-命令-和-npm-install-命令"><a href="#1-合理使用-npm-ci-命令-和-npm-install-命令" class="headerlink" title="1. 合理使用 npm ci 命令 和 npm install 命令"></a>1. 合理使用 npm ci 命令 和 npm install 命令</h3><p>顾名思义，<code>npm ci</code> 命令就是专门为 CI 环境准备的安装命令，相比于 <code>npm install</code>命令，它的不同之处有以下几点。</p>
<span id="more"></span>

<ul>
<li><code>npm ci</code> 命令要求项目中必须存在 package-lock.json 或 <code>npm-shrinkwrap.json</code>命令</li>
<li><code>npm ci</code> 命令完全根据 package-lock.json 文件安装依赖，这样可以保证开发团队成员使用版本一致的依赖。</li>
<li>因为 <code>npm ci</code> 命令完全根据 package-lock.json 文件安装依赖，因此在安装过程中，它不需要求解依赖满足问题及构造依赖树，安装过程更加迅速。</li>
<li><code>npm ci</code> 命令在执行安装时会先删除项目中现有的 <code>node_modules</code> 目录，重新安装。</li>
<li><code>npm ci</code> 命令只能一次性安装项目中所有的依赖包，无法安装单个依赖包。</li>
<li>如果 package-lock.json 文件和 package.json 文件冲突，那么执行 <code>npm ci</code> 命令时会直接报错。</li>
<li>执行 <code>npm ci</code> 命令永远不会改变 package.json 和 package-lock.json 文件的内容。</li>
</ul>
<p>基于以上特效，我们在 CI 环境下使用 <code>npm ci</code> 命令代替 <code>npm install</code> 命令时，一般会获得更加稳定、一致、迅速的安装体验</p>
<h3 id="2-使用-package-lock-json-文件缩短依赖安装时间"><a href="#2-使用-package-lock-json-文件缩短依赖安装时间" class="headerlink" title="2. 使用 package-lock.json 文件缩短依赖安装时间"></a>2. 使用 package-lock.json 文件缩短依赖安装时间</h3><p>项目中使用 package-lock.json 文件一般可以显著缩短依赖安装时间。这是因为 package-lock.json 文件中已经缓存了每个包的具体版本信息和下载链接，不要再去远程仓库进行查询即可直接进入文件完整性校验环节，减少大量网络请求。</p>
<p>除了以上内容之外，在 CI 环境下，缓存 <code>node_modules</code> 目录文件也是企业使用包管理工具常用的优化方法。</p>
<h2 id="为什么有-xxxDependencies"><a href="#为什么有-xxxDependencies" class="headerlink" title="为什么有 xxxDependencies"></a>为什么有 xxxDependencies</h2><p>npm 设计了以下几种依赖类型声明</p>
<ul>
<li>dependencies： 项目依赖</li>
<li>devDependencies： 开发依赖</li>
<li>peerDependencies： 同版本依赖</li>
<li>bundledDependencies： 捆绑依赖</li>
<li>optionalDependencies： 可选依赖</li>
</ul>
<h3 id="1-dependencies：-项目依赖"><a href="#1-dependencies：-项目依赖" class="headerlink" title="1.dependencies： 项目依赖"></a>1.dependencies： 项目依赖</h3><p>这些依赖会成为线上生产环节中代码组成部分，当它关联的 npm 包会下载时，dependencies 下的模块也会作为依赖一起被下载。</p>
<h3 id="2-devDependencies：-开发依赖"><a href="#2-devDependencies：-开发依赖" class="headerlink" title="2.devDependencies： 开发依赖"></a>2.devDependencies： 开发依赖</h3><p>不会自动下载，因为 devDependencies 一般只在开发阶段起作用，或只在开发环境中被用到。 如 webpack,预处理器 babel-loader、scss-loader,测试工具 E2E、Chai 等，这些都是辅助开发的工具包，无须在生产环境中使用。</p>
<blockquote>
<p>并不是只有 dependencies 下的模块才会被一起打包，而 devDependencies 下的模块一定不会被打包。实际上，模块是否作为依赖被打包，完全取决于项目里是否引入了该模块。</p>
</blockquote>
<h3 id="3-peerDependencies：-同版本依赖"><a href="#3-peerDependencies：-同版本依赖" class="headerlink" title="3.peerDependencies： 同版本依赖"></a>3.peerDependencies： 同版本依赖</h3><p>简单来说： 如果你安装了我，最好你也安装我的依赖。</p>
<h3 id="4-bundledDependencies：-捆绑依赖"><a href="#4-bundledDependencies：-捆绑依赖" class="headerlink" title="4.bundledDependencies： 捆绑依赖"></a>4.bundledDependencies： 捆绑依赖</h3><p>和 npm pack 打包命令有关。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;test&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;dep&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.0.2&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;devD1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.0.2&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;bundledDependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;bundleD1&quot;</span><span class="punctuation">,</span> <span class="string">&quot;bundleD1&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意：bundledDependencies 中指定的依赖包必须先在 dependencies 和 devDependencies 中声明过，否则执行 <code>npm pack</code> 命令阶段会报错。</p>
</blockquote>
<h3 id="5-optionalDependencies：-可选依赖"><a href="#5-optionalDependencies：-可选依赖" class="headerlink" title="5.optionalDependencies： 可选依赖"></a>5.optionalDependencies： 可选依赖</h3><p>该依赖如果安装失败，也不会影响整个安装过程。一般很少使用它，也不建议使用，会增加项目的不确定性和复杂性。</p>
]]></content>
      <tags>
        <tag>前端质量保障</tag>
      </tags>
  </entry>
  <entry>
    <title>JSDoc</title>
    <url>/2018/03/04/JSDoc/</url>
    <content><![CDATA[<p>这个是<a href="https://jsdoc.bootcss.com/">JSDoc 官方文档</a>，我这边简单做一些介绍。</p>
<span id="more"></span>

<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>JSDoc 3 是一个用于 JavaScript 的 API 文档生成器，类似于 Javadoc 或 phpDocumentor。可以将文档注释直接添加到源代码中。JSDoc 工具将扫描您的源代码并为您生成一个 HTML 文档网站。</p>
<h1 id="向代码中添加文档注释"><a href="#向代码中添加文档注释" class="headerlink" title="向代码中添加文档注释"></a>向代码中添加文档注释</h1><p>JSDoc 的目的是记录 JavaScript 应用程序或库的 API。假设您想要记录诸如模块、名称空间、类、方法、方法参数等内容。</p>
<p>JSDoc 注释通常应该放在记录代码之前。为了被 JSDoc 解析器识别，每个注释必须以 &#x2F;** 序列开头。以 &#x2F;<em>、&#x2F;</em>**开头或超过 3 颗星的注释将被忽略。这个特性用于控制解析注释块的功能。</p>
<p>可以使用特殊的 JSDoc 标签 来提供更多信息。例如，如果函数是类的构造函数，则可以通过添加 @constructor 标记来表示。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents a book.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@constructor</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">title</span> - The title of the book.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">author</span> - The author of the book.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Book</span>(<span class="params">title, author</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="生成网站"><a href="#生成网站" class="headerlink" title="生成网站"></a>生成网站</h3><p>一旦你的代码是已注释的，你可以是用 JSDoc 3 的工具从源文件中生成一个 HTML 网站。</p>
<p>默认情况下，JSDoc 使用内置的“默认”模板将文档转换为 HTML。您可以根据自己的需要编辑此模板，或者创建一个全新的模板（如果您喜欢的话）。</p>
<p>在命令行上运行文档生成器：</p>
<p><code>jsdoc book.js</code></p>
<p>此命令将在当前工作目录中创建名为 <code>out/</code> 的目录。在该目录中，您将找到生成的 HTML 页面。</p>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>Asset Modules资源模块</title>
    <url>/2024/03/10/asset-module/</url>
    <content><![CDATA[<p>Asset Modules 资源模块，针对于图片字体等这一类型的文件模块，无须额外的预处理器，webpack 可以通过一些配置完成对它们的解析，这是 webpack5 新加入的，和 <code>file-loader</code>,<code>raw-loader</code>,<code>url-loader</code> 预处理器功能相似</p>
<span id="more"></span>

<h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><p>Asset Modules 类型通过添加 4 个新的模块 type 来取代所有这些 loader</p>
<ul>
<li><strong>asset&#x2F;resource</strong> 发出一个单独的文件并导出 URL。和 <code>file-loader</code> 类似</li>
<li><strong>asset&#x2F;inline</strong> 和 <code>url-loader</code>相似，处理文件导入地址并将其替换成 data URL,默认是 <code>Base64</code> 格式编码的 URL</li>
<li><strong>asset&#x2F;source</strong> 和<code>raw-loader</code>很像，以字符串形式导出文件资源</li>
<li><strong>asset</strong> 在导出单独的文件 和 data URL 间自动选择，可以通过修改配置项影响自动选择的标准</li>
</ul>
<h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./a.js&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;&quot;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.jpg$/</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;asset/resource&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;none&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>打包入口文件是<code>a.js</code><br>a.js 文件内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> img <span class="keyword">from</span> <span class="string">&quot;./sky.jpg&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(img);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dom = <span class="string">`&lt;img src=&#x27;<span class="subst">$&#123;img&#125;</span>&#x27; /&gt;`</span>;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;main&quot;</span>).<span class="property">innerHTML</span> = dom;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>打包后目录里生成<code>6d99f3aefcfa4bj41a7f.jpg</code>,这个是 sky.jpg 被 asset&#x2F;resource 处理后生成的。</p>
<h2 id="自定义文件名称"><a href="#自定义文件名称" class="headerlink" title="自定义文件名称"></a>自定义文件名称</h2><h3 id="1-通过-generator-filename-配置"><a href="#1-通过-generator-filename-配置" class="headerlink" title="1. 通过 generator.filename 配置"></a>1. 通过 generator.filename 配置</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [&#123;</span><br><span class="line">    <span class="attr">test</span>: <span class="regexp">/\.jpg$/</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;asset/resource&#x27;</span>,</span><br><span class="line">    <span class="attr">generator</span>: &#123;</span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&#x27;static/[hash:8][ext][query]&#x27;</span> <span class="comment">//8位hash值与后缀名的组合</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="2-在-output-里配置"><a href="#2-在-output-里配置" class="headerlink" title="2. 在 output 里配置"></a>2. 在 output 里配置</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./a.js&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;&quot;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">    <span class="attr">assetModuleFilename</span>: <span class="string">&quot;static/[hash:6][ext][query]&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.jpg$/</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;asset/resource&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;none&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这两种方式配置资源文件名称的效果是一样，并且只能用于 type 是 <code>asset</code> 和 <code>asset/resource</code> 的情况</p>
<h2 id="asset-inline"><a href="#asset-inline" class="headerlink" title="asset&#x2F;inline"></a>asset&#x2F;inline</h2><p>打包后文件目录没有新增图片，原始图片被处理成 Base64 编码的 data URL 并直接存放在打包生成的 <code>bundle.js</code> 文件里</p>
<p>dataURL 默认使用 Base64 编码，可以配置 <code>generator.dataURL</code> 进行自定义编码算法。</p>
<h2 id="asset"><a href="#asset" class="headerlink" title="asset"></a>asset</h2><p>webpack 默认对于大于 8 KB 的资源 以 asset&#x2F;resource 处理，否则以 asset&#x2F;inline 处理</p>
<p>但是我们也可以修改这个资源大小的阙值，在 module.rule 的 <code>parser.dataURLCondition.maxSize</code> 中配置.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;./a.js&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;&quot;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(jpg|png)$/</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;asset&quot;</span>,</span><br><span class="line">        <span class="attr">parser</span>: &#123;</span><br><span class="line">          <span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line">            <span class="attr">maxSize</span>: <span class="number">6</span> * <span class="number">1024</span>, <span class="comment">// 6kb</span></span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;none&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Asset Modules 虽然可以代替部分预处理器的功能，但是要进行个性化配置的时候还是使用预处理器更方便。<br>比如，目前如果要给预处理器配置 publicPath，目前是做不到，而且 Asset Modules 存在 BUG，还需要修复。</p>
<p>但是 Asset Modules 是 webpack 的未来，文件资源预处理器后续已经不进行维护了，随着 Asset Modules 功能的优化，未来可能会取代 file-loader 等预处理器，我们需要留意 Asset Modules 的最新状态</p>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>js 手写函数</title>
    <url>/2023/02/13/js-handwriting-function/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2.3</span>];</span><br><span class="line">arr.<span class="title function_">myUnshift</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myUnshift</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> len = <span class="variable language_">arguments</span>.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="variable language_">arguments</span>[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">length</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">myUnshift</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), arr);</span><br></pre></td></tr></table></figure>

<h2 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//(method) Array&lt;any&gt;.indexOf(searchElement: any, fromIndex?: number | undefined): number</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myUnique</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">filter</span>(<span class="function">(<span class="params">v, idx</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">indexOf</span>(v, <span class="number">0</span>) === idx;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="获取指定范围内的随机数"><a href="#获取指定范围内的随机数" class="headerlink" title="获取指定范围内的随机数"></a>获取指定范围内的随机数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">min, max</span>) &#123;</span><br><span class="line">  <span class="comment">//(min,max)</span></span><br><span class="line">  <span class="comment">//   return Math.round(Math.random() * (max - min - 2) + (min + 1));</span></span><br><span class="line">  <span class="comment">//[min,max]</span></span><br><span class="line">  <span class="comment">//   return Math.round(Math.random() * (max - min ) + min);</span></span><br><span class="line">  <span class="comment">//(min,max)</span></span><br><span class="line">  <span class="comment">//   return Math.ceil(Math.random() * (max - min) + (min));</span></span><br><span class="line">  <span class="comment">//(min,max)</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (max - min) + min);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="打印-100-之内的质数"><a href="#打印-100-之内的质数" class="headerlink" title="打印 100 之内的质数"></a>打印 100 之内的质数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> count;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i % j === <span class="number">0</span>) &#123;</span><br><span class="line">      count++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//质数只能被1和它本身整除</span></span><br><span class="line">  <span class="keyword">if</span> (count === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何提取-URL-中的参数"><a href="#如何提取-URL-中的参数" class="headerlink" title="如何提取 URL 中的参数"></a>如何提取 URL 中的参数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> url = <span class="string">&quot;https://baidu.com?a=1&amp;b=2&amp;c=3#hash&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">queryURLParams</span>(<span class="params">URL</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> url = <span class="variable constant_">URL</span>.<span class="title function_">split</span>(<span class="string">&quot;?&quot;</span>)[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">const</span> urlSearchParams = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(url);</span><br><span class="line">  <span class="keyword">const</span> params = <span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(urlSearchParams.<span class="title function_">entries</span>());</span><br><span class="line">  <span class="keyword">return</span> params;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">queryURLParams</span>(url));</span><br></pre></td></tr></table></figure>

<h2 id="数组随机排序"><a href="#数组随机排序" class="headerlink" title="数组随机排序"></a>数组随机排序</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">result</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> randomIndex = <span class="built_in">parseInt</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * arr.<span class="property">length</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> curNum = arr[i];</span><br><span class="line">    arr[i] = arr[randomIndex];</span><br><span class="line">    arr[randomIndex] = curNum;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line">arr.<span class="title function_">sort</span>(<span class="function">() =&gt;</span> <span class="title class_">Math</span>.<span class="title function_">random</span>() - <span class="number">0.5</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br></pre></td></tr></table></figure>

<h2 id="实现迭代的方式实现-flatten"><a href="#实现迭代的方式实现-flatten" class="headerlink" title="实现迭代的方式实现 flatten"></a>实现迭代的方式实现 flatten</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">6</span>, [<span class="number">7</span>, [<span class="number">8</span>, <span class="number">9</span>, [<span class="number">10</span>, [<span class="number">11</span>, <span class="number">12</span>]]]]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> flatten = <span class="keyword">function</span> (<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (arr.<span class="title function_">some</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> <span class="title class_">Array</span>.<span class="title function_">isArray</span>(v))) &#123;</span><br><span class="line">    arr = [].<span class="title function_">concat</span>(...arr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> flatten = <span class="keyword">function</span> (<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [].<span class="title function_">concat</span>(...arr.<span class="title function_">map</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(v) ? <span class="title function_">flatten</span>(v) : v)));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><p>&#x2F;&#x2F; nums target</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">17</span>];</span><br><span class="line"><span class="keyword">const</span> target = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">twoSum</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> targetIndex = nums.<span class="title function_">indexOf</span>(target - nums[i]);</span><br><span class="line">    <span class="keyword">if</span> (targetIndex &gt; -<span class="number">1</span> &amp;&amp; targetIndex !== i) &#123;</span><br><span class="line">      <span class="keyword">return</span> [i, targetIndex];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="给-a-b-c-三个请求，c-在-a-b-获取完数据之后再发送请求"><a href="#给-a-b-c-三个请求，c-在-a-b-获取完数据之后再发送请求" class="headerlink" title="给 a,b,c 三个请求，c 在 a,b 获取完数据之后再发送请求"></a>给 a,b,c 三个请求，c 在 a,b 获取完数据之后再发送请求</h2><p>&#x2F;&#x2F; 1. promise.all</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  arr.<span class="title function_">push</span>(data);</span><br><span class="line">  <span class="keyword">if</span> (arr.<span class="property">length</span> === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&quot;./a.text&quot;</span>, <span class="string">&quot;utf-8&quot;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">fn</span>(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&quot;./b.text&quot;</span>, <span class="string">&quot;utf-8&quot;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">fn</span>(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="如何实现一个事件发布订阅"><a href="#如何实现一个事件发布订阅" class="headerlink" title="如何实现一个事件发布订阅"></a>如何实现一个事件发布订阅</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventEmitter</span> &#123;</span><br><span class="line">  handlers = &#123;&#125;;</span><br><span class="line">  <span class="title function_">on</span>(<span class="params">type, handler, once = <span class="literal">false</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">handlers</span>[type]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">handlers</span>[type] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">handlers</span>[type].<span class="title function_">includes</span>(handler)) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">handlers</span>[type].<span class="title function_">push</span>(handler);</span><br><span class="line">      handler.<span class="property">once</span> = once;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">once</span>(<span class="params">type, handler</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">on</span>(type, handler, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">off</span>(<span class="params">type, handler</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">handlers</span>[type]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">handlers</span>[type] = <span class="variable language_">this</span>.<span class="property">handlers</span>[type].<span class="title function_">filter</span>(<span class="function">(<span class="params">h</span>) =&gt;</span> h !== handler);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">trigger</span>(<span class="params">type</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">handlers</span>[type]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">handlers</span>[type].<span class="title function_">forEach</span>(<span class="function">(<span class="params">handler</span>) =&gt;</span> &#123;</span><br><span class="line">        handler.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (handler.<span class="property">once</span>) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">off</span>(type, handler);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ev = <span class="keyword">new</span> <span class="title class_">EventEmitter</span>();</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handler1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;handler1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handler2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;handler2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handler3</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;handler3&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ev.<span class="title function_">on</span>(<span class="string">&quot;test&quot;</span>, handler1);</span><br><span class="line">ev.<span class="title function_">once</span>(<span class="string">&quot;test&quot;</span>, handler2);</span><br><span class="line">ev.<span class="title function_">on</span>(<span class="string">&quot;test&quot;</span>, handler3);</span><br><span class="line"></span><br><span class="line">ev.<span class="title function_">trigger</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">ev.<span class="title function_">trigger</span>(<span class="string">&quot;test&quot;</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>requestAnimationFrame</title>
    <url>/2024/03/13/requestAnimationFrame/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>宏任务和微任务</title>
    <url>/2024/01/16/macro-micro-Task/</url>
    <content><![CDATA[<blockquote>
<p>一个很好的练习事件循环的网站 <a href="https://www.jsv9000.app/">https://www.jsv9000.app/</a></p>
</blockquote>
<p>JS 将 <strong>异步任务</strong> 分为宏任务和微任务</p>
<span id="more"></span>

<h2 id="1-同步代码（js-执行栈-回调栈）"><a href="#1-同步代码（js-执行栈-回调栈）" class="headerlink" title="1. 同步代码（js 执行栈&#x2F;回调栈）"></a>1. 同步代码（js 执行栈&#x2F;回调栈）</h2><h2 id="2-微任务的异步代码（js-引擎）"><a href="#2-微任务的异步代码（js-引擎）" class="headerlink" title="2. 微任务的异步代码（js 引擎）"></a>2. 微任务的异步代码（js 引擎）</h2><ul>
<li>Process.nextTick(node)</li>
<li>Promise.then() catch()<blockquote>
<p>Promise 本身同步，then 和 catch 的回调函数是异步的微任务</p>
</blockquote>
</li>
<li>Async&#x2F;Await</li>
<li>Object.observe 等等</li>
</ul>
<h2 id="3-宏任务的异步代码（宿主环境-浏览器、Node）"><a href="#3-宏任务的异步代码（宿主环境-浏览器、Node）" class="headerlink" title="3. 宏任务的异步代码（宿主环境-浏览器、Node）"></a>3. 宏任务的异步代码（宿主环境-浏览器、Node）</h2><ul>
<li>script(代码块)</li>
<li>Ajax&#x2F;Fetch</li>
<li>setTimeout&#x2F;setInterval</li>
<li>setImmediate</li>
</ul>
<h1 id="同步代码-微任务-宏任务"><a href="#同步代码-微任务-宏任务" class="headerlink" title="同步代码-&gt;微任务-&gt;宏任务"></a>同步代码-&gt;微任务-&gt;宏任务</h1><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><h2 id="例子-1"><a href="#例子-1" class="headerlink" title="例子 1"></a>例子 1</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>); <span class="comment">//macro</span></span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data); <span class="comment">//micro</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>打印结果：1 3 4 5 1000 2</p>
<h2 id="例子-2"><a href="#例子-2" class="headerlink" title="例子 2"></a>例子 2</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">2</span>);</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>打印结果： 3 2 1</p>
<h2 id="例子-3"><a href="#例子-3" class="headerlink" title="例子 3"></a>例子 3</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">11</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">12</span>);</span><br><span class="line">  <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">13</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  p.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">15</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">14</span>);</span><br></pre></td></tr></table></figure>

<p>打印结果： 11 14 12 15 13</p>
<h2 id="例子-4"><a href="#例子-4" class="headerlink" title="例子 4"></a>例子 4</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;p1&quot;</span>);</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="string">&quot;setTimeout2&quot;</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;p2&quot;</span>);</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;setTimeout1&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<p>打印结果：2 3 6 p2 p1 1 4 5</p>
<h2 id="例子-5"><a href="#例子-5" class="headerlink" title="例子 5"></a>例子 5</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 start&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">async2</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setTimeout&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="title function_">async1</span>();</span><br></pre></td></tr></table></figure>

<p>await async2();后面的代码的代码属于微任务</p>
<p>打印结果： script start 、 async1 start 、 async2 、async1 end 、setTimeout</p>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>原型和原型链</title>
    <url>/2022/03/18/prototype/</url>
    <content><![CDATA[<h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><p>原型： 每个函数都有 prototype 属性，称之为原型<br>因为这个属性的值是一个对象，称为 原型对象(Array.prototype)</p>
<span id="more"></span>

<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol>
<li>存放一些属性和方法</li>
<li>在 JS 中实现继承</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">arr.<span class="title function_">reverse</span>();</span><br><span class="line">arr.<span class="property">__proto__</span> === <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>__proto__</strong>:每个对象都有__proto__属性<br>作用： 这个属性指向它的原型对象</p>
<h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><p>对象都有__proto__属性，这个属性指向它的</p>
<p>person—__proto__—&gt;person.prototype—__proto__—&gt;Object.prototype—__proto__—&gt;null</p>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS纵享丝滑滚动</title>
    <url>/2023/06/18/css-slide/</url>
    <content><![CDATA[<p>我们之前利用 a 标签的锚点功能，能让页面滚动到指定位置，但是存在顿挫感，使用<code>scroll-behavior: smooth;</code>可以让滚动变得丝滑。</p>
<span id="more"></span>

<h2 id="CSS-实现"><a href="#CSS-实现" class="headerlink" title="CSS 实现"></a>CSS 实现</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.box1</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: aqua;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">1000px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">600px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>: <span class="number">80px</span> <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.box2</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">13</span>);</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">1000px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">600px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>: <span class="number">80px</span> <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.box3</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">227</span>, <span class="number">154</span>, <span class="number">177</span>);</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">1000px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">600px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>: <span class="number">80px</span> <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.slidebar</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">position</span>: fixed;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">top</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">right</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">50%</span>);</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.slidebar</span> &gt; <span class="selector-tag">a</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">80px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">80px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">justify-content</span>: center;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.slidebar</span> &gt; <span class="selector-tag">a</span><span class="selector-pseudo">:first</span>-child &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: aqua;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.slidebar</span> &gt; <span class="selector-tag">a</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">13</span>);</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.slidebar</span> &gt; <span class="selector-tag">a</span><span class="selector-pseudo">:last-child</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">227</span>, <span class="number">154</span>, <span class="number">177</span>);</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">      <span class="selector-tag">html</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="comment">/* 页面滚动条滑动 */</span></span></span><br><span class="line"><span class="language-css">        scroll-behavior: smooth;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span> <span class="attr">id</span>=<span class="string">&quot;box1&quot;</span>&gt;</span>服饰<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span> <span class="attr">id</span>=<span class="string">&quot;box2&quot;</span>&gt;</span>家电<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box3&quot;</span> <span class="attr">id</span>=<span class="string">&quot;box3&quot;</span>&gt;</span>生鲜<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;slidebar&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#box1&quot;</span>&gt;</span>服饰<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#box2&quot;</span>&gt;</span>家电<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#box3&quot;</span>&gt;</span>生鲜<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是 scroll-behavior 的兼容性会很差，比如在移动端 ios 基本不支持，我们也可以用 JS 来实现</p>
<h2 id="JS-实现"><a href="#JS-实现" class="headerlink" title="JS 实现"></a>JS 实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">target.<span class="title function_">scrollIntoView</span>(&#123;</span><br><span class="line">  <span class="attr">behavior</span>: <span class="string">&quot;smooth&quot;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>算法可视化网站分享</title>
    <url>/2024/03/18/algorithm-share/</url>
    <content><![CDATA[<p>通过动画可视化数据结构和算法: <a href="https://visualgo.net/zh">https://visualgo.net/zh</a></p>
<p>网站里面包含了排序、链表、哈希表、二叉搜索树、递归树、循环查找等常见算法动画，而部分高级算法，现今也只能在 VisuAlgo 上找到具体的动画展示效果。</p>
<span id="more"></span>

<p>我们可以定义自己的输入，可以切换模式：探索模式和电子讲座模式，也可以暂停和播放动画展示，也可以调整速度，网站也对每个步骤算法进行说明。</p>
<p>不仅于此，该网站还提供了一些算法练习题供学生训练，以便更进一步巩固自己的算法知识。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>vmin和vw</title>
    <url>/2024/03/18/vmin/</url>
    <content><![CDATA[<h1 id="vw-vh-和-vmin-vmax"><a href="#vw-vh-和-vmin-vmax" class="headerlink" title="vw&#x2F;vh 和 vmin&#x2F;vmax"></a>vw&#x2F;vh 和 vmin&#x2F;vmax</h1><p>vmin 可以照顾手机端 <strong>横屏和竖屏</strong> 的显示效果</p>
<span id="more"></span>

<h2 id="vw-vh"><a href="#vw-vh" class="headerlink" title="vw&#x2F;vh"></a>vw&#x2F;vh</h2><p>vh 和 vw 与视口的宽度和高度有关<br>1vw 就是视口宽度的 1%</p>
<h2 id="vmin-vmax"><a href="#vmin-vmax" class="headerlink" title="vmin&#x2F;vmax"></a>vmin&#x2F;vmax</h2><p>vmin 和 vmax 是与当下屏幕的宽度和高度的最大值或最小值有关，<br>取决于哪个更大和更小。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">app &#123;</span><br><span class="line">  <span class="comment">/* width: 100vw; */</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100vmin</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>vim: 当前 vw 和 vh 中较小的一个值(即相对于视窗中较短的一边)</li>
<li>vmax: 当前 vw 和 vh 中较大的一个值(即相对于视窗中较长的一边)</li>
</ul>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能优化</title>
    <url>/2024/03/19/performance-optimization/</url>
    <content><![CDATA[<h1 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h1><ol>
<li>首屏速度，白屏时间等</li>
<li>操作速度以及渲染速度</li>
</ol>
<p>白屏时间： 资源记载时间， 首屏 js 执行<br>渲染页面：首屏数据请求，Dom 渲染</p>
<span id="more"></span>

<h1 id="如何缩短首屏速度？"><a href="#如何缩短首屏速度？" class="headerlink" title="如何缩短首屏速度？"></a>如何缩短首屏速度？</h1><h2 id="效果比较好的操作"><a href="#效果比较好的操作" class="headerlink" title="效果比较好的操作"></a>效果比较好的操作</h2><ol>
<li>减少首屏资源体积</li>
</ol>
<ul>
<li>打包工具的压缩</li>
<li>异步加载（分析能够异步加载的，比较体积大，但又不是马上需要的功能，和首屏渲染没关系）</li>
<li>更新为体积更小的新版本（把一些老版本的库替换成新版本的支持 tree-shaking）</li>
<li>编写代码尽量减少体积</li>
<li>去除大的 base64 体积（打包工具默认将图片转成 base64，小图片可以转，但是 大图片和媒体资源 建议不要转成 base64）</li>
<li>能不用第三方库就不用第三方库（eg:时间格式化）</li>
</ul>
<h2 id="效果不太好或者在特殊情况下的优化操作"><a href="#效果不太好或者在特殊情况下的优化操作" class="headerlink" title="效果不太好或者在特殊情况下的优化操作"></a>效果不太好或者在特殊情况下的优化操作</h2><ol>
<li>首屏数据尽量并行，如果可行让小数据量接口合并到其他接口</li>
<li>页面包含大量 dom 可以分批随滚动渲染</li>
<li>骨架屏，loading，先让屏幕不白，减少用户焦虑</li>
</ol>
<h1 id="操作速度和渲染速度"><a href="#操作速度和渲染速度" class="headerlink" title="操作速度和渲染速度"></a>操作速度和渲染速度</h1><p>什么情况下会造成操作卡顿和渲染慢？</p>
<h2 id="1-一次性-操作大量"><a href="#1-一次性-操作大量" class="headerlink" title="1. 一次性 操作大量"></a>1. 一次性 操作大量</h2><p>长列表渲染和异步渲染</p>
<h3 id="长列表渲染"><a href="#长列表渲染" class="headerlink" title="长列表渲染"></a>长列表渲染</h3><ol>
<li>虚拟化列表技术<br>只渲染可见区域的数据项，而不是渲染整个列表</li>
<li>分页加载<br>将长列表分割成多个页面，一次性只加载当前页面的数据，而不是全部数据。当用户滚动或者翻页时，再加载下一页的数据</li>
<li>使用列表项重用<br>保持列表项的可重用性，避免频繁地创建和销毁 DOM 元素。这可以通过使用列表项池来维护已渲染的列表项，然后根据需要更新其内容。</li>
</ol>
<h3 id="异步渲染"><a href="#异步渲染" class="headerlink" title="异步渲染"></a>异步渲染</h3><h4 id="1-prefetch-加载"><a href="#1-prefetch-加载" class="headerlink" title="1. prefetch 加载"></a>1. prefetch 加载</h4><p>假设 page1,page2 是同步加载，page3 是异步加载（prefetch）,首屏打开都会给这个三个创建 link 标签加载，但是没用标记 prefetch 的 link 会先加载，然后首屏展示完之后，再加载 prefetch 资源</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Home&quot;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">Home</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/about&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;About&quot;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">import</span>(<span class="string">&quot;../views/About.vue&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>如果将网速调慢， 从 network 中也可以看出来，虽然先创建了 about.js 请求，但是需要等其他的请求完成之后再加载的 about</p>
<h4 id="2-script-加载"><a href="#2-script-加载" class="headerlink" title="2. script 加载"></a>2. script 加载</h4><p>App.js（page1,page2）-&gt;首页加载完成-&gt;进入 page3-&gt;执行 js，创建一个 script 标签引入 page3 相关 js-&gt;page3.js-&gt;page3 页面看到</p>
<h4 id="prefetch-和-script-加载-对比："><a href="#prefetch-和-script-加载-对比：" class="headerlink" title="prefetch 和 script 加载 对比："></a>prefetch 和 script 加载 对比：</h4><p><strong>script 加载</strong>:</p>
<ol>
<li>做到了充分按需引入，用到的时候在加载，不用永不加载，充分节省了带宽</li>
<li>最大问题是，切换需要等待，体验不是很流畅</li>
</ol>
<p><strong>prefetch 加载</strong>:</p>
<ol>
<li>充分利用使用者不占用带宽的浏览时间，切换到异步加载的页面是可能早已经加载好的，用户体验更流畅</li>
<li>一些本次行为不会打开的页面也会加载，一定程度上浪费了带宽</li>
</ol>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><ol>
<li>按需引入 <code>import &#123;read, utils&#125; from &#39;xlsx&#39; </code></li>
<li>一些非马上使用的操作，改成异步</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">change</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">import</span>(<span class="string">&#x27;jquery&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">let</span> $=res.<span class="property">default</span></span><br><span class="line">      <span class="keyword">let</span> a =$(<span class="string">&#x27;.test&#x27;</span>)</span><br><span class="line">      a.<span class="title function_">html</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-利用-setTimeout-或-requestAnimationFrame"><a href="#3-利用-setTimeout-或-requestAnimationFrame" class="headerlink" title="3. 利用 setTimeout 或 requestAnimationFrame"></a>3. 利用 setTimeout 或 requestAnimationFrame</h4><p>在渲染大量数据时，可以使用 <code>setTimeout</code> 或 <code>requestAnimationFrame</code> 来将渲染任务分解成多个小任务，并给浏览器一些空闲时间来处理其他任务，从而减少卡顿和提高渲染性能。</p>
<h4 id="4-使用-Web-Workers"><a href="#4-使用-Web-Workers" class="headerlink" title="4. 使用 Web Workers"></a>4. 使用 Web Workers</h4><p>可以将一些耗时的计算或处理任务放在 <code>Web Workers</code> 中进行，以避免阻塞主线程，从而提高页面的响应性能</p>
<h4 id="5-懒加载"><a href="#5-懒加载" class="headerlink" title="5. 懒加载"></a>5. 懒加载</h4><p>对于某些不是立即需要的数据或组件，可以延迟加载，直到用户需要时再进行加载和渲染。这可以通过 React 中的 <code>React.lazy()</code> 和 Vue 中的 <code>vue-router</code> 的懒加载功能来实现。</p>
<h4 id="6-使用分片加载"><a href="#6-使用分片加载" class="headerlink" title="6. 使用分片加载"></a>6. 使用分片加载</h4><p>对于大型数据集，可以将数据分成多个片段进行加载，并在每个片段加载完成后进行渲染。这样可以降低单次操作的负担，提高渲染的效率</p>
<h2 id="2-进行了复杂度高的运算（eg-循环）"><a href="#2-进行了复杂度高的运算（eg-循环）" class="headerlink" title="2. 进行了复杂度高的运算（eg:循环）"></a>2. 进行了复杂度高的运算（eg:循环）</h2><p>循环中操作尽量精简（可能效果不明显）</p>
<h2 id="3-vue-和-react-项目中，不必要的渲染太多"><a href="#3-vue-和-react-项目中，不必要的渲染太多" class="headerlink" title="3. vue 和 react 项目中，不必要的渲染太多"></a>3. vue 和 react 项目中，不必要的渲染太多</h2><h3 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h3><p>vue 中有依赖收集， 配合上 vue3 的静态节点标记，已经基本上避免了因为数据改变引起的无意义渲染</p>
<ol>
<li>频繁切换的显隐内容用 <code>v-show</code> 也就是 display 来控制隐藏，只有打开就一次性决定显示与否的用 <code>v-if</code> 不去创建</li>
<li>循环，动态切换内容加好 key 值</li>
<li>keep-alive 缓存</li>
<li>区分请求粒度，减少请求范围，也能减少更新</li>
</ol>
<h3 id="react"><a href="#react" class="headerlink" title="react"></a>react</h3><ol>
<li><code>PureComponent</code> 或 <code>React.memo</code>来减少不必要的重新渲染</li>
<li>通过实现<code>shouldComponentUpdate</code>生命周期方法来手动控制是否进行组件重新渲染。</li>
<li>避免在<code>render</code>方法中直接修改 state 或 props，因为这会触发组件的重新渲染。而是应该使用<code>setState</code>来更新<code>state</code>。</li>
<li>避免在渲染函数中执行昂贵的操作，例如大量计算、数据请求等，这会影响渲染性能。可以将这些操作移到生命周期方法中，或者使用异步渲染技术进行优化。</li>
</ol>
<h1 id="数据缓存"><a href="#数据缓存" class="headerlink" title="数据缓存"></a>数据缓存</h1><ul>
<li>不变数据，定期时效可以缓存在 <code>cookies</code> 或者 <code>localStorage</code> 中，比如 token,用户名</li>
<li>可以考虑做一个缓存队列，存于内存中（全局对象，vuex）。这样能保证刷新就更新数据，也能一定程度上缓存数据</li>
</ul>
]]></content>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>quick-sort</title>
    <url>/2023/01/23/quick-sort/</url>
    <content><![CDATA[<h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><ol>
<li>选定 Pivot 中心轴</li>
<li>将大于 Pivot 的数字放在 Pivot 的右边</li>
<li>将大于 Pivot 的数字放在 Pivot 的左边</li>
<li>分别对左右子序列重复前三步操作</li>
</ol>
<p>存在两个下标，L 和 R，进行移动下标，与 Pivot 值进行比较，并移动位置，最终，L 和 R 相遇后，Pivot 值放在相遇的位置，完成一次排序，再以当前的位置划分左右两个序列，分别对两边的序列再重复排序操作</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
