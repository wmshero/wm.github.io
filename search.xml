<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>compose函数组合</title>
    <url>/2019/10/10/compose/</url>
    <content><![CDATA[<p>在函数式编程当中有一个很重要的概念就是函数组合，实际上就是<strong>把处理数据的函数像管道一样连接起来，然后让数据穿过管道得到最终的结果</strong></p>
<p>在多个框架源码中都有用到，比如 redux、koa 中多次遇到这个方法</p>
<span id="more"></span>

<p>效果：将一系列函数，通过 <code>compose</code> 函数组合起来，像管道一样连接起来，比如函数结合<code>[f, g, h ]</code>，通过 <code>compose</code> 最终达到这样的效果： <code>f(g(h()))</code></p>
<p>compose 函数要求：可执行同步方法，也可执行异步方法，两者都可以兼容</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compose</span>(<span class="params">list</span>) &#123;</span><br><span class="line">  <span class="comment">// 取出第一个函数，当做reduce函数的初始值</span></span><br><span class="line">  <span class="keyword">const</span> init = list.<span class="title function_">shift</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...arg</span>) &#123;</span><br><span class="line">    <span class="comment">// 执行compose函数，返回一个函数</span></span><br><span class="line">    <span class="keyword">return</span> list.<span class="title function_">reduce</span>(</span><br><span class="line">      <span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 返回list.reduce的结果，为一个promise实例，外部就可以通过then获取</span></span><br><span class="line">        <span class="keyword">return</span> pre.<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// pre始终为一个promise实例，result为结果的累加值</span></span><br><span class="line">          <span class="comment">// 在前一个函数的then中，执行当前的函数，并返回一个promise实例，实现累加传递的效果</span></span><br><span class="line">          <span class="keyword">return</span> cur.<span class="title function_">call</span>(<span class="literal">null</span>, result);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// Promise.resolve可以将非promise实例转为promise实例（一种兼容处理）</span></span><br><span class="line">      <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(init.<span class="title function_">apply</span>(<span class="literal">null</span>, arg))</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步方法案例</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">sync1</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sync1&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">sync2</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sync2&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> data + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">sync3</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sync3&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> data + <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> syncFn = <span class="title function_">compose</span>([sync1, sync2, sync3]);</span><br><span class="line"><span class="title function_">syncFn</span>(<span class="number">0</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 依次打印 sync1 → sync2 → sync3 → 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步方法案例</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">async1</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1&quot;</span>);</span><br><span class="line">      <span class="title function_">resolve</span>(data);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">async2</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async2&quot;</span>);</span><br><span class="line">      <span class="title function_">resolve</span>(data + <span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">async3</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async3&quot;</span>);</span><br><span class="line">      <span class="title function_">resolve</span>(data + <span class="number">2</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> composeFn = <span class="title function_">compose</span>([async1, async2, async3]);</span><br><span class="line"><span class="title function_">composeFn</span>(<span class="number">0</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 依次打印 async1 → async1 → async1 → 3</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>兼容性</title>
    <url>/2023/12/15/compatibility/</url>
    <content><![CDATA[<h1 id="经常遇到的浏览器的兼容性有哪些？"><a href="#经常遇到的浏览器的兼容性有哪些？" class="headerlink" title="经常遇到的浏览器的兼容性有哪些？"></a>经常遇到的浏览器的兼容性有哪些？</h1><ol>
<li><p>IE 浏览器不支持 <code>Promise</code><br>babel-polyfill → webpack.config.js 的 entry 中设置 [‘babel-polyfill’, ‘.&#x2F;src&#x2F;main.js’]</p>
</li>
<li><p>各浏览器之间默认样式的差异<br>normalize.css<br>与 reset 区别 → normalize.css 消除各浏览器之间默认样式的差异、保留有用的默认样式；<br>而 reset 会清除所有的默认样式，过于暴力，例如会让 h 标题标签不再默认加粗，ul li 前面默认的小圆点也没了）</p>
<span id="more"></span></li>
<li><p>html5 某些新增标签不被识别<br>html5shiv.js - 解决 ie9 以下对 html5 某些新增标签不识别的问题（e.g. video 标签不识别不显示）<br>用法：[if lt IE 9]&gt;<script> src="<a href="http://html5shim.googlecode.com/svn/trunk/html5.js">http://html5shim.googlecode.com/svn/trunk/html5.js</a>"</script>&lt;![endif]<br>通过 <code>document.createElement</code> 方法产生的标签， 可以利用这一特性让这些浏览器支持 HTML5 新标签，浏览器支持新标签后，还需要添加标签默认的样式。</p>
</li>
<li><p>CSS3 媒体查询失效<br>respond.js - 能解决 ie9 以下不支持媒体查询问题</p>
</li>
<li><p>自动添加浏览器前缀<br>posscss-loader+autoprefixer</p>
</li>
<li><p>ie6 不支持 <code>min-height/width</code><br>添加额外的 _min-height ie6 识别</p>
</li>
<li><p>常见 <code>hack</code>（针对特定 ie 版本的样式控制）<br>_color - ie6 识别<br>*color - ie6&#x2F;7 识别<br>color: red\9; ie8 及以下识别</p>
</li>
<li><p>ie 条件注释写法：(lt 小于 | gt 大于 | lte 小于等于 | gte 大于等于 | ! 不等于)</p>
</li>
</ol>
<hr>
<h1 id="移动端兼容性？"><a href="#移动端兼容性？" class="headerlink" title="移动端兼容性？"></a>移动端兼容性？</h1><ol>
<li><p>移动端点透问题<a href="https://www.cnblogs.com/zhuzhenwei918/p/7588553.html">(解决办法)</a></p>
</li>
<li><p>ios 滚动卡顿<br>使用 better-scroll 插件</p>
</li>
<li><p>ios 顶部输入框 fixed 布局失效（当键盘弹起时）❌</p>
</li>
<li><p>安卓 键盘遮挡输入框 ❌</p>
</li>
<li><p>position:fixed; 在 android 下无效怎么处理？【❌ 待验证】</p>
<blockquote>
<p>原因：fixed 的元素是相对整个页面固定位置的，你在屏幕上滑动只是在移动这个所谓的 viewport ， 原来的网页还好好的在那，fixed 的内容也没有变过位置。</p>
</blockquote>
</li>
</ol>
<p>解决：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;meta</span><br><span class="line">  name=<span class="string">&quot;viewport&quot;</span></span><br><span class="line">  content=<span class="string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？❌<br>click 有 300ms 延迟,为了实现 safari 的双击事件的设计，浏览器要知道你是不是要双击操作。</li>
</ol>
<hr>
<h1 id="Polyfill"><a href="#Polyfill" class="headerlink" title="Polyfill"></a>Polyfill</h1><h2 id="什么是-Polyfill"><a href="#什么是-Polyfill" class="headerlink" title="什么是 Polyfill"></a>什么是 Polyfill</h2><p>polyfill 是“在旧版浏览器上复制标准 API 的 JavaScript 补充”,可以动态地加载 JavaScript 代码或库，在不支持这些标准 API 的浏览器中模拟它们。</p>
<p>例如，geolocation（地理位置）polyfill 可以在 navigator 对象上添加全局的 geolocation 对象，还能添加 getCurrentPosition 函数以及“坐标”回调对象， 所有这些都是 W3C 地理位置 API 定义的对象和函数。</p>
<p>因为 polyfill 模拟标准 API，所以能够以一种面向所有浏览器未来的方式针对这些 API 进行开发， 一旦对这些 API 的支持变成绝对大多数，则可以方便地去掉 polyfill，无需做任何额外工作。</p>
<ul>
<li>做的项目中，有没有用过或自己实现一些 polyfill 方案（兼容性处理方案）？❌<br>比如： html5shiv、Geolocation、Placeholder</li>
</ul>
<hr>
<h1 id="列举-IE-与其他浏览器不一样的特性？"><a href="#列举-IE-与其他浏览器不一样的特性？" class="headerlink" title="列举 IE 与其他浏览器不一样的特性？"></a>列举 IE 与其他浏览器不一样的特性？</h1><p><strong>事件目标对象</strong></p>
<p>触发事件的元素被认为是目标（target）。而在 IE 中，目标包含在 <code>event</code> 对象的 <code>srcElement</code> 属性</p>
<p><strong>获取字符代码</strong></p>
<p>如果按键代表一个字符（shift、ctrl、alt 除外），IE 的 <code>keyCode</code> 会返回字符代码（Unicode），DOM 中按键的代码和字符是分离的，要获取字符代码，需要使用 <code>charCode</code> 属性</p>
<p><strong>阻止某个事件的默认行为</strong></p>
<p>IE 中阻止某个事件的默认行为，必须将 <code>returnValue</code> 属性设置为 <code>false</code>，Mozilla 中，需要调用 <code>preventDefault()</code> 方法</p>
<p><strong>停止事件冒泡</strong></p>
<p>IE 中阻止事件进一步冒泡，需要设置 <code>cancelBubble</code> 为 true，Mozzilla 中，需要调用 <code>stopPropagation()</code></p>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
  </entry>
  <entry>
    <title>JSBridge</title>
    <url>/2020/07/21/JSBridge/</url>
    <content><![CDATA[<p>随着移动端盛行，不管是混合开发（Hybrid）应用，还是 React-Native 都离不开 JSBridge，当然也包括在国内举足轻重的微信小程序。</p>
<span id="more"></span>

<h1 id="JSBridge-的作用"><a href="#JSBridge-的作用" class="headerlink" title="JSBridge 的作用"></a>JSBridge 的作用</h1><p>通过 JSBridge 可以实现 H5 和 原生之间的<strong>双向</strong>通信，主要是给 H5 提供调用 原生（Native）功能的接口，让混合开发中的 H5 可以方便地使用地址位置、摄像头甚至支付等原生功能。</p>
<img src="/2020/07/21/JSBridge/jsbridge.png" class title="jsbridge">

<h1 id="JSBridge-的通信原理"><a href="#JSBridge-的通信原理" class="headerlink" title="JSBridge 的通信原理"></a>JSBridge 的通信原理</h1><p>主要有两种：注入 API 和 拦截 URL SCHEME。</p>
<h2 id="注入-API"><a href="#注入-API" class="headerlink" title="注入 API"></a>注入 API</h2><p>注入 API 方式是最常用的方式，主要原理是通过 <code>WebView</code> 提供的接口，向 JavaScript 的 Context（window）中注入对象或者方法，让 JavaScript 调用时，直接执行相应的 Native 代码逻辑，达到 JavaScript 调用 Native 的目的。</p>
<h3 id="注入-API-时，H5-端的代码"><a href="#注入-API-时，H5-端的代码" class="headerlink" title="注入 API 时，H5 端的代码"></a>注入 API 时，H5 端的代码</h3><h4 id="1）初始化-WebViewJavascriptBridge"><a href="#1）初始化-WebViewJavascriptBridge" class="headerlink" title="1）初始化 WebViewJavascriptBridge"></a>1）初始化 WebViewJavascriptBridge</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据navigator.userAgent来判断当前是 Android 还是 ios</span></span><br><span class="line"><span class="keyword">const</span> u = navigator.<span class="property">userAgent</span>;</span><br><span class="line"><span class="comment">// Android终端</span></span><br><span class="line"><span class="keyword">const</span> isAndroid = u.<span class="title function_">indexOf</span>(<span class="string">&quot;Android&quot;</span>) &gt; -<span class="number">1</span> || u.<span class="title function_">indexOf</span>(<span class="string">&quot;Adr&quot;</span>) &gt; -<span class="number">1</span>;</span><br><span class="line"><span class="comment">// IOS 终端</span></span><br><span class="line"><span class="keyword">const</span> isIOS = !!u.<span class="title function_">match</span>(<span class="regexp">/\(i[^;]+;( U;)? CPU.+Mac OS X/</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配合 IOS 使用时的初始化方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">iosFunction</span> = (<span class="params">callback</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">WebViewJavascriptBridge</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">callback</span>(<span class="variable language_">window</span>.<span class="property">WebViewJavascriptBridge</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">WVJBCallbacks</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">window</span>.<span class="property">WVJBCallbacks</span>.<span class="title function_">push</span>(callback);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">WVJBCallbacks</span> = [callback];</span><br><span class="line">  <span class="keyword">var</span> <span class="title class_">WVJBIframe</span> = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;iframe&quot;</span>);</span><br><span class="line">  <span class="title class_">WVJBIframe</span>.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;none&quot;</span>;</span><br><span class="line">  <span class="title class_">WVJBIframe</span>.<span class="property">src</span> = <span class="string">&quot;demo://__BRIDGE_LOADED__&quot;</span>;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="title function_">appendChild</span>(<span class="title class_">WVJBIframe</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="title function_">removeChild</span>(<span class="title class_">WVJBIframe</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配合 Android 使用时的初始化方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">androidFunction</span> = (<span class="params">callback</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">WebViewJavascriptBridge</span>) &#123;</span><br><span class="line">    <span class="title function_">callback</span>(<span class="variable language_">window</span>.<span class="property">WebViewJavascriptBridge</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(</span><br><span class="line">      <span class="string">&quot;WebViewJavascriptBridgeReady&quot;</span>,</span><br><span class="line">      <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">callback</span>(<span class="variable language_">window</span>.<span class="property">WebViewJavascriptBridge</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="literal">false</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">setupWebViewJavascriptBridge</span> = isAndroid ? androidFunction : iosFunction;</span><br><span class="line"></span><br><span class="line">isAndroid &amp;&amp;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">setupWebViewJavascriptBridge</span>(<span class="keyword">function</span> (<span class="params">bridge</span>) &#123;</span><br><span class="line">    <span class="comment">// 注册 H5 界面的默认接收函数</span></span><br><span class="line">    bridge.<span class="title function_">init</span>(<span class="keyword">function</span> (<span class="params">msg, responseCallback</span>) &#123;</span><br><span class="line">      <span class="title function_">responseCallback</span>(<span class="string">&quot;JS 返回给原生的消息内容&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h4 id="2）注册与原生交互的事件函数"><a href="#2）注册与原生交互的事件函数" class="headerlink" title="2）注册与原生交互的事件函数"></a>2）注册与原生交互的事件函数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bridge.registerHandler(&#x27;事件函数名&#x27;,fun 执行函数);</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">setupWebViewJavascriptBridge</span>(<span class="function">(<span class="params">bridge</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// data：原生传过来的数据;</span></span><br><span class="line">  <span class="comment">// callback: 原生传过来的回调函数</span></span><br><span class="line">  bridge.<span class="title function_">registerHandler</span>(<span class="string">&quot;H5Function&quot;</span>, <span class="function">(<span class="params">data, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    callback &amp;&amp; <span class="title function_">callback</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="3）调用原生注册的事件函数"><a href="#3）调用原生注册的事件函数" class="headerlink" title="3）调用原生注册的事件函数"></a>3）调用原生注册的事件函数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bridge.callHandler(&#x27;安卓端函数名&#x27;, &quot;传给原生端的数据&quot;, callback 回调函数);</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">setupWebViewJavascriptBridge</span>(<span class="function">(<span class="params">bridge</span>) =&gt;</span> &#123;</span><br><span class="line">  bridge.<span class="title function_">callHandler</span>(<span class="string">&quot;changeData&quot;</span>, data, <span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="拦截-URL-SCHEME"><a href="#拦截-URL-SCHEME" class="headerlink" title="拦截 URL SCHEME"></a>拦截 URL SCHEME</h2><p>先解释一下 URL SCHEME：URL SCHEME 是一种类似于 url 的链接，是为了方便 app 直接互相调用设计的，形式和普通的 url 近似，主要区别是 <code>protocol</code> 和 <code>host</code> 一般是自定义的</p>
<p>例如打开微信扫码的 SCHEME：weixin:&#x2F;&#x2F;scanqrcode<br>protocol 是 weixin，host 则是 scanqrcode</p>
<h3 id="拦截-URL-SCHEME-的主要流程"><a href="#拦截-URL-SCHEME-的主要流程" class="headerlink" title="拦截 URL SCHEME 的主要流程"></a>拦截 URL SCHEME 的主要流程</h3><p>Web 端通过某种方式（例如 <code>iframe.src</code>）发送 URL Scheme 请求，之后 Native 拦截到请求，并根据 URL SCHEME（包括所带的参数）进行相关操作（类似<code>JSONP</code>的方式）</p>
<h3 id="URL-SCHEME-的缺陷"><a href="#URL-SCHEME-的缺陷" class="headerlink" title="URL SCHEME 的缺陷"></a>URL SCHEME 的缺陷</h3><p>1）使用 <code>iframe.src</code> 发送 URL SCHEME 会有 url 长度的隐患<br>2）创建请求，需要一定的耗时，比注入 API 的方式调用同样的功能，耗时会较长</p>
]]></content>
  </entry>
  <entry>
    <title>自动化测试</title>
    <url>/2023/01/15/auto-testing/</url>
    <content><![CDATA[<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>为了更好的实施自动化测试，我们希望有一套简单但足够的自动化测试体系，能够从各个层面帮助我们开展自动化测试，从而交付高质量的软件代码。</p>
<p>本文包含三个部分，包括「测试流程」、「测试平台和工具」和「测试方法论」，各自关注不同的维度，整体形成一个良好的体系。</p>
<span id="more"></span>

<h1 id="测试流程"><a href="#测试流程" class="headerlink" title="测试流程"></a>测试流程</h1><p>测试流程关注测试开发的过程中，应该以怎样的流程来实施，以便测试的最佳效果。</p>
<h2 id="用例设计"><a href="#用例设计" class="headerlink" title="用例设计"></a>用例设计</h2><p>测试用例的设计需要考虑多个层面，尽量全方位的考虑所有场景，包括但不限于如下层面：</p>
<ol>
<li>用户故事，特定功能需要满足的用户场景</li>
<li>权限需求，不同权限可能的差异</li>
<li>异常场景，一些异常可能出现的问题，如何恢复</li>
<li>兼容性，对环境、设备、浏览器的要求</li>
<li>性能层面，数据量是否很大，是否有极致的性能需求<br>这上面的东西，是测试用例设计的需求，在需求明确之后，就可以针对它们设计具体的测试用例。</li>
</ol>
<p>好的测试用例是一个完备的集合，覆盖所有等价类与关键值，设计好的测试用例有三种常用的方式：</p>
<ol>
<li>等价类划</li>
<li>边界值</li>
<li>错误推测</li>
</ol>
<h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><p>测试用例的设计可以分为以下几个步骤：</p>
<ol>
<li>画一个较粗的业务流程图，包含所有的流程分支，图内每个节点可以较粗，比如“短信验证码登录”就是一个节点，先不用细分手机号是否已注册，或者对应的用户是什么身份。</li>
<li>我们把流程图中最长的主流程称为基本流 1，其他分支也依次标号，然后就可以组合出该流程图中所有可能的子流程，比如 1 + 2 + 4。<br>○ 当流程图比较复杂导致组合情况过多时，可以寻找解耦点將它拆分为两个甚至多个彼此之间耦合度较低的流程图，也就是说一个流程以哪一条路径执行基本不影响另一个流程的正确性。然后对拆分后的流程图罗列组合。<br>○ 我们可以进一步降低流程图的复杂度，不把“表单验证失败”的节点写在流程图中，每个表单的验证可以做成单独的测试用例。比如“短信验证码登录”的失败原因分为手机号格式不对、验证码错误、验证码过期等等，这些可以单独汇总在一个测试用例中去测试。</li>
<li>～～对上述的组合结果进行精简，依然从耦合度的角度去考虑。假设我们的组合中有 1 + 2、1 + 3 和 1 + 2 + 3，而分支 3 的执行与否对分支 2 的正确性几无影响，那么在已测试 1 + 2 和 1 + 3 的基础上，1 + 2 + 3 的性价比非常低，对测试效果的提升很小，可以被精简掉。这个比较依赖设计者的经验去判断哪些是“无意义”的组合。～～<br>○ 这一条先注释掉，不太好解释和实施，需要在实践中再打磨。</li>
<li>为精简后的每一个组合编写一个测试用例。对于用例中的每一个节点步骤，此时要考虑它的细分场景。比如“短信验证码登录”，需要先按业务场景拆分为学生登录、老师登录、家长登录、未注册手机号登录 4 种可能性。<br>○ 原则上每一种可能性都应当是一个单独的测试用例，但为了不重复编写差别很小的用例，我们可以在一个用例中描述一个节点的多个输入值。在实际执行用例时，可以选择在一个节点上测试多个输入值再继续往下也可以每个输入值都跑一遍用例中的流程，这个也需要执行者依靠经验来灵活判断。<br>○ 我们需要同时在测试用例管理工具中保存业务流程图，为执行者理解测试用例和设计者将来随着业务变化更新测试用例提供方便。<br>○ 设计测试用例是一个再次检查产品逻辑严密性的好时机，遇到问题需要及时与产品经理沟通。<br>○ 很多用例，尤其是表单验证类的，需要用等价类划分和边界值的方法去设计多种输入值。</li>
<li>然后设计者需要基于对业务的了解补充针对不在正常业务逻辑中的异常场景、安全性敏感场景、性能敏感场景的测试用例，就得到了完整的冒烟测试和黑盒测试集。<br>○ 有些“副作用”式的功能可以考虑集中在一个测试用例中描述，比如任务的推送，可以写一个测试用例集中测试，包括任务的创建、修改、驳回等各种情况的推送。</li>
<li>最后我们需要根据黑盒测试集做 E2E UI 自动化测试，考虑到编写效率和运行效率，思路是一长多短：<br>a. 在一个模块的用例中取一个最长的基本流先实现。<br>b. 实现其他未被覆盖的短分支。</li>
</ol>
<h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>这是一个 App 用手机号登录后选择身份进入主页的流程图，按照上文我们提供的方法：<br><img src="/images/test.png" alt="test"></p>
<ol>
<li>这个流程原本属于一个更长的流程，前面是手机号登录的流程，两部分加起来是一个完整的 App 登录流程，但是我们认为这个子流程之间的耦合度不高，所以选择了在中间解耦，变成两个流程分别测试。</li>
<li>在编写黑盒测试用例时，我们得到的组合集是：<br>a. 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5<br>b. 1 -&gt; 4 -&gt; 5<br>c. 1 -&gt; 4 -&gt; 3 -&gt; 4 -&gt; 5<br>外加一个绑定新身份时的表单验证。</li>
<li>在编写 E2E UI 自动化测试时，我们先实现最长基本流，然后实现剩下的短分支，所以最后编写的用例是：<br>a. 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5<br>b. 1 -&gt; 4 -&gt; 5<br>c. 1 -&gt; 4 -&gt; 3</li>
</ol>
<h2 id="测试规划"><a href="#测试规划" class="headerlink" title="测试规划"></a>测试规划</h2><p>在需求明确之后，有大致的测试用例之后，应该对测试的实施有一个大致的规划，一定程度的明确各个类型的测试做多少，怎么做。</p>
<p>比如对于复杂的项目，我们可能需要更多的单元测试，从而保证逻辑的正确性，对于简单的项目，可能一定的功能测试和 E2E 测试就可以了。</p>
<p>测试规划的时候，应该考虑到各种测试类型擅长的和不擅长的，合理安排比例以及覆盖场景，在成本可控的前提下实现效率的最大化。</p>
<h2 id="测试开发"><a href="#测试开发" class="headerlink" title="测试开发"></a>测试开发</h2><p>规划完毕之后，就可以和代码开发一起，进入测试开发的环节，在开发的过程中，一定会发现之前没有考虑到的情况，或者发现效率更高的方法，这时及时调整策略，优化方案。</p>
<h1 id="测试平台与工具"><a href="#测试平台与工具" class="headerlink" title="测试平台与工具"></a>测试平台与工具</h1><p>测试平台和工具包含测试工具相关的东西，通过优秀工具的使用和研发，让测试开发能够非常简单的进行，找到测试开发的乐趣。</p>
<h2 id="测试数据管理平台"><a href="#测试数据管理平台" class="headerlink" title="测试数据管理平台"></a>测试数据管理平台</h2><p>测试数据是进行高效测试的基础，尤其是对于我们这种 toB 复杂业务逻辑来说，如果没有良好基础测试数据的支持，我们将花费大量时间在测试数据的准备上，测试的编写和维护将会变成一件很难受的工作。</p>
<p>为了解决这个问题，我们引入测试数据管理平台，他能够帮助我们管理各种测试数据，需要的时候，通过很简单的方式就可能调用这些测试数据，减少人工构造的成本。</p>
<p>这之中的测试数据将主要用到以下四个地方：</p>
<ol>
<li>后端功能测试</li>
<li>前端 E2E 测试</li>
<li>demo 系统</li>
<li>开发环境</li>
</ol>
<p>对这个平台而言，它将提供如下功能：</p>
<ol>
<li>测试数据存储与管理</li>
<li>测试数据的写入与生成</li>
<li>多套后端服务的配置管理，同一个平台，可以向多个后端写入数据？</li>
<li>通过对外 API，能够通过 API 执行指定的命令</li>
<li>依据 client 请求执行单个&#x2F;批量数据请求&#x2F;写入操作</li>
</ol>
<p>目前这个平台主要提供一套相对固定的数据， 将来，它应该有能力按需及时生成一部分数据，能够用于对数据之间关系要求不高的场景。</p>
<h2 id="后端测试工具"><a href="#后端测试工具" class="headerlink" title="后端测试工具"></a>后端测试工具</h2><p>为了改善后端测试的效率，我们已经&#x2F;需要开发一些测试工具，让测试开发更简单，主要包含如下几个部分：</p>
<ol>
<li>基础测试工具，是对开源工具的改善和封装，比如 UTL <a href="https://git.seiue.com/open-source/utl/tree/master">https://git.seiue.com/open-source/utl/tree/master</a></li>
<li>应用层相关工具，比如 <a href="https://www.yuque.com/kovru3/gfdy75/ygtibk">https://www.yuque.com/kovru3/gfdy75/ygtibk</a> 这里面说的</li>
<li>与测试数据平台的交互，交互方式是什么？类似 UDS 注册的机制？</li>
<li>Reponse 与 schema 定义的一致性检查</li>
</ol>
<h2 id="前端测试工具"><a href="#前端测试工具" class="headerlink" title="前端测试工具"></a>前端测试工具</h2><p>同理，前端差不多，可能包含如下几个部分：</p>
<ol>
<li>基础测试工具最佳实践，封装</li>
<li>数据 Mock 的机制，什么时候 Mock</li>
<li>测试数据平台通信的方式</li>
</ol>
<h1 id="测试方法论"><a href="#测试方法论" class="headerlink" title="测试方法论"></a>测试方法论</h1><h2 id="编写可测试代码"><a href="#编写可测试代码" class="headerlink" title="编写可测试代码"></a>编写可测试代码</h2><p>为了良好的实施自动化测试，我们对各方实施一定的约束，以便能够高效的开展自动化测试，让自动化测试的效能最大化。</p>
<h2 id="被测主体约束"><a href="#被测主体约束" class="headerlink" title="被测主体约束"></a>被测主体约束</h2><p>被测试主体（包括但不限于后端服务，前端组件，数据层）都应该提供良好的数据测试支持，这样测试代码才能够很好的与测试主体进行交互，从而高效的完成测试。</p>
<p>比如，后端在进行 API 设计的时候需要考虑到测试的场景，能够通过 API 准备需要的测试数据，也可能需要给测试提供专用的 API。</p>
<p>前端可能将数据数据操作接口暴露到外部，能够让测试代码直接操作内部方法和数据，以便方便高效的完成自动化测试（见附[1]）。</p>
<p>被测试主体应该同时满足多方面的需求，包括但不限于：</p>
<ol>
<li>业务需求</li>
<li>测试需求</li>
<li>架构需求</li>
</ol>
<h3 id="代码约束"><a href="#代码约束" class="headerlink" title="代码约束"></a>代码约束</h3><p>为了进行良好的单元测试，对我们的代码也提出了更高的要求，我们的代码需要更好的可测试性，具体来说包含如下几个方面：</p>
<ol>
<li>功能划分清晰，职责分明，函数、类的实现应该高内聚，底耦合，一个方法只做一件事</li>
<li>外部依赖显式化，依赖的东西应该单独测试 附[2]</li>
<li>尽量避免副作用，输入输出应该简单统一</li>
<li>More needed</li>
</ol>
<h2 id="数据与行为分离"><a href="#数据与行为分离" class="headerlink" title="数据与行为分离"></a>数据与行为分离</h2><p>在测试中，有很多时候我们需要对同一个场景使用不同的数据进行测试，同时期望获取不同的结果，这时如果测试数据和测试代码耦合在一起，就需要将他们同时复制多份，代码可读性和维护起来都是一个问题。</p>
<p>这时，我们可以采用数据与行为分离的策略，将测试行为抽象出来，然后再用给定的数据跑测试。</p>
<p>在 PHP 项目中，我们可以 PHPUnit 的 DataProvider 实现这样的策略，在前端的 Jest 中，也可以使用 jest.each 达成同样的效果。不同测试框架都应该有类似的支持（hmmm, Cypress 好像没有原生的支持）。</p>
<h2 id="App-Actions"><a href="#App-Actions" class="headerlink" title="App Actions"></a>App Actions</h2><p>在 E2E 测试中，传统的做法是封装 PageObject，用来封装 UI 层的操作，以便让测试代码更加易于维护，但因为 UI 层的变化一般比较大，这一层的封装成本比较高，而且所有地方都通过 UI 来操作效率很低，稳定性也不好。</p>
<p>所以，Cypress 采用了另外的思路，就是直接在测试代码中操作应用的内部逻辑，我们把这种方式称作 App Actions。某种程度上去掉了和简化了 PageObject 这个封装，从而减少的响应的成本。</p>
<p>它的缺点是需要理解应用的内部状态，但因为我们是开发者自己写测试，所以这个反而变成了优点。</p>
<p>读者具体可以查看 <a href="https://www.cypress.io/blog/2019/01/03/stop-using-page-objects-and-start-using-app-actions/">Stop using Page Objects and Start using App Actions</a> 了解更详细的内容。</p>
<h1 id="实施计划"><a href="#实施计划" class="headerlink" title="实施计划"></a>实施计划</h1><p>测试数据平台<br>[ ] 测试平台准备工作（P0）<br>[ ] 方案优化空间<br>[ ] 环境初始化<br>[ ] 对外提供 API (P1)</p>
<p>测试数据<br>[ ] 用户数据 (P0)<br>[ ] What’s else?</p>
<p>测试工具<br>[ ] 后端测试工具整理和规范 UTL<br>[ ] 后端针对 Event 和 Job 的测试工具<br>[ ] 后端 response 与 schema 的一致性检查 (P0)<br>[ ] 后端与测试平台的交互机制？(P0)<br>[ ] 前端测试工具的实践<br>[ ] 前端与测试平台的交互机制 (P0)<br>[ ] 前端 Mock 的场景与机制</p>
<p>测试流程&#x2F;方法论<br>[ ] 形成最佳实践（跟随实践不断迭代）</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>[1] <a href="https://www.cypress.io/blog/2019/01/03/stop-using-page-objects-and-start-using-app-actions/">https://www.cypress.io/blog/2019/01/03/stop-using-page-objects-and-start-using-app-actions/</a><br>[2] <a href="http://www.voidcn.com/article/p-uyjitnuy-bno.html">http://www.voidcn.com/article/p-uyjitnuy-bno.html</a></p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>JS实现倒计时</title>
    <url>/2019/10/01/countdown/</url>
    <content><![CDATA[<p>天，小时，分钟，秒钟倒计时</p>
<span id="more"></span>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>倒计时<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;day&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;hour&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;minute&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;second&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> deadline = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;2019-10-1 00:00:00&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> dayElement = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.day&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> hourElement = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.hour&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> minuteElement = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.minute&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> secondElement = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.second&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> <span class="title function_">countDown</span> = (<span class="params"></span>) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> timeRemaining = deadline - <span class="keyword">new</span> <span class="title class_">Date</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> day, hour, minute, second;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (timeRemaining &lt; <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">return</span> <span class="number">0</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        day = <span class="title class_">Math</span>.<span class="title function_">floor</span>(timeRemaining / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> / <span class="number">24</span>);</span></span><br><span class="line"><span class="language-javascript">        hour = <span class="title class_">Math</span>.<span class="title function_">floor</span>((timeRemaining / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span>) % <span class="number">24</span>);</span></span><br><span class="line"><span class="language-javascript">        minute = <span class="title class_">Math</span>.<span class="title function_">floor</span>((timeRemaining / <span class="number">1000</span> / <span class="number">60</span>) % <span class="number">60</span>);</span></span><br><span class="line"><span class="language-javascript">        second = <span class="title class_">Math</span>.<span class="title function_">floor</span>((timeRemaining / <span class="number">1000</span>) % <span class="number">60</span>);</span></span><br><span class="line"><span class="language-javascript">        dayElement.<span class="property">innerHTML</span> = day + <span class="string">&quot;天&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        hourElement.<span class="property">innerHTML</span> = hour + <span class="string">&quot;时&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        minuteElement.<span class="property">innerHTML</span> = minute + <span class="string">&quot;分&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        secondElement.<span class="property">innerHTML</span> = second + <span class="string">&quot;秒&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="built_in">setTimeout</span>(countDown, <span class="number">1000</span>);</span></span><br><span class="line"><span class="language-javascript">      &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">countDown</span>();</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖节流函数</title>
    <url>/2023/12/18/debounce-throttle/</url>
    <content><![CDATA[<h1 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h1><p>应用场景：搜索框输入文字后调用对应搜索接口</p>
<p>利用闭包，不管触发频率多高，在停止触发 n 秒后才会执行，如果重复触发，会清空之前的定时器，重新计时，直到最后一次 n 秒后执行</p>
<span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @param &#123;function&#125; fn - 需要防抖的函数</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; time - 多长时间执行一次</span></span><br><span class="line"><span class="comment"> * @param &#123;boolean&#125; flag - 第一次是否执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, time, flag</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="comment">// 在time时间段内重复执行，会清空之前的定时器，然后重新计时</span></span><br><span class="line">    timer &amp;&amp; <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    <span class="keyword">if</span> (flag &amp;&amp; !timer) &#123;</span><br><span class="line">      <span class="comment">// flag为true 第一次默认执行</span></span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;执行:&quot;</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> debounceFn = <span class="title function_">debounce</span>(fn, <span class="number">3000</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="title function_">debounceFn</span>(<span class="number">1</span>);</span><br><span class="line"><span class="title function_">debounceFn</span>(<span class="number">2</span>);</span><br><span class="line"><span class="title function_">debounceFn</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先打印：执行: 1</span></span><br><span class="line"><span class="comment">// 3s后打印: 执行: 3</span></span><br></pre></td></tr></table></figure>

<h1 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h1><p>应用场景： 下拉滚动加载</p>
<p>利用闭包，不管触发频率多高，每隔一段时间内执行一次</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @param &#123;function&#125; fn - 需要防抖的函数</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; time - 多长时间执行一次</span></span><br><span class="line"><span class="comment"> * @param &#123;boolean&#125; flag - 第一次是否执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, time, flag</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="comment">// flag控制第一次是否立即执行</span></span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">      <span class="comment">// 第一次执行完后，flag变为false；否则以后每次都会执行</span></span><br><span class="line">      flag = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">        <span class="comment">// 每次执行完重置timer</span></span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">      &#125;, time);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fn&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> throttleFn = <span class="title function_">throttle</span>(fn, <span class="number">3000</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">setInterval</span>(throttleFn, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试结果，一开始就打印&quot;fn&quot;, 以后每隔3s打印一次&quot;fn&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2021/10/14/design-patterns/</url>
    <content><![CDATA[<p>设计模式是从许多优秀的软件系统中，总结出的成功的、能够实现可维护性、复用的设计方案，使用这些方案将可以让我们避免做一些重复性的工作。</p>
<span id="more"></span>

<h1 id="单例模式-弹框"><a href="#单例模式-弹框" class="headerlink" title="单例模式(弹框)"></a>单例模式(弹框)</h1><p>一个类只能构造出唯一实例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Single</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getInstance</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">instance</span>) &#123;</span><br><span class="line">      <span class="comment">// 关键代码 this指向的是Single这个构造函数</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">instance</span> = <span class="keyword">new</span> <span class="title class_">Single</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">instance</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> single1 = <span class="title class_">Single</span>.<span class="title function_">getInstance</span>(<span class="string">&quot;name1&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> single2 = <span class="title class_">Single</span>.<span class="title function_">getInstance</span>(<span class="string">&quot;name2&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(single1 === single2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h1 id="策略模式-表单验证"><a href="#策略模式-表单验证" class="headerlink" title="策略模式(表单验证)"></a>策略模式(表单验证)</h1><p>根据不同参数命中不同的策略</p>
<h2 id="策略模式的表单验证示例"><a href="#策略模式的表单验证示例" class="headerlink" title="策略模式的表单验证示例"></a>策略模式的表单验证示例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 策略对象</span></span><br><span class="line"><span class="keyword">const</span> strategies = &#123;</span><br><span class="line">  <span class="comment">// 验证是否为空</span></span><br><span class="line">  <span class="attr">isNoEmpty</span>: <span class="keyword">function</span>(<span class="params">value, errorMsg</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value.<span class="title function_">trim</span>() === <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 验证最小长度</span></span><br><span class="line">  <span class="attr">minLength</span>: <span class="keyword">function</span>(<span class="params">value, length, errorMsg</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value.<span class="title function_">trim</span>().<span class="property">length</span> &lt; length) &#123;</span><br><span class="line">      <span class="keyword">return</span> errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 验证最大长度</span></span><br><span class="line">  <span class="attr">maxLength</span>: <span class="keyword">function</span>(<span class="params">value, length, errorMsg</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value.<span class="property">length</span> &gt; length) &#123;</span><br><span class="line">      <span class="keyword">return</span> errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 验证手机号</span></span><br><span class="line">  <span class="attr">isMobile</span>: <span class="keyword">function</span>(<span class="params">value, errorMsg</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      !<span class="regexp">/^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|17[7]|18[0|1|2|3|5|6|7|8|9])\d&#123;8&#125;$/</span>.<span class="title function_">test</span>(</span><br><span class="line">        value</span><br><span class="line">      )</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Validator</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span> = []; <span class="comment">// 存储要验证的方法</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">errList</span> = []; <span class="comment">// 存储最终的验证结果</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">add</span>(<span class="params">value, rules</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, rule; (rule = rules[i++]); ) &#123;</span><br><span class="line">      <span class="keyword">let</span> strategyAry = rule.<span class="property">strategy</span>.<span class="title function_">split</span>(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">      <span class="keyword">let</span> errorMsg = rule.<span class="property">errorMsg</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> strategy = strategyAry.<span class="title function_">shift</span>();</span><br><span class="line">        strategyAry.<span class="title function_">unshift</span>(value);</span><br><span class="line">        strategyAry.<span class="title function_">push</span>(errorMsg);</span><br><span class="line">        <span class="comment">// 执行策略对象中的不同验证规则</span></span><br><span class="line">        <span class="keyword">let</span> error = strategies[strategy](...strategyAry <span class="string">&quot;strategy&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">errList</span>.<span class="title function_">push</span>(error);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">start</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, validatorFunc; (validatorFunc = <span class="variable language_">this</span>.<span class="property">cache</span>[i++]); ) &#123;</span><br><span class="line">      <span class="title function_">validatorFunc</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">errList</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> validataFunc = <span class="keyword">function</span>(<span class="params">info</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> validator = <span class="keyword">new</span> <span class="title class_">Validator</span>();</span><br><span class="line">  validator.<span class="title function_">add</span>(info.<span class="property">userName</span>, [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">strategy</span>: <span class="string">&quot;isNoEmpty&quot;</span>,</span><br><span class="line">      <span class="attr">errorMsg</span>: <span class="string">&quot;用户名不可为空&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">strategy</span>: <span class="string">&quot;minLength:2&quot;</span>,</span><br><span class="line">      <span class="attr">errorMsg</span>: <span class="string">&quot;用户名长度不能小于2位&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]);</span><br><span class="line">  validator.<span class="title function_">add</span>(info.<span class="property">password</span>, [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">strategy</span>: <span class="string">&quot;minLength:6&quot;</span>,</span><br><span class="line">      <span class="attr">errorMsg</span>: <span class="string">&quot;密码长度不能小于6位&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]);</span><br><span class="line">  validator.<span class="title function_">add</span>(info.<span class="property">phoneNumber</span>, [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">strategy</span>: <span class="string">&quot;isMobile&quot;</span>,</span><br><span class="line">      <span class="attr">errorMsg</span>: <span class="string">&quot;请输入正确的手机号码格式&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]);</span><br><span class="line">  <span class="keyword">return</span> validator.<span class="title function_">start</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要验证表单的对象</span></span><br><span class="line"><span class="keyword">let</span> userInfo = &#123;</span><br><span class="line">  <span class="attr">userName</span>: <span class="string">&quot;王&quot;</span>,</span><br><span class="line">  <span class="attr">password</span>: <span class="string">&quot;1234&quot;</span>,</span><br><span class="line">  <span class="attr">phoneNumber</span>: <span class="string">&quot;666&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> errorMsg = <span class="title function_">validataFunc</span>(userInfo);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(errorMsg); <span class="comment">// [&#x27;用户名长度不能小于2位&#x27;, &#x27;密码长度不能小于6位&#x27;, &#x27;请输入正确的手机号码格式&#x27;]</span></span><br></pre></td></tr></table></figure>

<h1 id="代理模式-图片预加载"><a href="#代理模式-图片预加载" class="headerlink" title="代理模式(图片预加载)"></a>代理模式(图片预加载)</h1><p>代理对象和本体对象具有一致的接口</p>
<h2 id="图片代理模式示例"><a href="#图片代理模式示例" class="headerlink" title="图片代理模式示例"></a>图片代理模式示例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代理模式</span></span><br><span class="line"><span class="keyword">let</span> relImage = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> imgNode = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(imgNode);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">setSrc</span>(<span class="params">src</span>) &#123;</span><br><span class="line">      imgNode.<span class="property">src</span> = src;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">let</span> proxyImage = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">  <span class="comment">// 实际要加载的图片 加载成功后 替换调占位图</span></span><br><span class="line">  img.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    relImage.<span class="title function_">setSrc</span>(img.<span class="property">src</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">setSrc</span>(<span class="params">src</span>) &#123;</span><br><span class="line">      img.<span class="property">src</span> = src;</span><br><span class="line">      <span class="comment">// 设置占位图</span></span><br><span class="line">      relImage.<span class="title function_">setSrc</span>(</span><br><span class="line">        <span class="string">&quot;https://fuss10.elemecdn.com/e/5d/4a731a90594a4af544c0c25941171jpeg.jpeg&quot;</span></span><br><span class="line">      );</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置实际要加载的图片</span></span><br><span class="line">proxyImage.<span class="title function_">setSrc</span>(</span><br><span class="line">  <span class="string">&quot;https://cube.elemecdn.com/6/94/4d3ea53c084bad6931a56d5158a48jpeg.jpeg&quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h1 id="装饰者模式-在函数执行前后添加新的方法"><a href="#装饰者模式-在函数执行前后添加新的方法" class="headerlink" title="装饰者模式(在函数执行前后添加新的方法)"></a>装饰者模式(在函数执行前后添加新的方法)</h1><p>在不改变对象自身的基础上，动态地给某个对象添加一些额外的职责</p>
<h2 id="装饰者模式示例"><a href="#装饰者模式示例" class="headerlink" title="装饰者模式示例"></a>装饰者模式示例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fuc</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">before</span> = <span class="keyword">function</span> (<span class="params">beFn</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    beFn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>); <span class="comment">// 先执行插入到前面的方法，类似于二叉树的前序遍历</span></span><br><span class="line">    <span class="keyword">return</span> self.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>); <span class="comment">// 后执行当前的方法</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">after</span> = <span class="keyword">function</span> (<span class="params">afFn</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    self.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>); <span class="comment">// 先执行当前的方法</span></span><br><span class="line">    <span class="keyword">return</span> afFn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>); <span class="comment">// 后执行插入到后面的方法</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fuc1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fuc3</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fuc4</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fuc = fuc.<span class="title function_">before</span>(fuc1).<span class="title function_">before</span>(fuc4).<span class="title function_">after</span>(fuc3);</span><br><span class="line"><span class="title function_">fuc</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终打印结果：4 1 2 3</span></span><br></pre></td></tr></table></figure>

<h1 id="组合模式-打印文件目录"><a href="#组合模式-打印文件目录" class="headerlink" title="组合模式(打印文件目录)"></a>组合模式(打印文件目录)</h1><p>组合模式在对象间形成树形结构<br>组合模式中基本对象和组合对象被一致对待<br>无须关心对象有多少层, 调用时只需在根部进行调用</p>
<h2 id="函数组合模式示例"><a href="#函数组合模式示例" class="headerlink" title="函数组合模式示例"></a>函数组合模式示例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Combine</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">add</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">push</span>(fn);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>; <span class="comment">// 链式调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">excute</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">list</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">list</span>[i].<span class="title function_">excute</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> comb1 = <span class="keyword">new</span> <span class="title class_">Combine</span>();</span><br><span class="line">comb1</span><br><span class="line">  .<span class="title function_">add</span>(&#123;</span><br><span class="line">    <span class="title function_">excute</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">add</span>(&#123;</span><br><span class="line">    <span class="title function_">excute</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> comb2 = <span class="keyword">new</span> <span class="title class_">Combine</span>();</span><br><span class="line">comb2</span><br><span class="line">  .<span class="title function_">add</span>(&#123;</span><br><span class="line">    <span class="title function_">excute</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">add</span>(&#123;</span><br><span class="line">    <span class="title function_">excute</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> comb3 = <span class="keyword">new</span> <span class="title class_">Combine</span>();</span><br><span class="line">comb3</span><br><span class="line">  .<span class="title function_">add</span>(&#123;</span><br><span class="line">    <span class="title function_">excute</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">add</span>(&#123;</span><br><span class="line">    <span class="title function_">excute</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">comb2.<span class="title function_">add</span>(comb3);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> comb4 = <span class="keyword">new</span> <span class="title class_">Combine</span>();</span><br><span class="line">comb4.<span class="title function_">add</span>(comb1).<span class="title function_">add</span>(comb2);</span><br><span class="line">comb4.<span class="title function_">excute</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终打印结果：1 2 3 4 5 6</span></span><br></pre></td></tr></table></figure>

<h1 id="工厂模式-jquery-中的-window"><a href="#工厂模式-jquery-中的-window" class="headerlink" title="工厂模式(jquery 中的 window.$)"></a>工厂模式(jquery 中的 window.$)</h1><p>工厂模式是用来创建对象的一种最常用的设计模式</p>
<p>不暴露创建对象的具体逻辑，而是将逻辑封装在一个函数中，这个函数就可以被视为一个工厂</p>
<h2 id="工厂模式示例"><a href="#工厂模式示例" class="headerlink" title="工厂模式示例"></a>工厂模式示例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, color</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">create</span>(<span class="params">type</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;car&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;汽车&quot;</span>, <span class="string">&quot;白色&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;bicycle&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;自行车&quot;</span>, <span class="string">&quot;黑色&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="attr">default</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;没有该类型&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Factory</span>.<span class="title function_">create</span>(<span class="string">&quot;car&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Factory</span>.<span class="title function_">create</span>(<span class="string">&quot;bicycle&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1, p1 <span class="keyword">instanceof</span> <span class="title class_">Car</span>); <span class="comment">// &#123;name: &#x27;汽车&#x27;, color: &#x27;白色&#x27;&#125; true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2, p2 <span class="keyword">instanceof</span> <span class="title class_">Car</span>); <span class="comment">// &#123;name: &#x27;自行车&#x27;, color: &#x27;黑色&#x27;&#125; true</span></span><br></pre></td></tr></table></figure>

<h1 id="访问者模式-babel-插件"><a href="#访问者模式-babel-插件" class="headerlink" title="访问者模式(babel 插件)"></a>访问者模式(babel 插件)</h1><p>在不改变该对象的前提下访问其结构中元素的新方法</p>
<h2 id="访问者模式示例"><a href="#访问者模式示例" class="headerlink" title="访问者模式示例"></a>访问者模式示例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 元素类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, chinese, math, english</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">chinese</span> = chinese;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">math</span> = math;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">english</span> = english;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">accept</span>(<span class="params">visitor</span>) &#123;</span><br><span class="line">    visitor.<span class="title function_">visit</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问者类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChineseTeacher</span> &#123;</span><br><span class="line">  <span class="title function_">visit</span>(<span class="params">student</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`语文 <span class="subst">$&#123;student.chinese&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MathTeacher</span> &#123;</span><br><span class="line">  <span class="title function_">visit</span>(<span class="params">student</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`数学 <span class="subst">$&#123;student.math&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EnglishTeacher</span> &#123;</span><br><span class="line">  <span class="title function_">visit</span>(<span class="params">student</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`英语 <span class="subst">$&#123;student.english&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化元素类</span></span><br><span class="line"><span class="keyword">const</span> student = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">90</span>, <span class="number">80</span>, <span class="number">60</span>);</span><br><span class="line"><span class="comment">// 实例化访问者类</span></span><br><span class="line"><span class="keyword">const</span> chineseTeacher = <span class="keyword">new</span> <span class="title class_">ChineseTeacher</span>();</span><br><span class="line"><span class="keyword">const</span> mathTeacher = <span class="keyword">new</span> <span class="title class_">MathTeacher</span>();</span><br><span class="line"><span class="keyword">const</span> englishTeacher = <span class="keyword">new</span> <span class="title class_">EnglishTeacher</span>();</span><br><span class="line"><span class="comment">// 接受访问</span></span><br><span class="line">student.<span class="title function_">accept</span>(chineseTeacher); <span class="comment">// 语文90</span></span><br><span class="line">student.<span class="title function_">accept</span>(mathTeacher); <span class="comment">// 数学80</span></span><br><span class="line">student.<span class="title function_">accept</span>(englishTeacher); <span class="comment">// 英语60</span></span><br></pre></td></tr></table></figure>

<h1 id="发布订阅模式-EventBus"><a href="#发布订阅模式-EventBus" class="headerlink" title="发布订阅模式(EventBus)"></a>发布订阅模式(EventBus)</h1><p>订阅者订阅相关主题，发布者通过发布主题事件的方式，通知订阅该主题的对象</p>
<h2 id="手写发布订阅模式示例"><a href="#手写发布订阅模式示例" class="headerlink" title="手写发布订阅模式示例"></a>手写发布订阅模式示例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发布订阅模式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventBus</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">task</span> = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">on</span>(<span class="params">type, fn</span>) &#123;</span><br><span class="line">    <span class="comment">// on 注册事件</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">task</span>[type]) <span class="variable language_">this</span>.<span class="property">task</span>[type] = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">task</span>[type].<span class="title function_">push</span>(fn);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">emit</span>(<span class="params">type, ...args</span>) &#123;</span><br><span class="line">    <span class="comment">// emit 发送事件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">task</span>[type]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">task</span>[type].<span class="title function_">forEach</span>(<span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">        fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args); <span class="comment">// 注意this指向</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">off</span>(<span class="params">type, fn</span>) &#123;</span><br><span class="line">    <span class="comment">// 删除事件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">task</span>[type]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">task</span>[type] = <span class="variable language_">this</span>.<span class="property">task</span>[type].<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item !== fn);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">once</span>(<span class="params">type, fn</span>) &#123;</span><br><span class="line">    <span class="comment">// 只执行一次</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">      <span class="title function_">fn</span>(...args);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">off</span>(type, f);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">on</span>(type, f);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">let</span> event = <span class="keyword">new</span> <span class="title class_">EventBus</span>();</span><br><span class="line">event.<span class="title function_">on</span>(<span class="string">&quot;change&quot;</span>, <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(args);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 只执行一次</span></span><br><span class="line">event.<span class="title function_">once</span>(<span class="string">&quot;change&quot;</span>, <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(args);</span><br><span class="line">&#125;);</span><br><span class="line">event.<span class="title function_">emit</span>(<span class="string">&quot;change&quot;</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">event.<span class="title function_">emit</span>(<span class="string">&quot;change&quot;</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h1 id="观察者模式-vue-双向绑定"><a href="#观察者模式-vue-双向绑定" class="headerlink" title="观察者模式(vue 双向绑定)"></a>观察者模式(vue 双向绑定)</h1><p>一个对象有一系列依赖于它的观察者（watcher），当对象发生变化时，会通知观察者进行更新</p>
<h2 id="观察者模式示例"><a href="#观察者模式示例" class="headerlink" title="观察者模式示例"></a>观察者模式示例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;ming&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(data).<span class="title function_">forEach</span>(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> value = data[key];</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data, key, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;get&quot;</span>, value);</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;更新&quot;</span>);</span><br><span class="line">      value = newValue;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">data.<span class="property">name</span> = <span class="string">&quot;佩奇&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="property">name</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依次打印： 更新 → get 佩奇 → 佩奇</span></span><br></pre></td></tr></table></figure>

<h1 id="观察者与发布订阅模式的区别"><a href="#观察者与发布订阅模式的区别" class="headerlink" title="观察者与发布订阅模式的区别"></a>观察者与发布订阅模式的区别</h1><p>观察者模式：一个对象有一系列依赖于它的观察者（watcher），当对象发生变化时，会通知观察者进行更新</p>
<p>发布订阅模式：订阅者订阅相关主题，发布者通过发布主题事件的方式通知订阅该主题的对象，发布订阅模式中可以基于不同的主题去执行不同的自定义事件</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS 垃圾回收机制</title>
    <url>/2023/01/15/garbage-recycling-mechanism/</url>
    <content><![CDATA[<h1 id="一、垃圾回收机制——GC"><a href="#一、垃圾回收机制——GC" class="headerlink" title="一、垃圾回收机制——GC"></a>一、垃圾回收机制——GC</h1><p>Javascript 具有自动垃圾回收机制（GC：Garbage Collecation），也就是说，执行环境会负责管理代码执行过程中使用的内存。</p>
<p>原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。</p>
<p>通常情况下有两种实现方式：</p>
<span id="more"></span>

<h2 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2><p>js 中最常用的垃圾回收方式就是标记清除。</p>
<p>当变量进入环境时，例如，在函数中声明一个变量，就将这个变量<strong>标记为“进入环境”</strong>。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其<strong>标记为“离开环境”</strong>。</p>
<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p><strong>跟踪记录每个值被引用的次数</strong></p>
<p>当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为 0 的值所占用的内存。</p>
<h1 id="二、内存管理"><a href="#二、内存管理" class="headerlink" title="二、内存管理"></a>二、内存管理</h1><ol>
<li>Javascript 引擎基础 GC 方案是</li>
</ol>
<p>（simple GC）：mark and sweep（标记清除），即：</p>
<p>1）遍历所有可访问的对象；</p>
<p>2）回收已不可访问的对象。</p>
<ol start="2">
<li>GC 的缺陷</li>
</ol>
<p>和其他语言一样，JavaScript 的 GC 策略也无法避免一个问题：<strong>GC 时，停止响应其他操作</strong>，这是为了安全考虑。而 Javascript 的 GC 在 100ms 甚至以上，对一般的应用还好，但对于 JS 游戏，动画对连贯性要求比较高的应用，就麻烦了。<br>这就是新引擎需要优化的点：避免 GC 造成的长时间停止响应。</p>
<ol start="3">
<li>GC 优化策略</li>
</ol>
<p>1）分代回收（Generation GC）</p>
<p>这个和 Java 回收策略思想是一致的。目的是通过区分“临时”与“持久”对象；多回收“临时对象”区（young generation），少回收“持久对象”区（tenured generation），减少每次需遍历的对象，从而减少每次 GC 的耗时。</p>
<p>2）增量 GC</p>
<p>这个方案的思想很简单，就是“每次处理一点，下次再处理一点”，如此类推。</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>sleep 函数</title>
    <url>/2020/12/18/sleep-function/</url>
    <content><![CDATA[<p>JS 没有语言内置的休眠（sleep or wait）函数，所谓的 sleep 只是实现一种延迟执行的效果</p>
<p>等待指定时间后再执行对应方法</p>
<span id="more"></span>

<h2 id="方法一：伪死循环阻塞主线程"><a href="#方法一：伪死循环阻塞主线程" class="headerlink" title="方法一：伪死循环阻塞主线程"></a>方法一：伪死循环阻塞主线程</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 因为JS是单线程的，所以通过这种方式可以实现真正意义上的sleep</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sleep1</span>(<span class="params">fn, time</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> start = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>() - start &lt; time) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">fn</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方式二：-定时器"><a href="#方式二：-定时器" class="headerlink" title="方式二： 定时器"></a>方式二： 定时器</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sleep2</span>(<span class="params">fn, time</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(fn, time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方式三：promise"><a href="#方式三：promise" class="headerlink" title="方式三：promise"></a>方式三：promise</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function sleep3(fn, time) &#123;</span><br><span class="line">  new Promise(resolve =&gt; &#123;</span><br><span class="line">    setTimeout(resolve, time);</span><br><span class="line">  &#125;).then(() =&gt; &#123;</span><br><span class="line">    fn();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="方式四：async-await"><a href="#方式四：async-await" class="headerlink" title="方式四：async await"></a>方式四：async await</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">sleep4</span>(<span class="params">fn, time</span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, time);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="title function_">fn</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fn&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sleep1</span>(fn, <span class="number">2000</span>);</span><br><span class="line"><span class="title function_">sleep2</span>(fn, <span class="number">2000</span>);</span><br><span class="line"><span class="title function_">sleep3</span>(fn, <span class="number">2000</span>);</span><br><span class="line"><span class="title function_">sleep4</span>(fn, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>实现图片的懒加载</title>
    <url>/2022/12/14/img-lazyload/</url>
    <content><![CDATA[<p>图片的懒加载原理： 当图片元素出现在屏幕中时，才给图片的 src 赋值对应的链接，去加载对应的图片</p>
<span id="more"></span>

<p>使用 <code>IntersectionObserver</code> 监听元素来判断是否出现在视口，当图片出现在视口时，给 <code>img.src</code> 赋值</p>
<p><code>IntersectionObserver</code> 替代监听 <code>scroll</code> 事件来判断元素是否在视口中，性能更高</p>
<p>图片懒加载示例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// html内容</span></span><br><span class="line"><span class="comment">// &lt;img src=&quot;./loading.jpg&quot; src=&quot;https://cube.elemecdn.com/6/94/4d3ea53c084bad6931a56d5158a48jpeg.jpeg&quot;&gt;</span></span><br><span class="line"><span class="comment">// &lt;img src=&quot;./loading.jpg&quot; src=&quot;https://fuss10.elemecdn.com/e/5d/4a731a90594a4af544c0c25941171jpeg.jpeg&quot;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">observerImg</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> imgList = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(<span class="function">(<span class="params">list</span>) =&gt;</span> &#123;</span><br><span class="line">    list.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 判断元素是否出现在视口</span></span><br><span class="line">      <span class="keyword">if</span> (item.<span class="property">intersectionRatio</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        item.<span class="property">target</span>.<span class="property">src</span> = item.<span class="property">target</span>.<span class="title function_">getAttribute</span>(<span class="string">&quot;src&quot;</span>);</span><br><span class="line">        observer.<span class="title function_">unobserve</span>(item.<span class="property">target</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; imgList.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 监听每个img元素</span></span><br><span class="line">    observer.<span class="title function_">observe</span>(imgList[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>React 组件的编写</title>
    <url>/2022/03/08/react-components/</url>
    <content><![CDATA[<p>在编写 React 组件时，有一些最佳实践需要遵循：</p>
<span id="more"></span>

<h1 id="单一职责"><a href="#单一职责" class="headerlink" title="单一职责"></a>单一职责</h1><p>就像函数一样，组件也应当遵循单一职责的原则，即每个组件只能负责一个功能。请阅读<a href="https://zh-hans.reactjs.org/docs/thinking-in-react.html#step-1-break-the-ui-into-a-component-hierarchy">官方示例中的第一步</a>。</p>
<p>将一个功能复杂的大组件拆分为多个职责单一的小组件可以获得以下好处：</p>
<ol>
<li>可读性和可维护性的提升：小组件代码更短，且服务于同一目的；读者可以按层级理解代码。</li>
<li>可测试性的提升：小组件更容易做单元测试。</li>
<li>可复用性的提升：小组件可以在简单的调整和提取后被复用于其他场景。</li>
<li>性能的提升：state 的变化不再总是触发整个大组件的重渲染。</li>
</ol>
<h1 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h1><p>拆分组件时在文件结构上的最佳实践是，假设原来有一个大组件是 Complex.tsx，拆分后它应变成一个文件夹：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- Complex</span><br><span class="line">  - index.tsx // 简化后的大组件</span><br><span class="line">  - SubA.tsx // 拆分出来的小组件</span><br><span class="line">  - SubB.tsx // 拆分出来的小组件</span><br></pre></td></tr></table></figure>

<h1 id="State-最小集"><a href="#State-最小集" class="headerlink" title="State 最小集"></a>State 最小集</h1><p>渲染组件所需要的数据有以下来源：外部传入的 prop、组件内部的 state、全局 state（比如 redux store）、组件 scope 外的常量，以及由前面这些基础数据计算得到的间接数据（即 Vue 中的 computed）。</p>
<p>新人易犯的错误是将间接数据作为 state 来维护，然后用 <code>useEffect</code> 去监听其他 state&#x2F;prop 并重新计算该数据。</p>
<p>组件内部 state 应是一个最小集，不包含任何间接数据或常量。请阅读<a href="https://zh-hans.react.dev/learn/thinking-in-react#step-3-identify-the-minimal-but-complete-representation-of-ui-state">官方示例中的第三步</a>。</p>
<h1 id="Prop-的设计"><a href="#Prop-的设计" class="headerlink" title="Prop 的设计"></a>Prop 的设计</h1><p>Prop 的设计应尽量从组件本身的需求出发，而不是套用父组件已有的数据和方法。举例来说：</p>
<ol>
<li>如果子组件需要的数据 c 是由父组件中的 a 和 b 计算而来的，那么应该为 c 设计一个 prop，在父组件中用 a 和 b 计算出 c 之后传给子组件，而不是为 a 和 b 设计两个 prop，在子组件内部再计算 c。这一条原则也可以理解为 prop 最小集。</li>
<li>如果子组件需要反向传递数据去设置父组件的 state（假设要传递的数据是 date），不要设计一个 setDate prop 然后把父组件的 setDate 直接传给子组件，而是设计一个 onDateChange prop，允许父组件设置一个 callback 去监听子组件的 date 变化。子组件不关心父组件是要 setDate 还是做什么，子组件只负责“广播”自己的数据变化“事件”。</li>
</ol>
<h1 id="组件内的代码组织"><a href="#组件内的代码组织" class="headerlink" title="组件内的代码组织"></a>组件内的代码组织</h1><p>目前我们统一用 React hooks 编写组件，hooks 的一大优势就是允许我们将组件内的代码按业务逻辑而非性质分组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Bad</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// states</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [state1, setState1] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [state2, setState2] = <span class="title function_">useState</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// computed</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> computed1 = state1 + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> computed2 = !state2;</span><br><span class="line">  <span class="keyword">const</span> computed3 = <span class="string">`<span class="subst">$&#123;computed1&#125;</span> <span class="subst">$&#123;computed2&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// side effects</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">sideEffect1</span>();</span><br><span class="line">    <span class="title function_">sideEffect2</span>();</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Good</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// logic group 1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [state1, setState1] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> computed1 = state1 + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">sideEffect1</span>();</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// logic group 2</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [state2, setState2] = <span class="title function_">useState</span>(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">const</span> computed2 = !state2;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">sideEffect2</span>();</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// logic group 3</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> computed3 = <span class="string">`<span class="subst">$&#123;computed1&#125;</span> <span class="subst">$&#123;computed2&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果组件中有很多个逻辑分组，可能就是该组件需要进一步拆分的信号。</p>
<h1 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h1><p>当一个组件树中有很多不同层级的组件需要访问一批同样的数据时，完全用 prop 传递会导致中间层的组件为了往下传递而多出很多它自己并不关心的 prop，此时你通常需要 context 解决方案，请阅读<a href="https://zh-hans.legacy.reactjs.org/docs/context.html">官方文档</a>。</p>
<p>当需要层层传递的数据本身非常简单时，也有<a href="https://zh-hans.legacy.reactjs.org/docs/context.html#before-you-use-context">除了 context 之外的解决方案</a>。</p>
<h1 id="表现与逻辑的分离"><a href="#表现与逻辑的分离" class="headerlink" title="表现与逻辑的分离"></a>表现与逻辑的分离</h1><p>组件主要负责表现层（即 UI 层）的逻辑，因此复杂的数据处理逻辑原则上不属于组件的职责，应提取为工具函数而不是直接放一大段代码在组件内。这个职责分离的原则与上文组件拆分的原则在本质上是一致的，即每个单元应负责自己唯一的职责。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>JS 数组方法</title>
    <url>/2019/11/10/array-function/</url>
    <content><![CDATA[<h1 id="改变原数组的方法-9-个"><a href="#改变原数组的方法-9-个" class="headerlink" title="改变原数组的方法(9 个)"></a>改变原数组的方法(9 个)</h1><h2 id="1-splice-添加-删除数组元素"><a href="#1-splice-添加-删除数组元素" class="headerlink" title="1.splice() 添加 &#x2F; 删除数组元素"></a>1.splice() 添加 &#x2F; 删除数组元素</h2><p>splice() 方法向&#x2F;从数组中添加&#x2F;删除项目，然后返回被删除的项目</p>
<p><code>array.splice(index,howmany,item1,.....,itemX)</code></p>
<blockquote>
<p>index：必需。整数，规定添加&#x2F;删除项目的位置，使用负数可从数组结尾处规定位置。<br>howmany：可选。要删除的项目数量。如果设置为 0，则不会删除项目。<br>item1, …, itemX： 可选。向数组添加的新项目。<br>返回值: 如果有元素被删除,返回包含被删除项目的新数组。</p>
</blockquote>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从数组下标0开始，删除3个元素</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.<span class="title function_">splice</span>(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// [1,2,3]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// [4,5,6,7]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从最后一个元素开始删除3个元素，因为最后一个元素，所以只删除了7</span></span><br><span class="line"><span class="keyword">let</span> item = a.<span class="title function_">splice</span>(-<span class="number">1</span>, <span class="number">3</span>); <span class="comment">// [7]</span></span><br></pre></td></tr></table></figure>

<h3 id="删除并添加"><a href="#删除并添加" class="headerlink" title="删除并添加"></a>删除并添加</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从数组下标0开始，删除3个元素，并添加元素&#x27;添加&#x27;</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.<span class="title function_">splice</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="string">&quot;添加&quot;</span>); <span class="comment">// [1,2,3]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// [&#x27;添加&#x27;,4,5,6,7]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从数组最后第二个元素开始，删除3个元素，并添加两个元素&#x27;添加1&#x27;、&#x27;添加2&#x27;</span></span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> item = b.<span class="title function_">splice</span>(-<span class="number">2</span>, <span class="number">3</span>, <span class="string">&quot;添加1&quot;</span>, <span class="string">&quot;添加2&quot;</span>); <span class="comment">// [6,7]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// [1,2,3,4,5,&#x27;添加1&#x27;,&#x27;添加2&#x27;]</span></span><br></pre></td></tr></table></figure>

<h3 id="不删除只添加"><a href="#不删除只添加" class="headerlink" title="不删除只添加"></a>不删除只添加</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.<span class="title function_">splice</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;添加1&quot;</span>, <span class="string">&quot;添加2&quot;</span>); <span class="comment">// [] 没有删除元素，返回空数组</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// [&#x27;添加1&#x27;,&#x27;添加2&#x27;,1,2,3,4,5,6,7]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">let</span> item = b.<span class="title function_">splice</span>(-<span class="number">1</span>, <span class="number">0</span>, <span class="string">&quot;添加1&quot;</span>, <span class="string">&quot;添加2&quot;</span>); <span class="comment">// [] 没有删除元素，返回空数组</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// [1,2,3,4,5,6,&#x27;添加1&#x27;,&#x27;添加2&#x27;,7] 在最后一个元素的前面添加两个元素</span></span><br></pre></td></tr></table></figure>

<h2 id="2-sort-数组排序"><a href="#2-sort-数组排序" class="headerlink" title="2.sort() 数组排序"></a>2.sort() 数组排序</h2><p>sort() 方法对数组元素进行排序，并返回这个数组。</p>
<blockquote>
<p>参数可选: 规定排序顺序的比较函数。<br>默认情况下 sort() 方法没有传比较函数的话，默认按字母升序，如果不是元素不是字符串的话，会调用 <code>toString()</code> 方法将元素转化为字符串的 <code>Unicode</code> (万国码)位点，然后再比较字符。</p>
</blockquote>
<h3 id="不传参"><a href="#不传参" class="headerlink" title="不传参"></a>不传参</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串排列 看起来很正常</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Mango&quot;</span>];</span><br><span class="line">a.<span class="title function_">sort</span>(); <span class="comment">// [&quot;Apple&quot;,&quot;Banana&quot;,&quot;Mango&quot;,&quot;Orange&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数字排序的时候 因为转换成Unicode字符串之后，有些数字会比较大会排在后面 这显然不是我们想要的</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">8</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">sort</span>()); <span class="comment">// [1,10,20,25,3,8];</span></span><br></pre></td></tr></table></figure>

<h3 id="比较函数的两个参数："><a href="#比较函数的两个参数：" class="headerlink" title="比较函数的两个参数："></a>比较函数的两个参数：</h3><p>sort 的比较函数有两个默认参数，要在函数中接收这两个参数，这两个参数是数组中两个要比较的元素，通常我们用 a 和 b 接收两个将要比较的元素：</p>
<ul>
<li>若比较函数返回值 &lt;0 ，那么 a 将排到 b 的前面;</li>
<li>若比较函数返回值 &#x3D;0 ，那么 a 和 b 相对位置不变；</li>
<li>若比较函数返回值 &gt;0 ，那么 b 排在 a 将的前面；</li>
</ul>
<h3 id="数字升降序"><a href="#数字升降序" class="headerlink" title="数字升降序"></a>数字升降序</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">20</span>, <span class="number">4</span>, <span class="number">25</span>, <span class="number">8</span>];</span><br><span class="line">array.<span class="title function_">sort</span>(<span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array); <span class="comment">// [1,3,4,4,8,10,20,25];</span></span><br><span class="line"></span><br><span class="line">array.<span class="title function_">sort</span>(<span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> b - a;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array); <span class="comment">// [25,20,10,8,4,4,3,1];</span></span><br></pre></td></tr></table></figure>

<p>pop() 删除一个数组中的最后的一个元素<br>定义: pop() 方法删除一个数组中的最后的一个元素，并且返回这个元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.<span class="title function_">pop</span>(); <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// [1,2]</span></span><br></pre></td></tr></table></figure>

<h2 id="shift-删除数组的第一个元素"><a href="#shift-删除数组的第一个元素" class="headerlink" title="shift() 删除数组的第一个元素"></a>shift() 删除数组的第一个元素</h2><p>定义: shift()方法删除数组的第一个元素，并返回这个元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.<span class="title function_">shift</span>(); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// [2,3]</span></span><br></pre></td></tr></table></figure>

<h2 id="push-向数组的末尾添加元素"><a href="#push-向数组的末尾添加元素" class="headerlink" title="push() 向数组的末尾添加元素"></a>push() 向数组的末尾添加元素</h2><p>定义：push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。</p>
<p>参数: item1, item2, …, itemX ,要添加到数组末尾的元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.<span class="title function_">push</span>(<span class="string">&quot;末尾&quot;</span>, <span class="string">&quot;233&quot;</span>); <span class="comment">// 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// [1,2,3,&#x27;末尾&#x27;, &#x27;233&#x27;]</span></span><br></pre></td></tr></table></figure>

<h2 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h2><p>定义：unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。</p>
<p>参数: item1, item2, …, itemX ,要添加到数组开头的元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> item = a.<span class="title function_">unshift</span>(<span class="string">&quot;开头&quot;</span>, <span class="string">&quot;开头 2&quot;</span>); <span class="comment">// 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// [ &#x27;开头&#x27;, &#x27;开头 2&#x27;, 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure>

<h2 id="reverse-颠倒数组中元素的顺序"><a href="#reverse-颠倒数组中元素的顺序" class="headerlink" title="reverse() 颠倒数组中元素的顺序"></a>reverse() 颠倒数组中元素的顺序</h2><p>定义: reverse() 方法用于颠倒数组中元素的顺序。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a.<span class="title function_">reverse</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// [3,2,1]</span></span><br></pre></td></tr></table></figure>

<h1 id="不改变原数组的方法（8-个）"><a href="#不改变原数组的方法（8-个）" class="headerlink" title="不改变原数组的方法（8 个）"></a>不改变原数组的方法（8 个）</h1><h2 id="slice-浅拷贝数组的元素"><a href="#slice-浅拷贝数组的元素" class="headerlink" title="slice() 浅拷贝数组的元素"></a>slice() 浅拷贝数组的元素</h2><p>定义： 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象，且原数组不会被修改。</p>
<p>语法：<code>array.slice(begin, end);</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> b = a.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">1</span>); <span class="comment">// [&#x27;hello&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新数组是浅拷贝的，元素是简单数据类型，改变之后不会互相干扰。</span></span><br><span class="line"><span class="comment">// 如果是复杂数据类型(对象,数组)的话，改变其中一个，另外一个也会改变。</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="string">&quot;改变原数组&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b); <span class="comment">// [&#x27;改变原数组&#x27;,&#x27;world&#x27;] [&#x27;hello&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [&#123; <span class="attr">name</span>: <span class="string">&quot;OBKoro1&quot;</span> &#125;];</span><br><span class="line"><span class="keyword">let</span> b = a.<span class="title function_">slice</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b, a); <span class="comment">// [&#123;&quot;name&quot;:&quot;OBKoro1&quot;&#125;] [&#123;&quot;name&quot;:&quot;OBKoro1&quot;&#125;]</span></span><br><span class="line"><span class="comment">// a[0].name=&#x27;改变原数组&#x27;</span></span><br><span class="line"><span class="comment">// console.log(b,a) // [&#123;&quot;name&quot;:&quot;改变原数组&quot;&#125;] [&#123;&quot;name&quot;:&quot;改变原数组&quot;&#125;]</span></span><br></pre></td></tr></table></figure>

<h2 id="join-数组转字符串"><a href="#join-数组转字符串" class="headerlink" title="join() 数组转字符串"></a>join() 数组转字符串</h2><p>定义: join() 方法用于把数组中的所有元素通过指定的分隔符进行分隔放入一个字符串，返回生成的字符串。</p>
<p>语法: <code>array.join(str)</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> str = a.<span class="title function_">join</span>(); <span class="comment">// &#x27;hello,world&#x27;</span></span><br><span class="line"><span class="keyword">let</span> str2 = a.<span class="title function_">join</span>(<span class="string">&quot;+&quot;</span>); <span class="comment">// &#x27;hello+world&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [[<span class="string">&quot;OBKoro1&quot;</span>, <span class="string">&quot;23&quot;</span>], <span class="string">&quot;test&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> str1 = a.<span class="title function_">join</span>(); <span class="comment">// OBKoro1,23,test</span></span><br><span class="line"><span class="keyword">let</span> b = [&#123; <span class="attr">name</span>: <span class="string">&quot;OBKoro1&quot;</span>, <span class="attr">age</span>: <span class="string">&quot;23&quot;</span> &#125;, <span class="string">&quot;test&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> str2 = b.<span class="title function_">join</span>(); <span class="comment">// [object Object],test</span></span><br><span class="line"><span class="comment">// 对象转字符串推荐 JSON.stringify(obj)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结论：</span></span><br><span class="line"><span class="comment">// join()/toString() 方法在数组元素是数组的时候，会将里面的数组也调用 join()/toString() ,</span></span><br><span class="line"><span class="comment">// 如果是对象的话，对象会被转为 [object Object] 字符串。</span></span><br></pre></td></tr></table></figure>

<h2 id="toLocaleString-数组转字符串"><a href="#toLocaleString-数组转字符串" class="headerlink" title="toLocaleString() 数组转字符串"></a>toLocaleString() 数组转字符串</h2><p>定义: 返回一个表示数组元素的字符串。该字符串由数组中的每个元素的 <code>toLocaleString()</code> 返回值经调用 <code>join()</code> 方法连接（由逗号隔开）组成。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [&#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&#x27;OBKoro1&#x27;</span></span><br><span class="line">&#125;, <span class="number">23</span>, <span class="string">&#x27;abcd&#x27;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()]</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">join</span>(<span class="string">&quot;,&quot;</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">toString</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">toLocaleString</span>(<span class="string">&#x27;en-us&#x27;</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">toLocaleString</span>(<span class="string">&#x27;zh-cn&#x27;</span>))</span><br><span class="line"></span><br><span class="line">[object <span class="title class_">Object</span>],<span class="number">23</span>,abcd,<span class="title class_">Tue</span> <span class="title class_">Feb</span> <span class="number">26</span> <span class="number">2019</span> <span class="number">11</span>:<span class="number">47</span>:<span class="number">03</span> <span class="variable constant_">GMT</span>+<span class="number">0800</span> (中国标准时间)</span><br><span class="line">[object <span class="title class_">Object</span>],<span class="number">23</span>,abcd,<span class="title class_">Tue</span> <span class="title class_">Feb</span> <span class="number">26</span> <span class="number">2019</span> <span class="number">11</span>:<span class="number">47</span>:<span class="number">03</span> <span class="variable constant_">GMT</span>+<span class="number">0800</span> (中国标准时间)</span><br><span class="line">[object <span class="title class_">Object</span>],<span class="number">23</span>,abcd,<span class="number">2</span>/<span class="number">26</span>/<span class="number">2019</span>, <span class="number">11</span>:<span class="number">47</span>:<span class="number">03</span> <span class="variable constant_">AM</span></span><br><span class="line">[object <span class="title class_">Object</span>],<span class="number">23</span>,abcd,<span class="number">2019</span>/<span class="number">2</span>/<span class="number">26</span> 上午 <span class="number">11</span>:<span class="number">47</span>:<span class="number">03</span></span><br></pre></td></tr></table></figure>

<h2 id="concat-合并数组"><a href="#concat-合并数组" class="headerlink" title="concat 合并数组"></a>concat 合并数组</h2><p>定义： 方法用于合并两个或多个数组，返回一个新数组。</p>
<p>语法：<code>var newArr =oldArray.concat(arrayX,arrayX,......,arrayX)</code></p>
<p>参数：arrayX（必须）：该参数可以是具体的值，也可以是数组对象。可以是任意多个。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="comment">//连接两个数组</span></span><br><span class="line"><span class="keyword">let</span> newVal = a.<span class="title function_">concat</span>(b); <span class="comment">// [1,2,3,4,5,6]</span></span><br><span class="line"><span class="comment">// 连接三个数组</span></span><br><span class="line"><span class="keyword">let</span> c = [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">let</span> newVal2 = a.<span class="title function_">concat</span>(b, c); <span class="comment">// [1,2,3,4,5,6,7,8,9]</span></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line"><span class="keyword">let</span> newVal3 = a.<span class="title function_">concat</span>(<span class="string">&quot;添加元素&quot;</span>, b, c, <span class="string">&quot;再加一个&quot;</span>);</span><br><span class="line"><span class="comment">// [1,2,3,&quot;添加元素&quot;,4,5,6,7,8,9,&quot;再加一个&quot;]</span></span><br><span class="line"><span class="comment">// 合并嵌套数组 会浅拷贝嵌套数组</span></span><br><span class="line"><span class="keyword">let</span> d = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> f = [<span class="number">3</span>, [<span class="number">4</span>]];</span><br><span class="line"><span class="keyword">let</span> newVal4 = d.<span class="title function_">concat</span>(f); <span class="comment">// [1,2,3,[4]]</span></span><br></pre></td></tr></table></figure>

<h2 id="ES6-扩展运算符-…-合并数组"><a href="#ES6-扩展运算符-…-合并数组" class="headerlink" title="ES6 扩展运算符 … 合并数组"></a>ES6 扩展运算符 … 合并数组</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">4</span>, ...a, <span class="number">4</span>, <span class="number">4</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b); <span class="comment">//  [2, 3, 4, 5] [4,2,3,4,5,4,4]</span></span><br></pre></td></tr></table></figure>

<h2 id="indexOf-查找数组是否存在某个元素，返回下标"><a href="#indexOf-查找数组是否存在某个元素，返回下标" class="headerlink" title="indexOf() 查找数组是否存在某个元素，返回下标"></a>indexOf() 查找数组是否存在某个元素，返回下标</h2><p>定义: 返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。</p>
<p>p.s. 字符串也有此方法，要注意当 ‘lance’.indexOf(‘’) 一个空字符串时，返回 0 而不是-1</p>
<p>语法：<code>array.indexOf(searchElement,fromIndex)</code></p>
<p>参数：</p>
<blockquote>
<p>searchElement (必须):被查找的元素<br>fromIndex (可选):开始查找的位置(不能大于等于数组的长度，返回-1)，接受负值，默认值为 0。</p>
</blockquote>
<h3 id="严格相等的搜索"><a href="#严格相等的搜索" class="headerlink" title="严格相等的搜索:"></a>严格相等的搜索:</h3><p>数组的 indexOf 搜索跟字符串的 indexOf 不一样,数组的 indexOf 使用严格相等&#x3D;&#x3D;&#x3D;搜索元素，即数组元素要完全匹配才能搜索成功。</p>
<blockquote>
<p>注意：indexOf() 不能识别 NaN</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">&quot;啦啦&quot;</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">24</span>, <span class="title class_">NaN</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">indexOf</span>(<span class="string">&quot;啦&quot;</span>)); <span class="comment">// -1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">indexOf</span>(<span class="string">&quot;NaN&quot;</span>)); <span class="comment">// -1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">indexOf</span>(<span class="string">&quot;啦啦&quot;</span>)); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h2 id="lastIndexOf-查找指定元素在数组中的最后一个位置"><a href="#lastIndexOf-查找指定元素在数组中的最后一个位置" class="headerlink" title="lastIndexOf() 查找指定元素在数组中的最后一个位置"></a>lastIndexOf() 查找指定元素在数组中的最后一个位置</h2><p>定义: 方法返回指定元素,在数组中的最后一个的索引，如果不存在则返回 -1。（从数组后面往前查找）</p>
<p>语法：<code>arr.lastIndexOf(searchElement,fromIndex)</code></p>
<p>参数:</p>
<blockquote>
<p>searchElement(必须): 被查找的元素<br>fromIndex(可选): 逆向查找开始位置，默认值数组的 长度-1，即查找整个数组。</p>
</blockquote>
<p>关于 fromIndex 有三个规则:</p>
<ul>
<li>正值。如果该值大于或等于数组的长度，则整个数组会被查找。</li>
<li>负值。将其视为从数组末尾向前的偏移。(比如-2，从数组最后第二个元素开始往前查找)</li>
<li>负值。其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">&quot;OB&quot;</span>, <span class="number">4</span>, <span class="string">&quot;Koro1&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;Koro1&quot;</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="string">&quot;Koro1&quot;</span>]; <span class="comment">// 数组长度为 10</span></span><br><span class="line"><span class="comment">// let b=a.lastIndexOf(&#x27;Koro1&#x27;,4) // 从下标 4 开始往前找 返回下标 2</span></span><br><span class="line"><span class="comment">// let b=a.lastIndexOf(&#x27;Koro1&#x27;,100) // 大于或数组的长度 查找整个数组 返回 9</span></span><br><span class="line"><span class="comment">// let b=a.lastIndexOf(&#x27;Koro1&#x27;,-11) // -1 数组不会被查找</span></span><br><span class="line"><span class="keyword">let</span> b = a.<span class="title function_">lastIndexOf</span>(<span class="string">&quot;Koro1&quot;</span>, -<span class="number">9</span>); <span class="comment">// 从第二个元素 4 往前查找，没有找到 返回-1</span></span><br></pre></td></tr></table></figure>

<h2 id="ES7-includes-查找数组是否包含某个元素-返回布尔"><a href="#ES7-includes-查找数组是否包含某个元素-返回布尔" class="headerlink" title="ES7 includes() 查找数组是否包含某个元素 返回布尔"></a>ES7 includes() 查找数组是否包含某个元素 返回布尔</h2><p>定义： 返回一个布尔值，表示某个数组是否包含给定的值</p>
<p>语法：<code>array.includes(searchElement,fromIndex=0)</code></p>
<p>参数：</p>
<blockquote>
<p>searchElement (必须):被查找的元素<br>fromIndex (可选):默认值为 0 ，参数表示搜索的起始位置，接受负值。正值超过数组长度，数组不会被搜索，返回 false 。负值绝对值超过长数组度，重置从 0 开始搜索。</p>
</blockquote>
<ul>
<li>includes 方法是为了弥补 indexOf 方法的缺陷而出现的:</li>
<li>indexOf 方法不能识别 NaN</li>
<li>indexOf 方法检查是否包含某个值不够语义化，需要判断是否不等于 -1 ，表达不够直观</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">&quot;OB&quot;</span>, <span class="string">&quot;Koro1&quot;</span>, <span class="number">1</span>, <span class="title class_">NaN</span>];</span><br><span class="line"><span class="comment">// let b=a.includes(NaN) // true 识别NaN</span></span><br><span class="line"><span class="comment">// let b=a.includes(&#x27;Koro1&#x27;,100) // false 超过数组长度 不搜索</span></span><br><span class="line"><span class="comment">// let b=a.includes(&#x27;Koro1&#x27;,-3)  // true 从倒数第三个元素开始搜索</span></span><br><span class="line"><span class="comment">// let b=a.includes(&#x27;Koro1&#x27;,-100)  // true 负值绝对值超过数组长度，搜索整个数组</span></span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://juejin.im/post/5b0903b26fb9a07a9d70c7e0">js 数组详细操作方法及解析合集</a></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
</search>
